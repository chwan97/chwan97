module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded chunks
/******/ 	// "0" means "already loaded"
/******/ 	var installedChunks = {
/******/ 		0: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// require() chunk loading for javascript
/******/
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] !== 0) {
/******/ 			var chunk = require("./" + ({"1":"components/nuxt-logo","2":"components/tutorial","3":"pages/index"}[chunkId]||chunkId) + ".js");
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids;
/******/ 			for(var moduleId in moreModules) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/_nuxt/";
/******/
/******/ 	// uncaught error handler for webpack runtime
/******/ 	__webpack_require__.oe = function(err) {
/******/ 		process.nextTick(function() {
/******/ 			throw err; // catch this error by using import().catch()
/******/ 		});
/******/ 	};
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 95);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("vue");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("@emotion/css");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


var chakraUiStyledSystem_esm = __webpack_require__(4);

var css = __webpack_require__(1);

var colorModeObserver = __webpack_require__(3);
/** Detect free variable `global` from Node.js. */


var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
/** Built-in value references. */

var Symbol$1 = root.Symbol;
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}
/** Used for built-in method references. */


var objectProto$1 = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString$1 = objectProto$1.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString$1.call(value);
}
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag$1 && symToStringTag$1 in Object(value) ? getRawTag(value) : objectToString(value);
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */


function isObjectLike(value) {
  return value != null && typeof value == 'object';
}
/** `Object#toString` result references. */


var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */


function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */


var isArray = Array.isArray;
/** Used as references for various `Number` constants. */

var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */


function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}
/** Used as references for various `Number` constants. */


var NAN = 0 / 0;
/** Used to match leading and trailing whitespace. */

var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */

function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
/** Used as references for various `Number` constants. */


var INFINITY$1 = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;
/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */

function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }

  value = toNumber(value);

  if (value === INFINITY$1 || value === -INFINITY$1) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }

  return value === value ? value : 0;
}
/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */


function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */


function identity(value) {
  return value;
}
/** `Object#toString` result references. */


var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
/** Used to detect overreaching core-js shims. */


var coreJsData = root['__core-js_shared__'];
/** Used to detect methods masquerading as native. */

var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
/** Used for built-in method references. */


var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */


var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto$1 = Function.prototype,
    objectProto$2 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$1 = funcProto$1.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */


function getValue(object, key) {
  return object == null ? undefined : object[key];
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}
/* Built-in method references that are verified to be native. */


var WeakMap$1 = getNative(root, 'WeakMap');
/** Built-in value references. */

var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */


function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */


function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}
/** Used to detect hot functions by number of calls within a span of milliseconds. */


var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */


function constant(value) {
  return function () {
    return value;
  };
}

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();
/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};
/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var setToString = shortOut(baseSetToString);
/** Used as references for various `Number` constants. */

var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */


function eq(value, other) {
  return value === other || value !== value && other !== other;
}
/** Used for built-in method references. */


var objectProto$3 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty$2.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */


function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */


function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}
/** Used as references for various `Number` constants. */


var MAX_SAFE_INTEGER$1 = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */


function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */


function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }

  var type = typeof index;

  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }

  return false;
}
/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */


function createAssigner(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}
/** Used for built-in method references. */


var objectProto$4 = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$4;
  return value === proto;
}
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */


function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}
/** `Object#toString` result references. */


var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}
/** Used for built-in method references. */


var objectProto$5 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$3 = objectProto$5.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty$3.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */

function stubFalse() {
  return false;
}
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
/** `Object#toString` result references. */

var argsTag$1 = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */


function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}
/** Detect free variable `exports`. */


var freeExports$1 =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports$1 && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();
/* Node.js helper references. */


var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
/** Used for built-in method references. */

var objectProto$6 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */


function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeKeys = overArg(Object.keys, Object);
/** Used for built-in method references. */

var objectProto$7 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty$5.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */


function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */


function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}
/** Used for built-in method references. */


var objectProto$8 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$6.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */


function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
/** Used to match property names within property paths. */


var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = typeof value;

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
/* Built-in method references that are verified to be native. */


var nativeCreate = getNative(Object, 'create');
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */

function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto$9 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty$7.call(data, key) ? data[key] : undefined;
}
/** Used for built-in method references. */


var objectProto$a = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty$8.call(data, key);
}
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
  return this;
}
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */

function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}
/** Used for built-in method references. */


var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/* Built-in method references that are verified to be native. */

var Map$1 = getNative(root, 'Map');
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */

function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map$1 || ListCache)(),
    'string': new Hash()
  };
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */


function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/** Error message constants. */

var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;
/** Used as the maximum memoize cache size. */

var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}
/** Used to match property names within property paths. */


var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
    result.push('');
  }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */

function toString(value) {
  return value == null ? '' : baseToString(value);
}
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */


function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}
/** Used as references for various `Number` constants. */


var INFINITY$2 = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY$2 ? '-0' : result;
}
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */


function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}
/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */


function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */


function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}
/** Built-in value references. */


var getPrototype = overArg(Object.getPrototypeOf, Object);
/** `Object#toString` result references. */

var objectTag$1 = '[object Object]';
/** Used for built-in method references. */

var funcProto$2 = Function.prototype,
    objectProto$b = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$2 = funcProto$2.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString$2.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$1) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty$9.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
}
/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */


function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }

    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }

  return number;
}
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */


function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function stackGet(key) {
  return this.__data__.get(key);
}
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function stackHas(key) {
  return this.__data__.has(key);
}
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
/** Detect free variable `exports`. */

var freeExports$2 =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
/** Built-in value references. */

var Buffer$1 = moduleExports$2 ? root.Buffer : undefined,
    allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */


function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */


function stubArray() {
  return [];
}
/** Used for built-in method references. */


var objectProto$c = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable$1 = objectProto$c.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbolsIn = !nativeGetSymbols$1 ? stubArray : function (object) {
  var result = [];

  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }

  return result;
};
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */

function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}
/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}
/* Built-in method references that are verified to be native. */


var DataView = getNative(root, 'DataView');
/* Built-in method references that are verified to be native. */

var Promise$1 = getNative(root, 'Promise');
/* Built-in method references that are verified to be native. */

var Set = getNative(root, 'Set');
/** `Object#toString` result references. */

var mapTag$1 = '[object Map]',
    objectTag$2 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$1 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';
var dataViewTag$1 = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map$1),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap$1);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$1 || Map$1 && getTag(new Map$1()) != mapTag$1 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set && getTag(new Set()) != setTag$1 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
  getTag = function (value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$2 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$1;

        case mapCtorString:
          return mapTag$1;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag$1;

        case weakMapCtorString:
          return weakMapTag$1;
      }
    }

    return result;
  };
}

var getTag$1 = getTag;
/** Built-in value references. */

var Uint8Array = root.Uint8Array;
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */

function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */


function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */


function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED$2);

  return this;
}
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */


function setCacheHas(value) {
  return this.__data__.has(value);
}
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */


function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */

function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function cacheHas(cache, key) {
  return cache.has(key);
}
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Assume cyclic values are equal.


  var stacked = stack.get(array);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */


function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */


function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;
/** `Object#toString` result references. */

var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$1 = '[object Error]',
    mapTag$2 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag$1 = '[object Symbol]';
var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$2 = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$2:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag$1:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag$1:
      return object.name == other.name && object.message == other.message;

    case regexpTag$1:
    case stringTag$1:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag$2:
      var convert = mapToArray;

    case setTag$2:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG$1; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG$2 = 1;
/** Used for built-in method references. */

var objectProto$d = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$a = objectProto$d.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty$a.call(other, key))) {
      return false;
    }
  } // Assume cyclic values are equal.


  var stacked = stack.get(object);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG$3 = 1;
/** `Object#toString` result references. */

var argsTag$2 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    objectTag$3 = '[object Object]';
/** Used for built-in method references. */

var objectProto$e = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$b = objectProto$e.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag$1 : getTag$1(object),
      othTag = othIsArr ? arrayTag$1 : getTag$1(other);
  objTag = objTag == argsTag$2 ? objectTag$3 : objTag;
  othTag = othTag == argsTag$2 ? objectTag$3 : othTag;
  var objIsObj = objTag == objectTag$3,
      othIsObj = othTag == objectTag$3,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
    var objIsWrapped = objIsObj && hasOwnProperty$b.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$b.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */


function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}
/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */


function isStrictComparable(value) {
  return value === value && !isObject(value);
}
/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */


function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }

  return result;
}
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */


function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}
/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */


function baseMatches(source) {
  var matchData = getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */


function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */


function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}
/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */


function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }

  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
  };
}
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */


function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}
/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */


function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}
/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */


function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */


function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return identity;
  }

  if (typeof value == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }

  return property(value);
}
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */


function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */


var baseFor = createBaseFor();
/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignMergeValue(object, key, value) {
  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */


function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */


function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}
/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */


function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}
/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */


function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }

  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;

    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;

      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }

  assignMergeValue(object, key, newValue);
}
/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */


function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }

  baseFor(source, function (srcValue, key) {
    stack || (stack = new Stack());

    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }

      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */


var merge = createAssigner(function (object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */

function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }

  path = castPath(path, object);
  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;

      if (newValue === undefined) {
        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
      }
    }

    assignValue(nested, key, newValue);
    nested = nested[key];
  }

  return object;
}
/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */


function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }

  return result;
}
/**
 * Creates an object composed of the `object` properties `predicate` returns
 * truthy for. The predicate is invoked with two arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} [predicate=_.identity] The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pickBy(object, _.isNumber);
 * // => { 'a': 1, 'c': 3 }
 */


function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }

  var props = arrayMap(getAllKeysIn(object), function (prop) {
    return [prop];
  });
  predicate = baseIteratee(predicate);
  return basePickBy(object, props, function (value, path) {
    return predicate(value, path[0]);
  });
}
/**
 * Checks if `string` starts with the given target string.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {string} [target] The string to search for.
 * @param {number} [position=0] The position to search from.
 * @returns {boolean} Returns `true` if `string` starts with `target`,
 *  else `false`.
 * @example
 *
 * _.startsWith('abc', 'a');
 * // => true
 *
 * _.startsWith('abc', 'b');
 * // => false
 *
 * _.startsWith('abc', 'b', 1);
 * // => true
 */


function startsWith(string, target, position) {
  string = toString(string);
  position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
  target = baseToString(target);
  return string.slice(position, position + target.length) == target;
}
/**
 * @param {String} prefix - prefix for the icon pack
 * @param {Array} icon - icon definition
 * @returns {{path: string, viewBox: string, attrs: *}}
 */


var createIcon = function createIcon(prefix, icon) {
  var w = icon[0];
  var h = icon[1];
  var content = icon[2];
  var svg = icon[3];
  var data = icon[4];
  var attrs = icon[6];
  var path;

  var createPath = function createPath(d, attrs) {
    if (attrs === void 0) attrs = {};
    return "<path d=\"" + d + "\" " + (attrs.className ? "class=\"" + attrs.className + "\"" : '') + " fill=\"currentColor\" />";
  };

  var createGroupedPath = function createGroupedPath(groups, prefix) {
    var paths = groups.map(function (d, idx) {
      return createPath(d, {
        className: idx ? prefix + "-primary" : prefix + "-secondary"
      });
    });
    return "<g fill=\"currentColor\" class=\"" + prefix + "-group\">" + paths.join('') + "</g>";
  };

  if (prefix.startsWith('fa')) {
    path = Array.isArray(data) ? createGroupedPath(data, prefix.substr(0, 2)) : createPath(data);
  } else {
    path = prefix.startsWith('fe') ? content : svg;
  }

  return {
    path: path,
    viewBox: "0 0 " + w + " " + h,
    attrs: attrs
  };
};
/**
 * @description Custom parse all Icons provided by user
 * @param {Object} iconSet - Registered Icons object
 * @returns {Object}
 */


var parseIcons = function parseIcons(iconSet) {
  if (iconSet === void 0) iconSet = {};

  var parseIcon = function parseIcon(iconObject) {
    var obj;
    var icon = iconObject.icon;
    var prefix = iconObject.prefix;
    var iconName = iconObject.iconName; // Is library icon

    if (icon) {
      return obj = {}, obj["" + iconName] = createIcon(prefix, icon), obj;
    } else {
      return {};
    }
  };

  return Object.values(iconSet).map(function (value) {
    return parseIcon(value);
  }).reduce(function (target, source) {
    return merge(target, source);
  }, {});
};
/**
 * @description Parse Icon packs
 * @param {Object} iconSet Registered Icon set
 * @returns {Object} Parsed pack icons object
 */


var parsePackIcons = function parsePackIcons(iconSet) {
  // TODO: Add support for other icon libraries
  // - Material Icons: these are string constants, and need lots of work
  // - Tailwind Icons (Hero icons)
  return parseIcons(iconSet);
};

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var Logger = function Logger(options) {
  this.isDebug = false;
  /**
   * @description Logs message to console.
   * @param {*} payload - Payload
   **/

  this.debug = function () {
    var payload = [],
        len = arguments.length;

    while (len--) {
      payload[len] = arguments[len];
    }

    var log = payload.length > 1 ? payload : payload[0];
    console.log && console.log(log);
  };
  /**
   * @description Logs error message to console.
   * @param {*} payload - Payload
   **/


  this.error = function () {
    var payload = [],
        len = arguments.length;

    while (len--) {
      payload[len] = arguments[len];
    }

    var log = payload.length > 1 ? payload : payload[0];
    console.error && console.error(log);
  };
  /**
   * @description Logs warning message to console.
   * @param {*} payload - Payload
   **/


  this.warn = function () {
    var payload = [],
        len = arguments.length;

    while (len--) {
      payload[len] = arguments[len];
    }

    var log = payload.length > 1 ? payload : payload[0];
    console.warn && console.warn(log);
  };
  /**
   * @description Logs info message to console.
   * @param {*} payload - Payload
   **/


  this.info = function () {
    var payload = [],
        len = arguments.length;

    while (len--) {
      payload[len] = arguments[len];
    }

    var log = payload.length > 1 ? payload : payload[0];
    console.info && console.info(log);
  };
  /**
   * @description Logs success message to console.
   * @param {*} payload - Payload
   **/


  this.success = function () {
    var payload = [],
        len = arguments.length;

    while (len--) {
      payload[len] = arguments[len];
    }

    var log = payload.length > 1 ? payload : payload[0];
    console.info && console.info(log);
  };

  this.isDebug = options.debug;
};
/**
 * Converts value to percentage
 * @param {Number} value Value
 * @param {Number} min Minimum value
 * @param {Number} max Maximum value
 * @returns {Number} Percentage value
 */


function valueToPercent(value, min, max) {
  return (value - min) * 100 / (max - min);
}
/**
 * Converts percentage to value
 * @param {Number} percent Percentage Value
 * @param {Number} min Minimum value
 * @param {Number} max Maximum value
 * @returns {Number} Numerical value
 */


function percentToValue(percent, min, max) {
  return (max - min) * percent + min;
}
/**
 * @description Returns the substring after a certain character in a string.
 * @param {'String'} string
 * @param {'String'} char
 */


function getSubstringAfterChar(string, char) {
  return string.slice(string.indexOf(char) + 1);
}
/**
 * @description Returns the substring before a certain character in a string.
 * @param {'String'} string
 * @param {'String'} char
 */


function getSubstringBeforeChar(string, char) {
  return string.slice(0, string.indexOf(char));
}
/**
 * Transforms a string to Kebab case
 * @param {String} text String to transform to kebab case
 */


function kebabify(text) {
  return text && text.match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g).map(function (x) {
    return x.toLowerCase();
  }).join('-');
}
/**
 * Converts a kebab-case string into camel case
 * @param {String} string
 */


function camelize(string) {
  return string.replace(/[.-](\w|$)/g, function (_, x) {
    return x.toUpperCase();
  });
}
/**
 * Clears out all undefined properties from an object.
 * @param {Object} props
 * @returns {Object} Sanitized object with defined values.
 */


function pickProperty(props) {
  var pure = {};

  for (var prop in props) {
    if (props[prop] !== undefined) {
      pure[prop] = props[prop];
    }
  }

  return pure;
}
/**
 * Extracts pseudo style props from props objects
 * @param {Object} props
 * @returns {Object} Pseudo styles object
 */


function filterPseudo(props) {
  var pseudos = pickBy(props, function (_value, key) {
    return startsWith(key, '_');
  });
  return pseudos;
}
/**
 * Extracts style props from merged spseudo styes object
 * @param {Object} props
 * @returns {Object} Base styles object
 */


function filterBaseStyles(props) {
  var pseudos = pickBy(props, function (_value, key) {
    return !startsWith(key, '_');
  });
  return pseudos;
}
/** Filter attrs and return object of chakra props */


function extractChakraAttrs(attrs) {
  var styleAttrs = {};
  var nativeAttrs = {};

  for (var _prop in attrs) {
    var prop = camelize(_prop);

    if (chakraUiStyledSystem_esm.isStyleProp(prop)) {
      styleAttrs[prop] = attrs[_prop];
    } else {
      nativeAttrs[_prop] = attrs[_prop];
    }
  }

  return {
    styleAttrs: styleAttrs,
    nativeAttrs: nativeAttrs
  };
}
/**
 * Check if a given value is a non-null object.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is a non-null object, else `false`.
 */


function isNonNullObject(value) {
  return _typeof(value) === 'object' && value !== null;
}
/**
 * Checks if object has a specific property.
 * @param {Object} obj
 * @param {String} prop
 */


var hasOwn = function hasOwn(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};
/**
 * Checks to see if objects in empty
 * @param {Object} object
 */


function isEmpty(object) {
  for (var key in object) {
    // Should iterate only once
    if (hasOwn(object, key)) {
      return false;
    }

    return true;
  }
}
/**
 * Splits user styles into base and pseudo styles
 * @param {Object} props styles objects
 * @returns {{ baseStyles: Object, pseudoStyles: Object }}
 */


function splitProps(props) {
  var baseStyles = {};
  var pseudoStyles = {};
  var styles = {
    baseStyles: baseStyles,
    pseudoStyles: pseudoStyles
  };

  if (!props || isEmpty(props)) {
    return styles;
  }

  for (var key in props) {
    if (key.startsWith('_')) {
      styles.pseudoStyles[key] = props[key];
    } else {
      styles.baseStyles[key] = props[key];
    }
  }

  return styles;
}

var colorName = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};

var isArrayish = function isArrayish(obj) {
  if (!obj || typeof obj === 'string') {
    return false;
  }

  return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== 'String');
};

var simpleSwizzle = chakraUiStyledSystem_esm.createCommonjsModule(function (module) {
  var concat = Array.prototype.concat;
  var slice = Array.prototype.slice;

  var swizzle = module.exports = function swizzle(args) {
    var results = [];

    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];

      if (isArrayish(arg)) {
        // http://jsperf.com/javascript-array-concat-vs-push/98
        results = concat.call(results, slice.call(arg));
      } else {
        results.push(arg);
      }
    }

    return results;
  };

  swizzle.wrap = function (fn) {
    return function () {
      return fn(swizzle(arguments));
    };
  };
});
var colorString = chakraUiStyledSystem_esm.createCommonjsModule(function (module) {
  /* MIT license */
  var reverseNames = {}; // create a list of reverse color names

  for (var name in colorName) {
    if (colorName.hasOwnProperty(name)) {
      reverseNames[colorName[name]] = name;
    }
  }

  var cs = module.exports = {
    to: {},
    get: {}
  };

  cs.get = function (string) {
    var prefix = string.substring(0, 3).toLowerCase();
    var val;
    var model;

    switch (prefix) {
      case 'hsl':
        val = cs.get.hsl(string);
        model = 'hsl';
        break;

      case 'hwb':
        val = cs.get.hwb(string);
        model = 'hwb';
        break;

      default:
        val = cs.get.rgb(string);
        model = 'rgb';
        break;
    }

    if (!val) {
      return null;
    }

    return {
      model: model,
      value: val
    };
  };

  cs.get.rgb = function (string) {
    if (!string) {
      return null;
    }

    var abbr = /^#([a-f0-9]{3,4})$/i;
    var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
    var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
    var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
    var keyword = /(\D+)/;
    var rgb = [0, 0, 0, 1];
    var match;
    var i;
    var hexAlpha;

    if (match = string.match(hex)) {
      hexAlpha = match[2];
      match = match[1];

      for (i = 0; i < 3; i++) {
        // https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
        var i2 = i * 2;
        rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
      }

      if (hexAlpha) {
        rgb[3] = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;
      }
    } else if (match = string.match(abbr)) {
      match = match[1];
      hexAlpha = match[3];

      for (i = 0; i < 3; i++) {
        rgb[i] = parseInt(match[i] + match[i], 16);
      }

      if (hexAlpha) {
        rgb[3] = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;
      }
    } else if (match = string.match(rgba)) {
      for (i = 0; i < 3; i++) {
        rgb[i] = parseInt(match[i + 1], 0);
      }

      if (match[4]) {
        rgb[3] = parseFloat(match[4]);
      }
    } else if (match = string.match(per)) {
      for (i = 0; i < 3; i++) {
        rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }

      if (match[4]) {
        rgb[3] = parseFloat(match[4]);
      }
    } else if (match = string.match(keyword)) {
      if (match[1] === 'transparent') {
        return [0, 0, 0, 0];
      }

      rgb = colorName[match[1]];

      if (!rgb) {
        return null;
      }

      rgb[3] = 1;
      return rgb;
    } else {
      return null;
    }

    for (i = 0; i < 3; i++) {
      rgb[i] = clamp(rgb[i], 0, 255);
    }

    rgb[3] = clamp(rgb[3], 0, 1);
    return rgb;
  };

  cs.get.hsl = function (string) {
    if (!string) {
      return null;
    }

    var hsl = /^hsla?\(\s*([+-]?(?:\d*\.)?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
    var match = string.match(hsl);

    if (match) {
      var alpha = parseFloat(match[4]);
      var h = (parseFloat(match[1]) + 360) % 360;
      var s = clamp(parseFloat(match[2]), 0, 100);
      var l = clamp(parseFloat(match[3]), 0, 100);
      var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s, l, a];
    }

    return null;
  };

  cs.get.hwb = function (string) {
    if (!string) {
      return null;
    }

    var hwb = /^hwb\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
    var match = string.match(hwb);

    if (match) {
      var alpha = parseFloat(match[4]);
      var h = (parseFloat(match[1]) % 360 + 360) % 360;
      var w = clamp(parseFloat(match[2]), 0, 100);
      var b = clamp(parseFloat(match[3]), 0, 100);
      var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b, a];
    }

    return null;
  };

  cs.to.hex = function () {
    var rgba = simpleSwizzle(arguments);
    return '#' + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : '');
  };

  cs.to.rgb = function () {
    var rgba = simpleSwizzle(arguments);
    return rgba.length < 4 || rgba[3] === 1 ? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')' : 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
  };

  cs.to.rgb.percent = function () {
    var rgba = simpleSwizzle(arguments);
    var r = Math.round(rgba[0] / 255 * 100);
    var g = Math.round(rgba[1] / 255 * 100);
    var b = Math.round(rgba[2] / 255 * 100);
    return rgba.length < 4 || rgba[3] === 1 ? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)' : 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
  };

  cs.to.hsl = function () {
    var hsla = simpleSwizzle(arguments);
    return hsla.length < 4 || hsla[3] === 1 ? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)' : 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
  }; // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
  // (hwb have alpha optional & 1 is default value)


  cs.to.hwb = function () {
    var hwba = simpleSwizzle(arguments);
    var a = '';

    if (hwba.length >= 4 && hwba[3] !== 1) {
      a = ', ' + hwba[3];
    }

    return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
  };

  cs.to.keyword = function (rgb) {
    return reverseNames[rgb.slice(0, 3)];
  }; // helpers


  function clamp(num, min, max) {
    return Math.min(Math.max(min, num), max);
  }

  function hexDouble(num) {
    var str = num.toString(16).toUpperCase();
    return str.length < 2 ? '0' + str : str;
  }
});
var colorString_1 = colorString.to;
var colorString_2 = colorString.get;
var colorName$1 = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};
var conversions = chakraUiStyledSystem_esm.createCommonjsModule(function (module) {
  /* MIT license */
  // NOTE: conversions should only return primitive values (i.e. arrays, or
  //       values that give correct `typeof` results).
  //       do not use box values types (i.e. Number(), String(), etc.)
  var reverseKeywords = {};

  for (var key in colorName$1) {
    if (colorName$1.hasOwnProperty(key)) {
      reverseKeywords[colorName$1[key]] = key;
    }
  }

  var convert = module.exports = {
    rgb: {
      channels: 3,
      labels: 'rgb'
    },
    hsl: {
      channels: 3,
      labels: 'hsl'
    },
    hsv: {
      channels: 3,
      labels: 'hsv'
    },
    hwb: {
      channels: 3,
      labels: 'hwb'
    },
    cmyk: {
      channels: 4,
      labels: 'cmyk'
    },
    xyz: {
      channels: 3,
      labels: 'xyz'
    },
    lab: {
      channels: 3,
      labels: 'lab'
    },
    lch: {
      channels: 3,
      labels: 'lch'
    },
    hex: {
      channels: 1,
      labels: ['hex']
    },
    keyword: {
      channels: 1,
      labels: ['keyword']
    },
    ansi16: {
      channels: 1,
      labels: ['ansi16']
    },
    ansi256: {
      channels: 1,
      labels: ['ansi256']
    },
    hcg: {
      channels: 3,
      labels: ['h', 'c', 'g']
    },
    apple: {
      channels: 3,
      labels: ['r16', 'g16', 'b16']
    },
    gray: {
      channels: 1,
      labels: ['gray']
    }
  }; // hide .channels and .labels properties

  for (var model in convert) {
    if (convert.hasOwnProperty(model)) {
      if (!('channels' in convert[model])) {
        throw new Error('missing channels property: ' + model);
      }

      if (!('labels' in convert[model])) {
        throw new Error('missing channel labels property: ' + model);
      }

      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error('channel and label counts mismatch: ' + model);
      }

      var channels = convert[model].channels;
      var labels = convert[model].labels;
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], 'channels', {
        value: channels
      });
      Object.defineProperty(convert[model], 'labels', {
        value: labels
      });
    }
  }

  convert.rgb.hsl = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h;
    var s;
    var l;

    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }

    h = Math.min(h * 60, 360);

    if (h < 0) {
      h += 360;
    }

    l = (min + max) / 2;

    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }

    return [h, s * 100, l * 100];
  };

  convert.rgb.hsv = function (rgb) {
    var rdif;
    var gdif;
    var bdif;
    var h;
    var s;
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var v = Math.max(r, g, b);
    var diff = v - Math.min(r, g, b);

    var diffc = function (c) {
      return (v - c) / 6 / diff + 1 / 2;
    };

    if (diff === 0) {
      h = s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);

      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }

      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }

    return [h * 360, s * 100, v * 100];
  };

  convert.rgb.hwb = function (rgb) {
    var r = rgb[0];
    var g = rgb[1];
    var b = rgb[2];
    var h = convert.rgb.hsl(rgb)[0];
    var w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };

  convert.rgb.cmyk = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var c;
    var m;
    var y;
    var k;
    k = Math.min(1 - r, 1 - g, 1 - b);
    c = (1 - r - k) / (1 - k) || 0;
    m = (1 - g - k) / (1 - k) || 0;
    y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  /**
   * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
   * */


  function comparativeDistance(x, y) {
    return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
  }

  convert.rgb.keyword = function (rgb) {
    var reversed = reverseKeywords[rgb];

    if (reversed) {
      return reversed;
    }

    var currentClosestDistance = Infinity;
    var currentClosestKeyword;

    for (var keyword in colorName$1) {
      if (colorName$1.hasOwnProperty(keyword)) {
        var value = colorName$1[keyword]; // Compute comparative distance

        var distance = comparativeDistance(rgb, value); // Check if its less, if so set as closest

        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
    }

    return currentClosestKeyword;
  };

  convert.keyword.rgb = function (keyword) {
    return colorName$1[keyword];
  };

  convert.rgb.xyz = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255; // assume sRGB

    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };

  convert.rgb.lab = function (rgb) {
    var xyz = convert.rgb.xyz(rgb);
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };

  convert.hsl.rgb = function (hsl) {
    var h = hsl[0] / 360;
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var t1;
    var t2;
    var t3;
    var rgb;
    var val;

    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }

    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }

    t1 = 2 * l - t2;
    rgb = [0, 0, 0];

    for (var i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);

      if (t3 < 0) {
        t3++;
      }

      if (t3 > 1) {
        t3--;
      }

      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }

      rgb[i] = val * 255;
    }

    return rgb;
  };

  convert.hsl.hsv = function (hsl) {
    var h = hsl[0];
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var smin = s;
    var lmin = Math.max(l, 0.01);
    var sv;
    var v;
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    v = (l + s) / 2;
    sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };

  convert.hsv.rgb = function (hsv) {
    var h = hsv[0] / 60;
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var hi = Math.floor(h) % 6;
    var f = h - Math.floor(h);
    var p = 255 * v * (1 - s);
    var q = 255 * v * (1 - s * f);
    var t = 255 * v * (1 - s * (1 - f));
    v *= 255;

    switch (hi) {
      case 0:
        return [v, t, p];

      case 1:
        return [q, v, p];

      case 2:
        return [p, v, t];

      case 3:
        return [p, q, v];

      case 4:
        return [t, p, v];

      case 5:
        return [v, p, q];
    }
  };

  convert.hsv.hsl = function (hsv) {
    var h = hsv[0];
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var vmin = Math.max(v, 0.01);
    var lmin;
    var sl;
    var l;
    l = (2 - s) * v;
    lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  }; // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


  convert.hwb.rgb = function (hwb) {
    var h = hwb[0] / 360;
    var wh = hwb[1] / 100;
    var bl = hwb[2] / 100;
    var ratio = wh + bl;
    var i;
    var v;
    var f;
    var n; // wh + bl cant be > 1

    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }

    i = Math.floor(6 * h);
    v = 1 - bl;
    f = 6 * h - i;

    if ((i & 0x01) !== 0) {
      f = 1 - f;
    }

    n = wh + f * (v - wh); // linear interpolation

    var r;
    var g;
    var b;

    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;

      case 1:
        r = n;
        g = v;
        b = wh;
        break;

      case 2:
        r = wh;
        g = v;
        b = n;
        break;

      case 3:
        r = wh;
        g = n;
        b = v;
        break;

      case 4:
        r = n;
        g = wh;
        b = v;
        break;

      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }

    return [r * 255, g * 255, b * 255];
  };

  convert.cmyk.rgb = function (cmyk) {
    var c = cmyk[0] / 100;
    var m = cmyk[1] / 100;
    var y = cmyk[2] / 100;
    var k = cmyk[3] / 100;
    var r;
    var g;
    var b;
    r = 1 - Math.min(1, c * (1 - k) + k);
    g = 1 - Math.min(1, m * (1 - k) + k);
    b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };

  convert.xyz.rgb = function (xyz) {
    var x = xyz[0] / 100;
    var y = xyz[1] / 100;
    var z = xyz[2] / 100;
    var r;
    var g;
    var b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB

    r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };

  convert.xyz.lab = function (xyz) {
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };

  convert.lab.xyz = function (lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var x;
    var y;
    var z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    var y2 = Math.pow(y, 3);
    var x2 = Math.pow(x, 3);
    var z2 = Math.pow(z, 3);
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };

  convert.lab.lch = function (lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var hr;
    var h;
    var c;
    hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;

    if (h < 0) {
      h += 360;
    }

    c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };

  convert.lch.lab = function (lch) {
    var l = lch[0];
    var c = lch[1];
    var h = lch[2];
    var a;
    var b;
    var hr;
    hr = h / 360 * 2 * Math.PI;
    a = c * Math.cos(hr);
    b = c * Math.sin(hr);
    return [l, a, b];
  };

  convert.rgb.ansi16 = function (args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

    value = Math.round(value / 50);

    if (value === 0) {
      return 30;
    }

    var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

    if (value === 2) {
      ansi += 60;
    }

    return ansi;
  };

  convert.hsv.ansi16 = function (args) {
    // optimization here; we already know the value and don't need to get
    // it converted for us.
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };

  convert.rgb.ansi256 = function (args) {
    var r = args[0];
    var g = args[1];
    var b = args[2]; // we use the extended greyscale palette here, with the exception of
    // black and white. normal palette only has 4 greyscale shades.

    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }

      if (r > 248) {
        return 231;
      }

      return Math.round((r - 8) / 247 * 24) + 232;
    }

    var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };

  convert.ansi16.rgb = function (args) {
    var color = args % 10; // handle greyscale

    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }

      color = color / 10.5 * 255;
      return [color, color, color];
    }

    var mult = (~~(args > 50) + 1) * 0.5;
    var r = (color & 1) * mult * 255;
    var g = (color >> 1 & 1) * mult * 255;
    var b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };

  convert.ansi256.rgb = function (args) {
    // handle greyscale
    if (args >= 232) {
      var c = (args - 232) * 10 + 8;
      return [c, c, c];
    }

    args -= 16;
    var rem;
    var r = Math.floor(args / 36) / 5 * 255;
    var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    var b = rem % 6 / 5 * 255;
    return [r, g, b];
  };

  convert.rgb.hex = function (args) {
    var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
    var string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };

  convert.hex.rgb = function (args) {
    var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

    if (!match) {
      return [0, 0, 0];
    }

    var colorString = match[0];

    if (match[0].length === 3) {
      colorString = colorString.split('').map(function (char) {
        return char + char;
      }).join('');
    }

    var integer = parseInt(colorString, 16);
    var r = integer >> 16 & 0xFF;
    var g = integer >> 8 & 0xFF;
    var b = integer & 0xFF;
    return [r, g, b];
  };

  convert.rgb.hcg = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var max = Math.max(Math.max(r, g), b);
    var min = Math.min(Math.min(r, g), b);
    var chroma = max - min;
    var grayscale;
    var hue;

    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }

    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma + 4;
    }

    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };

  convert.hsl.hcg = function (hsl) {
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var c = 1;
    var f = 0;

    if (l < 0.5) {
      c = 2.0 * s * l;
    } else {
      c = 2.0 * s * (1.0 - l);
    }

    if (c < 1.0) {
      f = (l - 0.5 * c) / (1.0 - c);
    }

    return [hsl[0], c * 100, f * 100];
  };

  convert.hsv.hcg = function (hsv) {
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var c = s * v;
    var f = 0;

    if (c < 1.0) {
      f = (v - c) / (1 - c);
    }

    return [hsv[0], c * 100, f * 100];
  };

  convert.hcg.rgb = function (hcg) {
    var h = hcg[0] / 360;
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;

    if (c === 0.0) {
      return [g * 255, g * 255, g * 255];
    }

    var pure = [0, 0, 0];
    var hi = h % 1 * 6;
    var v = hi % 1;
    var w = 1 - v;
    var mg = 0;

    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;

      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;

      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;

      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;

      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;

      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }

    mg = (1.0 - c) * g;
    return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
  };

  convert.hcg.hsv = function (hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1.0 - c);
    var f = 0;

    if (v > 0.0) {
      f = c / v;
    }

    return [hcg[0], f * 100, v * 100];
  };

  convert.hcg.hsl = function (hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var l = g * (1.0 - c) + 0.5 * c;
    var s = 0;

    if (l > 0.0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1.0) {
      s = c / (2 * (1 - l));
    }

    return [hcg[0], s * 100, l * 100];
  };

  convert.hcg.hwb = function (hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1.0 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };

  convert.hwb.hcg = function (hwb) {
    var w = hwb[1] / 100;
    var b = hwb[2] / 100;
    var v = 1 - b;
    var c = v - w;
    var g = 0;

    if (c < 1) {
      g = (v - c) / (1 - c);
    }

    return [hwb[0], c * 100, g * 100];
  };

  convert.apple.rgb = function (apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };

  convert.rgb.apple = function (rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };

  convert.gray.rgb = function (args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };

  convert.gray.hsl = convert.gray.hsv = function (args) {
    return [0, 0, args[0]];
  };

  convert.gray.hwb = function (gray) {
    return [0, 100, gray[0]];
  };

  convert.gray.cmyk = function (gray) {
    return [0, 0, 0, gray[0]];
  };

  convert.gray.lab = function (gray) {
    return [gray[0], 0, 0];
  };

  convert.gray.hex = function (gray) {
    var val = Math.round(gray[0] / 100 * 255) & 0xFF;
    var integer = (val << 16) + (val << 8) + val;
    var string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };

  convert.rgb.gray = function (rgb) {
    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});
var conversions_1 = conversions.rgb;
var conversions_2 = conversions.hsl;
var conversions_3 = conversions.hsv;
var conversions_4 = conversions.hwb;
var conversions_5 = conversions.cmyk;
var conversions_6 = conversions.xyz;
var conversions_7 = conversions.lab;
var conversions_8 = conversions.lch;
var conversions_9 = conversions.hex;
var conversions_10 = conversions.keyword;
var conversions_11 = conversions.ansi16;
var conversions_12 = conversions.ansi256;
var conversions_13 = conversions.hcg;
var conversions_14 = conversions.apple;
var conversions_15 = conversions.gray;
/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
  var graph = {}; // https://jsperf.com/object-keys-vs-for-in-with-closure/3

  var models = Object.keys(conversions);

  for (var len = models.length, i = 0; i < len; i++) {
    graph[models[i]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  }

  return graph;
} // https://en.wikipedia.org/wiki/Breadth-first_search


function deriveBFS(fromModel) {
  var graph = buildGraph();
  var queue = [fromModel]; // unshift -> queue -> pop

  graph[fromModel].distance = 0;

  while (queue.length) {
    var current = queue.pop();
    var adjacents = Object.keys(conversions[current]);

    for (var len = adjacents.length, i = 0; i < len; i++) {
      var adjacent = adjacents[i];
      var node = graph[adjacent];

      if (node.distance === -1) {
        node.distance = graph[current].distance + 1;
        node.parent = current;
        queue.unshift(adjacent);
      }
    }
  }

  return graph;
}

function link(from, to) {
  return function (args) {
    return to(from(args));
  };
}

function wrapConversion(toModel, graph) {
  var path = [graph[toModel].parent, toModel];
  var fn = conversions[graph[toModel].parent][toModel];
  var cur = graph[toModel].parent;

  while (graph[cur].parent) {
    path.unshift(graph[cur].parent);
    fn = link(conversions[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }

  fn.conversion = path;
  return fn;
}

var route = function (fromModel) {
  var graph = deriveBFS(fromModel);
  var conversion = {};
  var models = Object.keys(graph);

  for (var len = models.length, i = 0; i < len; i++) {
    var toModel = models[i];
    var node = graph[toModel];

    if (node.parent === null) {
      // no possible conversion, or this node is the source model.
      continue;
    }

    conversion[toModel] = wrapConversion(toModel, graph);
  }

  return conversion;
};

var convert = {};
var models = Object.keys(conversions);

function wrapRaw(fn) {
  var wrappedFn = function (args) {
    if (args === undefined || args === null) {
      return args;
    }

    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments);
    }

    return fn(args);
  }; // preserve .conversion property if there is one


  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }

  return wrappedFn;
}

function wrapRounded(fn) {
  var wrappedFn = function (args) {
    if (args === undefined || args === null) {
      return args;
    }

    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments);
    }

    var result = fn(args); // we're assuming the result is an array here.
    // see notice in conversions.js; don't use box types
    // in conversion functions.

    if (typeof result === 'object') {
      for (var len = result.length, i = 0; i < len; i++) {
        result[i] = Math.round(result[i]);
      }
    }

    return result;
  }; // preserve .conversion property if there is one


  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }

  return wrappedFn;
}

models.forEach(function (fromModel) {
  convert[fromModel] = {};
  Object.defineProperty(convert[fromModel], 'channels', {
    value: conversions[fromModel].channels
  });
  Object.defineProperty(convert[fromModel], 'labels', {
    value: conversions[fromModel].labels
  });
  var routes = route(fromModel);
  var routeModels = Object.keys(routes);
  routeModels.forEach(function (toModel) {
    var fn = routes[toModel];
    convert[fromModel][toModel] = wrapRounded(fn);
    convert[fromModel][toModel].raw = wrapRaw(fn);
  });
});
var colorConvert = convert;
var _slice = [].slice;
var skippedModels = [// to be honest, I don't really feel like keyword belongs in color convert, but eh.
'keyword', // gray conflicts with some method names, and has its own method defined.
'gray', // shouldn't really be in color-convert either...
'hex'];
var hashedModelKeys = {};
Object.keys(colorConvert).forEach(function (model) {
  hashedModelKeys[_slice.call(colorConvert[model].labels).sort().join('')] = model;
});
var limiters = {};

function Color(obj, model) {
  if (!(this instanceof Color)) {
    return new Color(obj, model);
  }

  if (model && model in skippedModels) {
    model = null;
  }

  if (model && !(model in colorConvert)) {
    throw new Error('Unknown model: ' + model);
  }

  var i;
  var channels;

  if (obj == null) {
    // eslint-disable-line no-eq-null,eqeqeq
    this.model = 'rgb';
    this.color = [0, 0, 0];
    this.valpha = 1;
  } else if (obj instanceof Color) {
    this.model = obj.model;
    this.color = obj.color.slice();
    this.valpha = obj.valpha;
  } else if (typeof obj === 'string') {
    var result = colorString.get(obj);

    if (result === null) {
      throw new Error('Unable to parse color from string: ' + obj);
    }

    this.model = result.model;
    channels = colorConvert[this.model].channels;
    this.color = result.value.slice(0, channels);
    this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
  } else if (obj.length) {
    this.model = model || 'rgb';
    channels = colorConvert[this.model].channels;

    var newArr = _slice.call(obj, 0, channels);

    this.color = zeroArray(newArr, channels);
    this.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;
  } else if (typeof obj === 'number') {
    // this is always RGB - can be converted later on.
    obj &= 0xFFFFFF;
    this.model = 'rgb';
    this.color = [obj >> 16 & 0xFF, obj >> 8 & 0xFF, obj & 0xFF];
    this.valpha = 1;
  } else {
    this.valpha = 1;
    var keys = Object.keys(obj);

    if ('alpha' in obj) {
      keys.splice(keys.indexOf('alpha'), 1);
      this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;
    }

    var hashedKeys = keys.sort().join('');

    if (!(hashedKeys in hashedModelKeys)) {
      throw new Error('Unable to parse color from object: ' + JSON.stringify(obj));
    }

    this.model = hashedModelKeys[hashedKeys];
    var labels = colorConvert[this.model].labels;
    var color = [];

    for (i = 0; i < labels.length; i++) {
      color.push(obj[labels[i]]);
    }

    this.color = zeroArray(color);
  } // perform limitations (clamping, etc.)


  if (limiters[this.model]) {
    channels = colorConvert[this.model].channels;

    for (i = 0; i < channels; i++) {
      var limit = limiters[this.model][i];

      if (limit) {
        this.color[i] = limit(this.color[i]);
      }
    }
  }

  this.valpha = Math.max(0, Math.min(1, this.valpha));

  if (Object.freeze) {
    Object.freeze(this);
  }
}

Color.prototype = {
  toString: function () {
    return this.string();
  },
  toJSON: function () {
    return this[this.model]();
  },
  string: function (places) {
    var self = this.model in colorString.to ? this : this.rgb();
    self = self.round(typeof places === 'number' ? places : 1);
    var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
    return colorString.to[self.model](args);
  },
  percentString: function (places) {
    var self = this.rgb().round(typeof places === 'number' ? places : 1);
    var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
    return colorString.to.rgb.percent(args);
  },
  array: function () {
    return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
  },
  object: function () {
    var result = {};
    var channels = colorConvert[this.model].channels;
    var labels = colorConvert[this.model].labels;

    for (var i = 0; i < channels; i++) {
      result[labels[i]] = this.color[i];
    }

    if (this.valpha !== 1) {
      result.alpha = this.valpha;
    }

    return result;
  },
  unitArray: function () {
    var rgb = this.rgb().color;
    rgb[0] /= 255;
    rgb[1] /= 255;
    rgb[2] /= 255;

    if (this.valpha !== 1) {
      rgb.push(this.valpha);
    }

    return rgb;
  },
  unitObject: function () {
    var rgb = this.rgb().object();
    rgb.r /= 255;
    rgb.g /= 255;
    rgb.b /= 255;

    if (this.valpha !== 1) {
      rgb.alpha = this.valpha;
    }

    return rgb;
  },
  round: function (places) {
    places = Math.max(places || 0, 0);
    return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
  },
  alpha: function (val) {
    if (arguments.length) {
      return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
    }

    return this.valpha;
  },
  // rgb
  red: getset('rgb', 0, maxfn(255)),
  green: getset('rgb', 1, maxfn(255)),
  blue: getset('rgb', 2, maxfn(255)),
  hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) {
    return (val % 360 + 360) % 360;
  }),
  // eslint-disable-line brace-style
  saturationl: getset('hsl', 1, maxfn(100)),
  lightness: getset('hsl', 2, maxfn(100)),
  saturationv: getset('hsv', 1, maxfn(100)),
  value: getset('hsv', 2, maxfn(100)),
  chroma: getset('hcg', 1, maxfn(100)),
  gray: getset('hcg', 2, maxfn(100)),
  white: getset('hwb', 1, maxfn(100)),
  wblack: getset('hwb', 2, maxfn(100)),
  cyan: getset('cmyk', 0, maxfn(100)),
  magenta: getset('cmyk', 1, maxfn(100)),
  yellow: getset('cmyk', 2, maxfn(100)),
  black: getset('cmyk', 3, maxfn(100)),
  x: getset('xyz', 0, maxfn(100)),
  y: getset('xyz', 1, maxfn(100)),
  z: getset('xyz', 2, maxfn(100)),
  l: getset('lab', 0, maxfn(100)),
  a: getset('lab', 1),
  b: getset('lab', 2),
  keyword: function (val) {
    if (arguments.length) {
      return new Color(val);
    }

    return colorConvert[this.model].keyword(this.color);
  },
  hex: function (val) {
    if (arguments.length) {
      return new Color(val);
    }

    return colorString.to.hex(this.rgb().round().color);
  },
  rgbNumber: function () {
    var rgb = this.rgb().color;
    return (rgb[0] & 0xFF) << 16 | (rgb[1] & 0xFF) << 8 | rgb[2] & 0xFF;
  },
  luminosity: function () {
    // http://www.w3.org/TR/WCAG20/#relativeluminancedef
    var rgb = this.rgb().color;
    var lum = [];

    for (var i = 0; i < rgb.length; i++) {
      var chan = rgb[i] / 255;
      lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
    }

    return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
  },
  contrast: function (color2) {
    // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
    var lum1 = this.luminosity();
    var lum2 = color2.luminosity();

    if (lum1 > lum2) {
      return (lum1 + 0.05) / (lum2 + 0.05);
    }

    return (lum2 + 0.05) / (lum1 + 0.05);
  },
  level: function (color2) {
    var contrastRatio = this.contrast(color2);

    if (contrastRatio >= 7.1) {
      return 'AAA';
    }

    return contrastRatio >= 4.5 ? 'AA' : '';
  },
  isDark: function () {
    // YIQ equation from http://24ways.org/2010/calculating-color-contrast
    var rgb = this.rgb().color;
    var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
    return yiq < 128;
  },
  isLight: function () {
    return !this.isDark();
  },
  negate: function () {
    var rgb = this.rgb();

    for (var i = 0; i < 3; i++) {
      rgb.color[i] = 255 - rgb.color[i];
    }

    return rgb;
  },
  lighten: function (ratio) {
    var hsl = this.hsl();
    hsl.color[2] += hsl.color[2] * ratio;
    return hsl;
  },
  darken: function (ratio) {
    var hsl = this.hsl();
    hsl.color[2] -= hsl.color[2] * ratio;
    return hsl;
  },
  saturate: function (ratio) {
    var hsl = this.hsl();
    hsl.color[1] += hsl.color[1] * ratio;
    return hsl;
  },
  desaturate: function (ratio) {
    var hsl = this.hsl();
    hsl.color[1] -= hsl.color[1] * ratio;
    return hsl;
  },
  whiten: function (ratio) {
    var hwb = this.hwb();
    hwb.color[1] += hwb.color[1] * ratio;
    return hwb;
  },
  blacken: function (ratio) {
    var hwb = this.hwb();
    hwb.color[2] += hwb.color[2] * ratio;
    return hwb;
  },
  grayscale: function () {
    // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
    var rgb = this.rgb().color;
    var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
    return Color.rgb(val, val, val);
  },
  fade: function (ratio) {
    return this.alpha(this.valpha - this.valpha * ratio);
  },
  opaquer: function (ratio) {
    return this.alpha(this.valpha + this.valpha * ratio);
  },
  rotate: function (degrees) {
    var hsl = this.hsl();
    var hue = hsl.color[0];
    hue = (hue + degrees) % 360;
    hue = hue < 0 ? 360 + hue : hue;
    hsl.color[0] = hue;
    return hsl;
  },
  mix: function (mixinColor, weight) {
    // ported from sass implementation in C
    // https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
    if (!mixinColor || !mixinColor.rgb) {
      throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
    }

    var color1 = mixinColor.rgb();
    var color2 = this.rgb();
    var p = weight === undefined ? 0.5 : weight;
    var w = 2 * p - 1;
    var a = color1.alpha() - color2.alpha();
    var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
    var w2 = 1 - w1;
    return Color.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue(), color1.alpha() * p + color2.alpha() * (1 - p));
  }
}; // model conversion methods and static constructors

Object.keys(colorConvert).forEach(function (model) {
  if (skippedModels.indexOf(model) !== -1) {
    return;
  }

  var channels = colorConvert[model].channels; // conversion methods

  Color.prototype[model] = function () {
    if (this.model === model) {
      return new Color(this);
    }

    if (arguments.length) {
      return new Color(arguments, model);
    }

    var newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;
    return new Color(assertArray(colorConvert[this.model][model].raw(this.color)).concat(newAlpha), model);
  }; // 'static' construction methods


  Color[model] = function (color) {
    if (typeof color === 'number') {
      color = zeroArray(_slice.call(arguments), channels);
    }

    return new Color(color, model);
  };
});

function roundTo(num, places) {
  return Number(num.toFixed(places));
}

function roundToPlace(places) {
  return function (num) {
    return roundTo(num, places);
  };
}

function getset(model, channel, modifier) {
  model = Array.isArray(model) ? model : [model];
  model.forEach(function (m) {
    (limiters[m] || (limiters[m] = []))[channel] = modifier;
  });
  model = model[0];
  return function (val) {
    var result;

    if (arguments.length) {
      if (modifier) {
        val = modifier(val);
      }

      result = this[model]();
      result.color[channel] = val;
      return result;
    }

    result = this[model]().color[channel];

    if (modifier) {
      result = modifier(result);
    }

    return result;
  };
}

function maxfn(max) {
  return function (v) {
    return Math.max(0, Math.min(max, v));
  };
}

function assertArray(val) {
  return Array.isArray(val) ? val : [val];
}

function zeroArray(arr, length) {
  for (var i = 0; i < length; i++) {
    if (typeof arr[i] !== 'number') {
      arr[i] = 0;
    }
  }

  return arr;
}

var color = Color;
/**
 * Checks if a value is undefined
 * @param {*} v
 * @returns {Boolean}
 */

function isUndef(v) {
  return v === undefined || v === null;
}
/**
 * Checks if a value is defined
 * @param {*} v
 * @returns {Boolean}
 */


function isDef(v) {
  return v !== undefined && v !== null;
}
/**
 * @description Gets color value from theme
 * @param {String} color
 * @param {Number} hue
 * @returns {String} color
 */


var get$1 = function get(color, hue) {
  return color + "." + hue;
};
/**
 * @description Add opacity to a color
 * @param {String} color Hex color code
 * @param {Object} opacity Opacity
 * @returns String
 */


var addOpacity = function addOpacity(color$1, opacity) {
  return color(color$1).fade(1 - opacity).string();
};

var generateAlphas = function generateAlphas(color) {
  return {
    900: addOpacity(color, 0.92),
    800: addOpacity(color, 0.8),
    700: addOpacity(color, 0.6),
    600: addOpacity(color, 0.48),
    500: addOpacity(color, 0.38),
    400: addOpacity(color, 0.24),
    300: addOpacity(color, 0.16),
    200: addOpacity(color, 0.12),
    100: addOpacity(color, 0.08),
    50: addOpacity(color, 0.04)
  };
};
/**
 * @description Creates emphasis color values for color.
 * @param {String} color
 * @param {String} emphasis
 * @returns {Object} Color alpha hue
 */


var colorEmphasis = function colorEmphasis(color, emphasis) {
  switch (emphasis) {
    case 'high':
      return color;

    case 'medium':
      return generateAlphas(color)[700];

    case 'low':
      return generateAlphas(color)[500];

    case 'lowest':
      return generateAlphas(color)[300];
  }
};
/**
 * Generates stripe colors
 * @param {{ size: Number, color: String }} props
 * @returns {String} Class for style strips
 */


var generateStripe = function generateStripe(ref) {
  var size = ref.size;
  if (size === void 0) size = '1rem';
  var color = ref.color;
  if (color === void 0) color = 'rgba(255, 255, 255, 0.15)';
  return css.css({
    backgroundImage: "linear-gradient(\n    45deg,\n    " + color + " 25%,\n    transparent 25%,\n    transparent 50%,\n    " + color + " 50%,\n    " + color + " 75%,\n    transparent 75%,\n    transparent\n  )",
    backgroundSize: size + " " + size
  });
};
/**
 * @description Determines whether the provided color is dark or not.
 * @param {String} color
 */


var isDarkColor = function isDarkColor(color$1) {
  return color(color$1).isDark();
};
/**
 * Validates variant colors provided by consumer
 * @param {Object} theme Chakra Theme Object
 * @param {String} componentName Component name
 * @param {String} variantColor Variabt color
 */


function useVariantColorWarning(theme, componentName, variantColor) {
  if (true) {
    return;
  }

  var variantColorIsDefined = isDef(variantColor);

  if (variantColorIsDefined) {
    var variantColorExists = (variantColor in theme.colors);

    if (!variantColorExists) {
      console.warn("You passed an invalid variantColor to the " + componentName + " Component. Variant color values must be a color key in the theme object that has '100' - '900' color values. Check http://chakra-ui.com/theme#colors to see possible values");
    }

    if (variantColorExists) {
      var colorObj = theme.colors[variantColor];
      var variantColorIsObject = _typeof(colorObj) === 'object' && colorHasAllVariants(colorObj);

      if (!variantColorIsObject) {
        console.warn(componentName + ": The variantColor passed exists in the theme object but is not valid. For a color to be a valid variantColor, it must be an object that has '100' - '900' color values. Use a tool like:\n        https://smart-swatch.netlify.com/ to generate color values quickly");
      }
    }
  }
}
/**
 * Checks whether a variant color has all keys from 100 - 900
 * @param {Object} color Color object on theme with all variantes
 * @returns {Boolean}
 */


function colorHasAllVariants(color) {
  var keys = ['100', '200', '300', '400', '500', '600', '700', '800', '900'];
  return keys.every(function (key) {
    return isDef(color[key]);
  });
}
/**
 * Handly list of all HTML elements.
 */


var htmlElements = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG
'circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];
var focusableElList = ['a[href]', 'area[href]', 'button:not([disabled])', 'embed', 'iframe', 'input:not([disabled])', 'object', 'select:not([disabled])', 'textarea:not([disabled])', '*[tabindex]:not([aria-disabled])', '*[contenteditable]'];
var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
var HTMLElement = canUseDOM ? window.HTMLElement : Object;
/**
 * Checks if a given element is an HTML element.
 * @param {String} element HTML element tag name
 * @returns {Boolean}
 */

function isValidElement(element) {
  if (typeof element === 'string') {
    return htmlElements.includes(element);
  }
}

var focusableElSelector = focusableElList.join();
/**
 * Get a NodeList of all focusable DOM nodes within an element
 * @param {HTMLElement} element HTML element to get focusable list of DOM nodes from.
 * @param {Boolean} keyboardOnly Should get only keyboard accessible nodes?
 * @returns {NodeList} List of all focusable DOM nodes
 */

function getFocusables(element, keyboardOnly) {
  if (keyboardOnly === void 0) keyboardOnly = false;
  var focusableEls = Array.from(element.querySelectorAll(focusableElSelector)); // filter out elements with display: none

  focusableEls = focusableEls.filter(function (focusableEl) {
    return window.getComputedStyle(focusableEl).display !== 'none';
  });

  if (keyboardOnly === true) {
    focusableEls = focusableEls.filter(function (focusableEl) {
      return focusableEl.getAttribute('tabindex') !== '-1';
    });
  }

  return focusableEls;
}
/**
 * @description Wraps and executes both user and internal event handlers for a single event
 * @param {Function} theirHandler Userland event handler
 * @param {*} ourHandler Internal Vue chakra event handler
 */


var wrapEvent = function wrapEvent(theirHandler, ourHandler) {
  return function (event) {
    if (theirHandler) {
      theirHandler(event);
    }

    if (!event.defaultPrevented) {
      return ourHandler(event);
    }
  };
};
/**
 * Queries an element from the DOM
 * @param {String} selector Element selector
 * @param {Node} domain HTML element in which to query for element
 * @returns {Node} Node
 */


var getElement = function getElement(selector, domain) {
  if (!domain) {
    return document.querySelector(selector);
  } else {
    return domain.querySelector(selector);
  }
};
/**
 * Queries an element by ID from the DOM
 * @param {String} id Element id
 * @param {Node} domain HTML element in which to query for element
 * @returns {Node} Node
 */


var getElById = function getElById(id, domain) {
  return getElement("#" + id, domain);
};

function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * Clones a single VNode
 * @param {Vue.VNode} vnodes VNode to be cloned
 * @param {Function} createElement Render function
 * @returns {Vue.VNode} Cloned VNodes
 */


function cloneVNode(vnode, createElement) {
  var clonedChildren = vnode.children && vnode.children.map(function (vnode) {
    return cloneVNode(vnode, createElement);
  });
  var cloned = createElement(vnode.tag, vnode.data, clonedChildren);
  cloned.text = vnode.text;
  cloned.isComment = vnode.isComment;
  cloned.componentOptions = vnode.componentOptions;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnContext = vnode.fnContext;
  cloned.elm = vnode.elm;
  cloned.context = vnode.context;
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.data = vnode.data;
  return cloned;
}
/**
 * Clones an array of VNodes
 * @param {Array<Vue.VNode>} vnodes Array of VNodes to be cloned
 * @param {Function} createElement Render function
 * @returns {Array<Vue.VNode>} Cloned VNodes Array
 */


function cloneVNodes(vnodes, createElement) {
  var clonedVNodes = vnodes.map(function (vnode) {
    return cloneVNode(vnode, createElement);
  });
  return clonedVNodes;
}
/**
 * Clones VNode with merged data
 * @param {Vue.VNode} vnode VNode
 * @param {Object} data VNode data
 * @param {Function} h Render function
 */


function cloneVNodeElement(vnode, ref, h) {
  var props = ref.props;
  var attrs = ref.attrs;
  var children = ref.children;
  var rest$1 = objectWithoutProperties(ref, ["props", "attrs", "children"]);
  var rest = rest$1;
  var cloned = cloneVNode(vnode, h);
  return h(cloned.componentOptions.Ctor, Object.assign({}, cloned.data, cloned.componentOptions.listeners || {}, {
    props: Object.assign({}, cloned.data.props || {}, cloned.componentOptions.propsData, props),
    attrs: Object.assign({}, cloned.data.attrs || {}, attrs)
  }, rest), cloned.componentOptions.children || children);
}
/**
 * Checks whether a vnode is an async placeholder
 * @param {Vue.VNode} node
 * @returns {Boolean}
 */


function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}
/**
 * Get's the first child component VNode from an array of VNodes
 * @param {Array<Vue.VNode>} children
 * @returns {Vue.VNode}
 */


function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];

      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}
/**
 * Clears out all undefined or nullish vnodes
 * @param {Array<Vue.VNode>} vnodes Array of VNodes
 * @returns {Array<Vue.VNode>}
 */


function cleanChildren(vnodes) {
  if (!vnodes) {
    return [];
  }

  return vnodes.filter(function (vnode) {
    return vnode.tag;
  });
}
/**
 * Extracts native and nonNative event handlers for functional components
 *
 * The returned object returns `native` object contains listeners that
 * MUST be passed to a Vue component in the render function.
 *
 * The returned `nonNative` object contains other native listeners that
 * can be passed to a native HTML element in the render function.
 *
 * @param {Object} context Render function context
 * @param {Object} nonNative Object of VNode `on` event handlers
 * @returns {{ nonNative: Object<String, Function>, native: Object<String, Function>}}
 *
 * @example
 * import Comp from 'comp'
 *
 * const newComp = {
 *  functional: true,
 *  render(h, context) {
 *    const { native, nonNative } = extractListeners(context, componentEvents)
 *    return h(Comp, {
 *      ...context.data
 *      on: nonNative,
 *      nativeOn: native,
 *    }, context.slots ? context.slots().default : context.children)
 *  }
 * }
 */


var extractListeners = function extractListeners(context, nonNative) {
  if (nonNative === void 0) nonNative = {};
  var listeners = context.listeners;
  var native = {};

  for (var listener in listeners) {
    if (!nonNative[listener]) {
      native[listener] = listeners[listener];
    }
  }

  return {
    native: native,
    nonNative: nonNative
  };
};

function useId(size) {
  if (size === void 0) size = 3;
  var uuid = '';
  var dictionary = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';

  for (var i = 0; i < size; i++) {
    uuid += dictionary.charAt(Math.floor(Math.random() * dictionary.length));
  }

  return uuid;
}
/**
 * Chains function arguments passed.
 * @param  {...Function} funcs Functions to be chained
 */


function createChainedFunction() {
  var funcs = [],
      len = arguments.length;

  while (len--) {
    funcs[len] = arguments[len];
  }

  return funcs.reduce(function (acc, func) {
    if (func == null) {
      return acc;
    }

    return function chainedFunction() {
      var args = [],
          len = arguments.length;

      while (len--) {
        args[len] = arguments[len];
      }

      acc.apply(this, args);
      func.apply(this, args);
    };
  }, function () {});
}
/**
 * Computes a value if it's a function. Otherwise it returns the value
 * @param {Function|Any} value value to be computed
 * @param {Object|Any} props values to be passed as argument to function
 * @example
 *
 * const fn = (a, b) => a + b
 * const result = runIfFn(fn, 2,3)
 * console.log(result) // 5
 *
 * const obj = { m:3, p: 4 }
 * const withObj = runIfFn(obj, {m: 3})
 * console.log(withObj) // { m:3, p: 4 }
 */


var runIfFn = function runIfFn(value) {
  var props = [],
      len = arguments.length - 1;

  while (len-- > 0) {
    props[len] = arguments[len + 1];
  }

  if (typeof value === 'function') {
    return value.apply(void 0, props);
  }

  return value;
};
/**
 * Existential getter function that can be used in any style declaration to get a value
 * from theme, with support for fallback values. This helps prevent errors from
 * throwing when a theme value is missing.
 * @param {Object} obj Theme property
 * @param {String} key Theme key
 * @param {String} def Definition if non-existent
 */


var __get = function __get(obj, key, def) {
  var keys = key && key.split ? key.split('.') : [key];
  return keys.reduce(function (res, key) {
    return res && res[key];
  }, obj) || def;
};

var composeSystem = function composeSystem(props, theme) {
  if (props === void 0) props = {};
  if (theme === void 0) theme = {};
  return chakraUiStyledSystem_esm.css(props)(theme);
};

var isVueComponent = function isVueComponent(value) {
  return !!value && !!value.$el;
};
/**
 * Makes a cache watcher handler for data property.
 * This utility helps prevent unnecessary re-renders
 * for primitives with changes in the $parent $attrs
 * and $listeners objects
 * @param {String} property
 */


function createWatcher(property) {
  return {
    handler: function handler(newVal, oldVal) {
      for (var key in oldVal) {
        if (!hasOwn(newVal, key)) {
          this.$delete(this.$data[property], key);
        }
      }

      for (var key$1 in newVal) {
        this.$set(this.$data[property], key$1, newVal[key$1]);
      }
    },
    immediate: true
  };
}
/**
 * Create mixin for style attributes
 * @param {String} name Component name
 */


var createStyledAttrsMixin = function createStyledAttrsMixin(name) {
  return {
    name: name,
    inheritAttrs: false,
    inject: ['$chakraTheme', '$chakraColorMode'],
    data: function data() {
      return {
        attrs$: {},
        listeners$: {}
      };
    },
    props: {
      as: {
        type: [String, Object],
        default: 'div'
      },
      to: String
    },
    computed: {
      colorMode: function colorMode() {
        return this.$chakraColorMode();
      },
      theme: function theme() {
        return this.$chakraTheme();
      },

      /** Split style attributes and native attributes */
      splitProps: function splitProps() {
        var $attrs = this.$data.attrs$;
        var ref = extractChakraAttrs($attrs);
        var styleAttrs = ref.styleAttrs;
        var nativeAttrs = ref.nativeAttrs;
        return {
          styleAttrs: styleAttrs,
          nativeAttrs: nativeAttrs
        };
      },
      baseStyle: function baseStyle() {
        var componentBaseStyleObjectOrFunction = __get(this.theme, "baseStyles." + name);

        return componentBaseStyleObjectOrFunction ? chakraUiStyledSystem_esm.runIfFn(componentBaseStyleObjectOrFunction, Object.assign({}, this.splitProps.styleAttrs, this.splitProps.nativeAttrs, {
          theme: this.theme,
          colorMode: this.colorMode
        })) : {};
      },
      className: function className() {
        var ref = this.splitProps;
        var styleAttrs = ref.styleAttrs;
        var merged = Object.assign({}, this.componentStyles || {}, this.baseStyle, styleAttrs);
        var boxStylesObject = chakraUiStyledSystem_esm.css(merged)(this.theme);
        return css.css(boxStylesObject);
      },

      /** Computed attributes object */
      computedAttrs: function computedAttrs() {
        return Object.assign({}, name && {
          'data-chakra-component': name
        }, this.splitProps.nativeAttrs);
      },

      /** Computed listeners object */
      computedListeners: function computedListeners() {
        return this.$data.listeners$;
      }
    },
    created: function created() {
      this.$watch('$attrs', createWatcher('attrs$'));
      this.$watch('$listeners', createWatcher('listeners$'));
    }
  };
};

exports.colorModeObserver = colorModeObserver.colorModeObserver;
exports.colorModeObserverEventBus = colorModeObserver.colorModeObserverEventBus;
exports.defineColorModeObserver = colorModeObserver.defineColorModeObserver;
exports.emitToggleColorMode = colorModeObserver.emitToggleColorMode;
exports.mode = colorModeObserver.mode;
exports.onUpdateColorMode = colorModeObserver.onUpdateColorMode;
exports.HTMLElement = HTMLElement;
exports.Logger = Logger;
exports.__get = __get;
exports._typeof = _typeof;
exports.addOpacity = addOpacity;
exports.camelize = camelize;
exports.canUseDOM = canUseDOM;
exports.cleanChildren = cleanChildren;
exports.cloneVNode = cloneVNode;
exports.cloneVNodeElement = cloneVNodeElement;
exports.cloneVNodes = cloneVNodes;
exports.colorEmphasis = colorEmphasis;
exports.composeSystem = composeSystem;
exports.createChainedFunction = createChainedFunction;
exports.createStyledAttrsMixin = createStyledAttrsMixin;
exports.createWatcher = createWatcher;
exports.extractChakraAttrs = extractChakraAttrs;
exports.extractListeners = extractListeners;
exports.filterBaseStyles = filterBaseStyles;
exports.filterPseudo = filterPseudo;
exports.generateAlphas = generateAlphas;
exports.generateStripe = generateStripe;
exports.get = get$1;
exports.getElById = getElById;
exports.getElement = getElement;
exports.getFirstComponentChild = getFirstComponentChild;
exports.getFocusables = getFocusables;
exports.getSubstringAfterChar = getSubstringAfterChar;
exports.getSubstringBeforeChar = getSubstringBeforeChar;
exports.hasOwn = hasOwn;
exports.isDarkColor = isDarkColor;
exports.isDef = isDef;
exports.isEmpty = isEmpty;
exports.isFunction = isFunction;
exports.isNonNullObject = isNonNullObject;
exports.isUndef = isUndef;
exports.isValidElement = isValidElement;
exports.isVueComponent = isVueComponent;
exports.kebabify = kebabify;
exports.merge = merge;
exports.parsePackIcons = parsePackIcons;
exports.percentToValue = percentToValue;
exports.pickProperty = pickProperty;
exports.runIfFn = runIfFn;
exports.splitProps = splitProps;
exports.useId = useId;
exports.useVariantColorWarning = useVariantColorWarning;
exports.valueToPercent = valueToPercent;
exports.wrapEvent = wrapEvent;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(79)(module)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

var Vue = _interopDefault(__webpack_require__(0));

var defineColorModeObserver = function defineColorModeObserver(ref) {
  if (ref === void 0) ref = {};
  var colorMode = ref.colorMode;
  var theme = ref.theme;
  var icons = ref.icons;
  var toggleColorMode = ref.toggleColorMode;
  return Vue.observable({
    colorMode: colorMode,
    theme: theme,
    icons: icons,
    toggleColorMode: toggleColorMode
  });
};
/**
 * This observed store object observed the colorMode and stores it in an
 * observed object that other components can consume.
 */


var colorModeObserver = defineColorModeObserver({
  toggleColorMode: emitToggleColorMode
});
/**
 * Utility function that returns a value based on the colorMode
 * @param {string | number | Array<string | number>} lightValue Value when colorMode is `light`
 * @param {string | number | Array<string | number>} darkValue Value when colorMode is `dark`
 * @param {import('Vue').ComponentOptions<Vue, { colorMode: 'light' | 'dark', theme: any, icons: any }>} observer Value when colorMode is `dark`
 * @return {string | number | Array<string | number>}
 */

var mode = function mode(lightValue, darkValue, observer) {
  var ref = observer || colorModeObserver;
  var colorMode = ref.colorMode;
  return colorMode === 'dark' ? darkValue : lightValue;
};

var changeColorModeListeners = [];
var colorModeObserverEventBus = new Vue();
colorModeObserverEventBus.$on('change:colorMode', function (newVal) {
  colorModeObserver.colorMode = newVal;
  changeColorModeListeners.forEach(function (handler) {
    return handler(newVal);
  });
});

function emitToggleColorMode() {
  colorModeObserverEventBus.$emit('command:toggleColorMode');
}

var onUpdateColorMode = function onUpdateColorMode(fn) {
  return changeColorModeListeners.push(fn);
};

exports.colorModeObserver = colorModeObserver;
exports.colorModeObserverEventBus = colorModeObserverEventBus;
exports.defineColorModeObserver = defineColorModeObserver;
exports.emitToggleColorMode = emitToggleColorMode;
exports.mode = mode;
exports.onUpdateColorMode = onUpdateColorMode;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


__webpack_require__(24);

__webpack_require__(28);

__webpack_require__(29);

__webpack_require__(30);

__webpack_require__(31);

__webpack_require__(32);

__webpack_require__(33);

__webpack_require__(34);

__webpack_require__(35);

__webpack_require__(36);

__webpack_require__(37);

__webpack_require__(38);

__webpack_require__(39);

__webpack_require__(40);

__webpack_require__(41);

__webpack_require__(42);

__webpack_require__(43);

__webpack_require__(44);

__webpack_require__(45);

__webpack_require__(46);

__webpack_require__(47);

__webpack_require__(48);

__webpack_require__(49);

__webpack_require__(50);

__webpack_require__(51);

__webpack_require__(52);

__webpack_require__(53);

__webpack_require__(54);

__webpack_require__(55);

__webpack_require__(56);

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

var lodash_mergewith = createCommonjsModule(function (module, exports) {
  /**
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;
  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  /** Used to detect hot functions by number of calls within a span of milliseconds. */

  var HOT_COUNT = 800,
      HOT_SPAN = 16;
  /** Used as references for various `Number` constants. */

  var MAX_SAFE_INTEGER = 9007199254740991;
  /** `Object#toString` result references. */

  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */

  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  /** Used to detect host constructors (Safari). */

  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  /** Used to detect unsigned integer values. */

  var reIsUint = /^(?:0|[1-9]\d*)$/;
  /** Used to identify `toStringTag` values of typed arrays. */

  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  /** Detect free variable `global` from Node.js. */

  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  /** Detect free variable `self`. */

  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root = freeGlobal || freeSelf || Function('return this')();
  /** Detect free variable `exports`. */

  var freeExports = exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports = freeModule && freeModule.exports === freeExports;
  /** Detect free variable `process` from Node.js. */

  var freeProcess = moduleExports && freeGlobal.process;
  /** Used to access faster Node.js helpers. */

  var nodeUtil = function () {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      } // Legacy `process.binding('util')` for Node.js < 10.


      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }();
  /* Node.js helper references. */


  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */

  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);

      case 1:
        return func.call(thisArg, args[0]);

      case 2:
        return func.call(thisArg, args[0], args[1]);

      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }

    return func.apply(thisArg, args);
  }
  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */


  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }
  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */


  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }
  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */


  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }
  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */


  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }
  /** Used for built-in method references. */


  var arrayProto = Array.prototype,
      funcProto = Function.prototype,
      objectProto = Object.prototype;
  /** Used to detect overreaching core-js shims. */

  var coreJsData = root['__core-js_shared__'];
  /** Used to resolve the decompiled source of functions. */

  var funcToString = funcProto.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty = objectProto.hasOwnProperty;
  /** Used to detect methods masquerading as native. */

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */


  var nativeObjectToString = objectProto.toString;
  /** Used to infer the `Object` constructor. */

  var objectCtorString = funcToString.call(Object);
  /** Used to detect if a method is native. */

  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  /** Built-in value references. */

  var Buffer = moduleExports ? root.Buffer : undefined,
      Symbol = root.Symbol,
      Uint8Array = root.Uint8Array,
      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
      getPrototype = overArg(Object.getPrototypeOf, Object),
      objectCreate = Object.create,
      propertyIsEnumerable = objectProto.propertyIsEnumerable,
      splice = arrayProto.splice,
      symToStringTag = Symbol ? Symbol.toStringTag : undefined;

  var defineProperty = function () {
    try {
      var func = getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }();
  /* Built-in method references for those with the same name as other `lodash` methods. */


  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
      nativeMax = Math.max,
      nativeNow = Date.now;
  /* Built-in method references that are verified to be native. */

  var Map = getNative(root, 'Map'),
      nativeCreate = getNative(Object, 'create');
  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */

  var baseCreate = function () {
    function object() {}

    return function (proto) {
      if (!isObject(proto)) {
        return {};
      }

      if (objectCreate) {
        return objectCreate(proto);
      }

      object.prototype = proto;
      var result = new object();
      object.prototype = undefined;
      return result;
    };
  }();
  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */


  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */


  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function hashGet(key) {
    var data = this.__data__;

    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }
  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }
  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */


  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  } // Add methods to `Hash`.


  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */


  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    --this.size;
    return true;
  }
  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }
  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */


  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  } // Add methods to `ListCache`.


  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */


  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map || ListCache)(),
      'string': new Hash()
    };
  }
  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */


  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  } // Add methods to `MapCache`.


  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */


  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);
    this.size = data.size;
    return result;
  }
  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function stackGet(key) {
    return this.__data__.get(key);
  }
  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function stackHas(key) {
    return this.__data__.has(key);
  }
  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */


  function stackSet(key, value) {
    var data = this.__data__;

    if (data instanceof ListCache) {
      var pairs = data.__data__;

      if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }

      data = this.__data__ = new MapCache(pairs);
    }

    data.set(key, value);
    this.size = data.size;
    return this;
  } // Add methods to `Stack`.


  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */

  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value),
        isArg = !isArr && isArguments(value),
        isBuff = !isArr && !isArg && isBuffer(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
      key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
      isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }
  /**
   * This function is like `assignValue` except that it doesn't assign
   * `undefined` values.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */


  function assignMergeValue(object, key, value) {
    if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */


  function assignValue(object, key, value) {
    var objValue = object[key];

    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */


  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }
  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */


  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty) {
      defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }
  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */


  var baseFor = createBaseFor();
  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */

  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */


  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */


  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }

    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */


  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */


  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }

    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }

    return result;
  }
  /**
   * The base implementation of `_.merge` without support for multiple sources.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} [customizer] The function to customize merged values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */


  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }

    baseFor(source, function (srcValue, key) {
      stack || (stack = new Stack());

      if (isObject(srcValue)) {
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

        if (newValue === undefined) {
          newValue = srcValue;
        }

        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }
  /**
   * A specialized version of `baseMerge` for arrays and objects which performs
   * deep merges and tracks traversed objects enabling objects with circular
   * references to be merged.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {string} key The key of the value to merge.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} mergeFunc The function to merge values.
   * @param {Function} [customizer] The function to customize assigned values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */


  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key),
        srcValue = safeGet(source, key),
        stacked = stack.get(srcValue);

    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }

    var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
    var isCommon = newValue === undefined;

    if (isCommon) {
      var isArr = isArray(srcValue),
          isBuff = !isArr && isBuffer(srcValue),
          isTyped = !isArr && !isBuff && isTypedArray(srcValue);
      newValue = srcValue;

      if (isArr || isBuff || isTyped) {
        if (isArray(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
        newValue = objValue;

        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject(objValue) || isFunction(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }

    if (isCommon) {
      // Recursively merge objects and arrays (susceptible to call stack limits).
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack['delete'](srcValue);
    }

    assignMergeValue(object, key, newValue);
  }
  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */


  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + '');
  }
  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */


  var baseSetToString = !defineProperty ? identity : function (func, string) {
    return defineProperty(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant(string),
      'writable': true
    });
  };
  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */

  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }

    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */


  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }
  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */


  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */


  function copyArray(source, array) {
    var index = -1,
        length = source.length;
    array || (array = Array(length));

    while (++index < length) {
      array[index] = source[index];
    }

    return array;
  }
  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */


  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }

      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }

    return object;
  }
  /**
   * Creates a function like `_.assign`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */


  function createAssigner(assigner) {
    return baseRest(function (object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined,
          guard = length > 2 ? sources[2] : undefined;
      customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }

      object = Object(object);

      while (++index < length) {
        var source = sources[index];

        if (source) {
          assigner(object, source, index, customizer);
        }
      }

      return object;
    });
  }
  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */


  function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];

        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }

      return object;
    };
  }
  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */


  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }
  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */


  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }
  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */


  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }

    return result;
  }
  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */


  function initCloneObject(object) {
    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */


  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }
  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */


  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }

    var type = typeof index;

    if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
      return eq(object[index], value);
    }

    return false;
  }
  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */


  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }
  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */


  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */


  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
  }
  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */


  function nativeKeysIn(object) {
    var result = [];

    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }

    return result;
  }
  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */


  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */


  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function () {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }

      index = -1;
      var otherArgs = Array(start + 1);

      while (++index < start) {
        otherArgs[index] = args[index];
      }

      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }
  /**
   * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */


  function safeGet(object, key) {
    if (key === 'constructor' && typeof object[key] === 'function') {
      return;
    }

    if (key == '__proto__') {
      return;
    }

    return object[key];
  }
  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */


  var setToString = shortOut(baseSetToString);
  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */

  function shortOut(func) {
    var count = 0,
        lastCalled = 0;
    return function () {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;

      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }

      return func.apply(undefined, arguments);
    };
  }
  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */


  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }
  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */


  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */


  var isArguments = baseIsArguments(function () {
    return arguments;
  }()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
  };
  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */

  var isArray = Array.isArray;
  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */

  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */


  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */


  var isBuffer = nativeIsBuffer || stubFalse;
  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */

  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    } // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.


    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */


  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */


  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }
  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */


  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }
  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */


  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }

    var proto = getPrototype(value);

    if (proto === null) {
      return true;
    }

    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */


  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  /**
   * Converts `value` to a plain object flattening inherited enumerable string
   * keyed properties of `value` to own properties of the plain object.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {Object} Returns the converted plain object.
   * @example
   *
   * function Foo() {
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.assign({ 'a': 1 }, new Foo);
   * // => { 'a': 1, 'b': 2 }
   *
   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
   * // => { 'a': 1, 'b': 2, 'c': 3 }
   */

  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */


  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  /**
   * This method is like `_.merge` except that it accepts `customizer` which
   * is invoked to produce the merged values of the destination and source
   * properties. If `customizer` returns `undefined`, merging is handled by the
   * method instead. The `customizer` is invoked with six arguments:
   * (objValue, srcValue, key, object, source, stack).
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} sources The source objects.
   * @param {Function} customizer The function to customize assigned values.
   * @returns {Object} Returns `object`.
   * @example
   *
   * function customizer(objValue, srcValue) {
   *   if (_.isArray(objValue)) {
   *     return objValue.concat(srcValue);
   *   }
   * }
   *
   * var object = { 'a': [1], 'b': [2] };
   * var other = { 'a': [3], 'b': [4] };
   *
   * _.mergeWith(object, other, customizer);
   * // => { 'a': [1, 3], 'b': [2, 4] }
   */


  var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
    baseMerge(object, source, srcIndex, customizer);
  });
  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */

  function constant(value) {
    return function () {
      return value;
    };
  }
  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */


  function identity(value) {
    return value;
  }
  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */


  function stubFalse() {
    return false;
  }

  module.exports = mergeWith;
});

function getLastItem(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
} // Number assertions


function isNumber(value) {
  return typeof value === "number";
}

function isArray(value) {
  return Array.isArray(value);
}

function isFunction(value) {
  return typeof value === "function";
} // Generic assertions


function isObject(value) {
  var type = typeof value;
  return value != null && (type === "object" || type === "function") && !isArray(value);
}

function isString(value) {
  return Object.prototype.toString.call(value) === "[object String]";
}

function isCssVar(value) {
  return /^var\(--.+\)$/.test(value);
} // Empty assertions


var __DEV__ = "production" !== "production";

var __TEST__ = "production" === "test";

function pick(object, keys) {
  var result = {};
  keys.forEach(function (key) {
    if (key in object) {
      result[key] = object[key];
    }
  });
  return result;
}
/**
 * Get value from a deeply nested object using a string path.
 * Memoizes the value.
 * @param obj - the object
 * @param path - the string path
 * @param def  - the fallback value
 */


function get(obj, path, fallback, index) {
  var key = typeof path === "string" ? path.split(".") : [path];

  for (index = 0; index < key.length; index += 1) {
    if (!obj) {
      break;
    }

    obj = obj[key[index]];
  }

  return obj === undefined ? fallback : obj;
}

var memoize = function memoize(fn) {
  var cache = new WeakMap();

  var memoizedFn = function memoizedFn(obj, path, fallback, index) {
    if (typeof obj === "undefined") {
      return fn(obj, path, fallback);
    }

    if (!cache.has(obj)) {
      cache.set(obj, new Map());
    }

    var map = cache.get(obj);

    if (map.has(path)) {
      return map.get(path);
    }

    var value = fn(obj, path, fallback, index);
    map.set(path, value);
    return value;
  };

  return memoizedFn;
};

var memoizedGet = memoize(get);
/**
 * Object.entries polyfill for Nodev10 compatibility
 */

var fromEntries = function fromEntries(entries) {
  return entries.reduce(function (carry, _ref) {
    var key = _ref[0],
        value = _ref[1];
    carry[key] = value;
    return carry;
  }, {});
};

function analyzeCSSValue(value) {
  var num = parseFloat(value.toString());
  var unit = value.toString().replace(String(num), "");
  return {
    unitless: !unit,
    value: num,
    unit: unit
  };
}

function px(value) {
  if (value == null) {
    return value;
  }

  var _analyzeCSSValue = analyzeCSSValue(value),
      unitless = _analyzeCSSValue.unitless;

  return unitless || isNumber(value) ? value + "px" : value;
}

var sortByBreakpointValue = function sortByBreakpointValue(a, b) {
  return parseInt(a[1], 10) > parseInt(b[1], 10) ? 1 : -1;
};

var sortBps = function sortBps(breakpoints) {
  return fromEntries(Object.entries(breakpoints).sort(sortByBreakpointValue));
};

function normalize(breakpoints) {
  var sorted = sortBps(breakpoints);
  return Object.assign(Object.values(sorted), sorted);
}

function keys(breakpoints) {
  var value = Object.keys(sortBps(breakpoints));
  return new Set(value);
}

function subtract(value) {
  var _px;

  if (!value) {
    return value;
  }

  value = (_px = px(value)) != null ? _px : value;
  var factor = value.endsWith("px") ? -1 : // the equivalent of 1px in em using a 16px base
  -0.0635;
  return isNumber(value) ? "" + (value + factor) : value.replace(/([0-9]+\.?[0-9]*)/, function (m) {
    return "" + (parseFloat(m) + factor);
  });
}

function queryString(min, max) {
  var query = [];

  if (min) {
    query.push("@media screen and (min-width: " + px(min) + ")");
  }

  if (query.length > 0 && max) {
    query.push("and");
  }

  if (max) {
    query.push("@media screen and (max-width: " + px(max) + ")");
  }

  return query.join(" ");
}

function analyzeBreakpoints(breakpoints) {
  var _breakpoints$base;

  if (!breakpoints) {
    return null;
  }

  breakpoints.base = (_breakpoints$base = breakpoints.base) != null ? _breakpoints$base : "0px";
  var normalized = normalize(breakpoints);
  var queries = Object.entries(breakpoints).sort(sortByBreakpointValue).map(function (_ref, index, entry) {
    var _entry;

    var breakpoint = _ref[0],
        minW = _ref[1];

    var _ref2 = (_entry = entry[index + 1]) != null ? _entry : [],
        maxW = _ref2[1];

    maxW = parseFloat(maxW) > 0 ? subtract(maxW) : undefined;
    return {
      breakpoint: breakpoint,
      minW: minW,
      maxW: maxW,
      maxWQuery: queryString(null, maxW),
      minWQuery: queryString(minW),
      minMaxQuery: queryString(minW, maxW)
    };
  });

  var _keys = keys(breakpoints);

  var _keysArr = Array.from(_keys.values());

  return {
    keys: _keys,
    normalized: normalized,
    isResponsive: function isResponsive(test) {
      var keys = Object.keys(test);
      return keys.length > 0 && keys.every(function (key) {
        return _keys.has(key);
      });
    },
    asObject: sortBps(breakpoints),
    asArray: normalize(breakpoints),
    details: queries,
    media: [null].concat(normalized.map(function (minW) {
      return queryString(minW);
    }).slice(1)),
    toArrayValue: function toArrayValue(test) {
      if (!isObject(test)) {
        throw new Error("toArrayValue: value must be an object");
      }

      var result = _keysArr.map(function (bp) {
        var _test$bp;

        return (_test$bp = test[bp]) != null ? _test$bp : null;
      });

      while (getLastItem(result) === null) {
        result.pop();
      }

      return result;
    },
    toObjectValue: function toObjectValue(test) {
      if (!Array.isArray(test)) {
        throw new Error("toObjectValue: value must be an array");
      }

      return test.reduce(function (acc, value, index) {
        var key = _keysArr[index];

        if (key != null && value != null) {
          acc[key] = value;
        }

        return acc;
      }, {});
    }
  };
}
/* eslint-disable no-nested-ternary */


function runIfFn(valueOrFn) {
  var arguments$1 = arguments;

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments$1[_key];
  }

  return isFunction(valueOrFn) ? valueOrFn.apply(void 0, args) : valueOrFn;
}

var breakpoints = Object.freeze(["base", "sm", "md", "lg", "xl", "2xl"]);

function walkObject(target, predicate) {
  function inner(value, path) {
    if (path === void 0) {
      path = [];
    }

    if (isArray(value)) {
      return value.map(function (item, index) {
        return inner(item, [].concat(path, [String(index)]));
      });
    }

    if (isObject(value)) {
      return fromEntries(Object.entries(value).map(function (_ref) {
        var key = _ref[0],
            child = _ref[1];
        return [key, inner(child, [].concat(path, [key]))];
      }));
    }

    return predicate(value, path);
  }

  return inner(target);
}

function _extends() {
  _extends = Object.assign || function (target) {
    var arguments$1 = arguments;

    for (var i = 1; i < arguments.length; i++) {
      var source = arguments$1[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var tokenToCSSVar = function tokenToCSSVar(scale, value) {
  return function (theme) {
    var valueStr = String(value);
    var key = scale ? scale + "." + valueStr : valueStr;
    return isObject(theme.__cssMap) && key in theme.__cssMap ? theme.__cssMap[key].varRef : value;
  };
};

function createTransform(options) {
  var scale = options.scale,
      transform = options.transform,
      compose = options.compose;

  var fn = function fn(value, theme) {
    var _transform;

    var _value = tokenToCSSVar(scale, value)(theme);

    var result = (_transform = transform == null ? void 0 : transform(_value, theme)) != null ? _transform : _value;

    if (compose) {
      result = compose(result, theme);
    }

    return result;
  };

  return fn;
}

function toConfig(scale, transform) {
  return function (property) {
    var result = {
      property: property,
      scale: scale
    };
    result.transform = createTransform({
      scale: scale,
      transform: transform
    });
    return result;
  };
}

var getRtl = function getRtl(_ref) {
  var rtl = _ref.rtl,
      ltr = _ref.ltr;
  return function (theme) {
    return theme.direction === "rtl" ? rtl : ltr;
  };
};

function logical(options) {
  var property = options.property,
      scale = options.scale,
      transform = options.transform;
  return {
    scale: scale,
    property: getRtl(property),
    transform: scale ? createTransform({
      scale: scale,
      compose: transform
    }) : transform
  };
}

var _spaceXTemplate, _spaceYTemplate;
/**
 * The CSS transform order following the upcoming spec from CSSWG
 * translate => rotate => scale => skew
 * @see https://drafts.csswg.org/css-transforms-2/#ctm
 * @see https://www.stefanjudis.com/blog/order-in-css-transformation-transform-functions-vs-individual-transforms/
 */


var transformTemplate = ["rotate(var(--chakra-rotate, 0))", "scaleX(var(--chakra-scale-x, 1))", "scaleY(var(--chakra-scale-y, 1))", "skewX(var(--chakra-skew-x, 0))", "skewY(var(--chakra-skew-y, 0))"];

function getTransformTemplate() {
  return ["translateX(var(--chakra-translate-x, 0))", "translateY(var(--chakra-translate-y, 0))"].concat(transformTemplate).join(" ");
}

function getTransformGpuTemplate() {
  return ["translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)"].concat(transformTemplate).join(" ");
}

var filterTemplate = {
  "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
  filter: ["var(--chakra-blur)", "var(--chakra-brightness)", "var(--chakra-contrast)", "var(--chakra-grayscale)", "var(--chakra-hue-rotate)", "var(--chakra-invert)", "var(--chakra-saturate)", "var(--chakra-sepia)", "var(--chakra-drop-shadow)"].join(" ")
};
var backdropFilterTemplate = {
  backdropFilter: ["var(--chakra-backdrop-blur)", "var(--chakra-backdrop-brightness)", "var(--chakra-backdrop-contrast)", "var(--chakra-backdrop-grayscale)", "var(--chakra-backdrop-hue-rotate)", "var(--chakra-backdrop-invert)", "var(--chakra-backdrop-opacity)", "var(--chakra-backdrop-saturate)", "var(--chakra-backdrop-sepia)"].join(" "),
  "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
};

function getRingTemplate(value) {
  return {
    "--chakra-ring-offset-shadow": "var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)",
    "--chakra-ring-shadow": "var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)",
    "--chakra-ring-width": value,
    boxShadow: ["var(--chakra-ring-offset-shadow)", "var(--chakra-ring-shadow)", "var(--chakra-shadow, 0 0 #0000)"].join(", ")
  };
}

var flexDirectionTemplate = {
  "row-reverse": {
    space: "--chakra-space-x-reverse",
    divide: "--chakra-divide-x-reverse"
  },
  "column-reverse": {
    space: "--chakra-space-y-reverse",
    divide: "--chakra-divide-y-reverse"
  }
};
var owlSelector = "& > :not(style) ~ :not(style)";
var spaceXTemplate = (_spaceXTemplate = {}, _spaceXTemplate[owlSelector] = {
  marginInlineStart: "calc(var(--chakra-space-x) * calc(1 - var(--chakra-space-x-reverse)))",
  marginInlineEnd: "calc(var(--chakra-space-x) * var(--chakra-space-x-reverse))"
}, _spaceXTemplate);
var spaceYTemplate = (_spaceYTemplate = {}, _spaceYTemplate[owlSelector] = {
  marginTop: "calc(var(--chakra-space-y) * calc(1 - var(--chakra-space-y-reverse)))",
  marginBottom: "calc(var(--chakra-space-y) * var(--chakra-space-y-reverse))"
}, _spaceYTemplate);

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });

  if (superClass) {
    _setPrototypeOf(subClass, superClass);
  }
}

function _wrapRegExp() {
  _wrapRegExp = function (re, groups) {
    return new BabelRegExp(re, undefined, groups);
  };

  var _super = RegExp.prototype;

  var _groups = new WeakMap();

  function BabelRegExp(re, flags, groups) {
    var _this = new RegExp(re, flags);

    _groups.set(_this, groups || _groups.get(re));

    return _setPrototypeOf(_this, BabelRegExp.prototype);
  }

  _inherits(BabelRegExp, RegExp);

  BabelRegExp.prototype.exec = function (str) {
    var result = _super.exec.call(this, str);

    if (result) {
      result.groups = buildGroups(result, this);
    }

    return result;
  };

  BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {
    if (typeof substitution === "string") {
      var groups = _groups.get(this);

      return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) {
        return "$" + groups[name];
      }));
    } else if (typeof substitution === "function") {
      var _this = this;

      return _super[Symbol.replace].call(this, str, function () {
        var args = arguments;

        if (typeof args[args.length - 1] !== "object") {
          args = [].slice.call(args);
          args.push(buildGroups(args, _this));
        }

        return substitution.apply(this, args);
      });
    } else {
      return _super[Symbol.replace].call(this, str, substitution);
    }
  };

  function buildGroups(result, re) {
    var g = _groups.get(re);

    return Object.keys(g).reduce(function (groups, name) {
      groups[name] = result[g[name]];
      return groups;
    }, Object.create(null));
  }

  return _wrapRegExp.apply(this, arguments);
}

var directionMap = {
  "to-t": "to top",
  "to-tr": "to top right",
  "to-r": "to right",
  "to-br": "to bottom right",
  "to-b": "to bottom",
  "to-bl": "to bottom left",
  "to-l": "to left",
  "to-tl": "to top left"
};
var valueSet = new Set(Object.values(directionMap));
var globalSet = new Set(["none", "-moz-initial", "inherit", "initial", "revert", "unset"]);

var trimSpace = function trimSpace(str) {
  return str.trim();
};

function parseGradient(value, theme) {
  var _regex$exec$groups, _regex$exec;

  if (value == null || globalSet.has(value)) {
    return value;
  }

  var regex = /*#__PURE__*/_wrapRegExp(/(^[\x2DA-Za-z]+)\(((.*))\)/g, {
    type: 1,
    values: 2
  });

  var _ref = (_regex$exec$groups = (_regex$exec = regex.exec(value)) == null ? void 0 : _regex$exec.groups) != null ? _regex$exec$groups : {},
      type = _ref.type,
      values = _ref.values;

  if (!type || !values) {
    return value;
  }

  var _type = type.includes("-gradient") ? type : type + "-gradient";

  var _values$split$map$fil = values.split(",").map(trimSpace).filter(Boolean),
      maybeDirection = _values$split$map$fil[0],
      stops = _values$split$map$fil.slice(1);

  if ((stops == null ? void 0 : stops.length) === 0) {
    return value;
  }

  var direction = maybeDirection in directionMap ? directionMap[maybeDirection] : maybeDirection;
  stops.unshift(direction);

  var _values = stops.map(function (stop) {
    // if stop is valid shorthand direction, return it
    if (valueSet.has(stop)) {
      return stop;
    }

    var firstStop = stop.indexOf(" "); // color stop could be `red.200 20%` based on css gradient spec

    var _ref2 = firstStop !== -1 ? [stop.substr(0, firstStop), stop.substr(firstStop + 1)] : [stop],
        _color = _ref2[0],
        _stop = _ref2[1];

    var _stopOrFunc = isCSSFunction(_stop) ? _stop : _stop && _stop.split(" "); // else, get and transform the color token or css value


    var key = "colors." + _color;
    var color = key in theme.__cssMap ? theme.__cssMap[key].varRef : _color;
    return _stopOrFunc ? [color].concat(Array.isArray(_stopOrFunc) ? _stopOrFunc : [_stopOrFunc]).join(" ") : color;
  });

  return _type + "(" + _values.join(", ") + ")";
}

var isCSSFunction = function isCSSFunction(value) {
  return isString(value) && value.includes("(") && value.includes(")");
};

var gradientTransform = function gradientTransform(value, theme) {
  return parseGradient(value, theme != null ? theme : {});
};

var analyzeCSSValue$1 = function analyzeCSSValue(value) {
  var num = parseFloat(value.toString());
  var unit = value.toString().replace(String(num), "");
  return {
    unitless: !unit,
    value: num,
    unit: unit
  };
};

var wrap = function wrap(str) {
  return function (value) {
    return str + "(" + value + ")";
  };
};

var transformFunctions = {
  filter: function filter(value) {
    return value !== "auto" ? value : filterTemplate;
  },
  backdropFilter: function backdropFilter(value) {
    return value !== "auto" ? value : backdropFilterTemplate;
  },
  ring: function ring(value) {
    return getRingTemplate(transformFunctions.px(value));
  },
  bgClip: function bgClip(value) {
    return value === "text" ? {
      color: "transparent",
      backgroundClip: "text"
    } : {
      backgroundClip: value
    };
  },
  transform: function transform(value) {
    if (value === "auto") {
      return getTransformTemplate();
    }

    if (value === "auto-gpu") {
      return getTransformGpuTemplate();
    }

    return value;
  },
  px: function px(value) {
    if (value == null) {
      return value;
    }

    var _analyzeCSSValue = analyzeCSSValue$1(value),
        unitless = _analyzeCSSValue.unitless;

    return unitless || isNumber(value) ? value + "px" : value;
  },
  fraction: function fraction(value) {
    return !isNumber(value) || value > 1 ? value : value * 100 + "%";
  },
  "float": function float(value, theme) {
    var map = {
      left: "right",
      right: "left"
    };
    return theme.direction === "rtl" ? map[value] : value;
  },
  degree: function degree(value) {
    if (isCssVar(value) || value == null) {
      return value;
    }

    var unitless = isString(value) && !value.endsWith("deg");
    return isNumber(value) || unitless ? value + "deg" : value;
  },
  gradient: gradientTransform,
  blur: wrap("blur"),
  opacity: wrap("opacity"),
  brightness: wrap("brightness"),
  contrast: wrap("contrast"),
  dropShadow: wrap("drop-shadow"),
  grayscale: wrap("grayscale"),
  hueRotate: wrap("hue-rotate"),
  invert: wrap("invert"),
  saturate: wrap("saturate"),
  sepia: wrap("sepia"),
  bgImage: function bgImage(value) {
    if (value == null) {
      return value;
    }

    var prevent = isCSSFunction(value) || globalSet.has(value);
    return !prevent ? "url(" + value + ")" : value;
  },
  outline: function outline(value) {
    var isNoneOrZero = String(value) === "0" || String(value) === "none";
    return value !== null && isNoneOrZero ? {
      outline: "2px solid transparent",
      outlineOffset: "2px"
    } : {
      outline: value
    };
  },
  flexDirection: function flexDirection(value) {
    var _flexDirectionTemplat;

    var _ref = (_flexDirectionTemplat = flexDirectionTemplate[value]) != null ? _flexDirectionTemplat : {},
        space = _ref.space,
        divide = _ref.divide;

    var result = {
      flexDirection: value
    };

    if (space) {
      result[space] = 1;
    }

    if (divide) {
      result[divide] = 1;
    }

    return result;
  }
};
var t = {
  borderWidths: toConfig("borderWidths"),
  borderStyles: toConfig("borderStyles"),
  colors: toConfig("colors"),
  borders: toConfig("borders"),
  radii: toConfig("radii", transformFunctions.px),
  space: toConfig("space", transformFunctions.px),
  spaceT: toConfig("space", transformFunctions.px),
  degreeT: function degreeT(property) {
    return {
      property: property,
      transform: transformFunctions.degree
    };
  },
  prop: function prop(property, scale, transform) {
    return _extends({
      property: property,
      scale: scale
    }, scale && {
      transform: createTransform({
        scale: scale,
        transform: transform
      })
    });
  },
  propT: function propT(property, transform) {
    return {
      property: property,
      transform: transform
    };
  },
  sizes: toConfig("sizes", transformFunctions.px),
  sizesT: toConfig("sizes", transformFunctions.fraction),
  shadows: toConfig("shadows"),
  logical: logical,
  blur: toConfig("blur", transformFunctions.blur)
};
var background = {
  background: t.colors("background"),
  backgroundColor: t.colors("backgroundColor"),
  backgroundImage: t.propT("backgroundImage", transformFunctions.bgImage),
  backgroundSize: true,
  backgroundPosition: true,
  backgroundRepeat: true,
  backgroundAttachment: true,
  backgroundClip: {
    transform: transformFunctions.bgClip
  },
  bgSize: t.prop("backgroundSize"),
  bgPosition: t.prop("backgroundPosition"),
  bg: t.colors("background"),
  bgColor: t.colors("backgroundColor"),
  bgPos: t.prop("backgroundPosition"),
  bgRepeat: t.prop("backgroundRepeat"),
  bgAttachment: t.prop("backgroundAttachment"),
  bgGradient: t.propT("backgroundImage", transformFunctions.gradient),
  bgClip: {
    transform: transformFunctions.bgClip
  }
};
Object.assign(background, {
  bgImage: background.backgroundImage,
  bgImg: background.backgroundImage
});
var border = {
  border: t.borders("border"),
  borderWidth: t.borderWidths("borderWidth"),
  borderStyle: t.borderStyles("borderStyle"),
  borderColor: t.colors("borderColor"),
  borderRadius: t.radii("borderRadius"),
  borderTop: t.borders("borderTop"),
  borderBlockStart: t.borders("borderBlockStart"),
  borderTopLeftRadius: t.radii("borderTopLeftRadius"),
  borderStartStartRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderTopLeftRadius",
      rtl: "borderTopRightRadius"
    }
  }),
  borderEndStartRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomLeftRadius",
      rtl: "borderBottomRightRadius"
    }
  }),
  borderTopRightRadius: t.radii("borderTopRightRadius"),
  borderStartEndRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderTopRightRadius",
      rtl: "borderTopLeftRadius"
    }
  }),
  borderEndEndRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomRightRadius",
      rtl: "borderBottomLeftRadius"
    }
  }),
  borderRight: t.borders("borderRight"),
  borderInlineEnd: t.borders("borderInlineEnd"),
  borderBottom: t.borders("borderBottom"),
  borderBlockEnd: t.borders("borderBlockEnd"),
  borderBottomLeftRadius: t.radii("borderBottomLeftRadius"),
  borderBottomRightRadius: t.radii("borderBottomRightRadius"),
  borderLeft: t.borders("borderLeft"),
  borderInlineStart: {
    property: "borderInlineStart",
    scale: "borders"
  },
  borderInlineStartRadius: t.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopLeftRadius", "borderBottomLeftRadius"],
      rtl: ["borderTopRightRadius", "borderBottomRightRadius"]
    }
  }),
  borderInlineEndRadius: t.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopRightRadius", "borderBottomRightRadius"],
      rtl: ["borderTopLeftRadius", "borderBottomLeftRadius"]
    }
  }),
  borderX: t.borders(["borderLeft", "borderRight"]),
  borderInline: t.borders("borderInline"),
  borderY: t.borders(["borderTop", "borderBottom"]),
  borderBlock: t.borders("borderBlock"),
  borderTopWidth: t.borderWidths("borderTopWidth"),
  borderBlockStartWidth: t.borderWidths("borderBlockStartWidth"),
  borderTopColor: t.colors("borderTopColor"),
  borderBlockStartColor: t.colors("borderBlockStartColor"),
  borderTopStyle: t.borderStyles("borderTopStyle"),
  borderBlockStartStyle: t.borderStyles("borderBlockStartStyle"),
  borderBottomWidth: t.borderWidths("borderBottomWidth"),
  borderBlockEndWidth: t.borderWidths("borderBlockEndWidth"),
  borderBottomColor: t.colors("borderBottomColor"),
  borderBlockEndColor: t.colors("borderBlockEndColor"),
  borderBottomStyle: t.borderStyles("borderBottomStyle"),
  borderBlockEndStyle: t.borderStyles("borderBlockEndStyle"),
  borderLeftWidth: t.borderWidths("borderLeftWidth"),
  borderInlineStartWidth: t.borderWidths("borderInlineStartWidth"),
  borderLeftColor: t.colors("borderLeftColor"),
  borderInlineStartColor: t.colors("borderInlineStartColor"),
  borderLeftStyle: t.borderStyles("borderLeftStyle"),
  borderInlineStartStyle: t.borderStyles("borderInlineStartStyle"),
  borderRightWidth: t.borderWidths("borderRightWidth"),
  borderInlineEndWidth: t.borderWidths("borderInlineEndWidth"),
  borderRightColor: t.colors("borderRightColor"),
  borderInlineEndColor: t.colors("borderInlineEndColor"),
  borderRightStyle: t.borderStyles("borderRightStyle"),
  borderInlineEndStyle: t.borderStyles("borderInlineEndStyle"),
  borderTopRadius: t.radii(["borderTopLeftRadius", "borderTopRightRadius"]),
  borderBottomRadius: t.radii(["borderBottomLeftRadius", "borderBottomRightRadius"]),
  borderLeftRadius: t.radii(["borderTopLeftRadius", "borderBottomLeftRadius"]),
  borderRightRadius: t.radii(["borderTopRightRadius", "borderBottomRightRadius"])
};
Object.assign(border, {
  rounded: border.borderRadius,
  roundedTop: border.borderTopRadius,
  roundedTopLeft: border.borderTopLeftRadius,
  roundedTopRight: border.borderTopRightRadius,
  roundedTopStart: border.borderStartStartRadius,
  roundedTopEnd: border.borderStartEndRadius,
  roundedBottom: border.borderBottomRadius,
  roundedBottomLeft: border.borderBottomLeftRadius,
  roundedBottomRight: border.borderBottomRightRadius,
  roundedBottomStart: border.borderEndStartRadius,
  roundedBottomEnd: border.borderEndEndRadius,
  roundedLeft: border.borderLeftRadius,
  roundedRight: border.borderRightRadius,
  roundedStart: border.borderInlineStartRadius,
  roundedEnd: border.borderInlineEndRadius,
  borderStart: border.borderInlineStart,
  borderEnd: border.borderInlineEnd,
  borderTopStartRadius: border.borderStartStartRadius,
  borderTopEndRadius: border.borderStartEndRadius,
  borderBottomStartRadius: border.borderEndStartRadius,
  borderBottomEndRadius: border.borderEndEndRadius,
  borderStartRadius: border.borderInlineStartRadius,
  borderEndRadius: border.borderInlineEndRadius,
  borderStartWidth: border.borderInlineStartWidth,
  borderEndWidth: border.borderInlineEndWidth,
  borderStartColor: border.borderInlineStartColor,
  borderEndColor: border.borderInlineEndColor,
  borderStartStyle: border.borderInlineStartStyle,
  borderEndStyle: border.borderInlineEndStyle
});
/**
 * The prop types for border properties listed above
 */

var color = {
  color: t.colors("color"),
  textColor: t.colors("color"),
  fill: t.colors("fill"),
  stroke: t.colors("stroke")
};
var effect = {
  boxShadow: t.shadows("boxShadow"),
  mixBlendMode: true,
  blendMode: t.prop("mixBlendMode"),
  backgroundBlendMode: true,
  bgBlendMode: t.prop("backgroundBlendMode"),
  opacity: true
};
Object.assign(effect, {
  shadow: effect.boxShadow
});
/**
 * Types for box and text shadow properties
 */

var filter = {
  filter: {
    transform: transformFunctions.filter
  },
  blur: t.blur("--chakra-blur"),
  brightness: t.propT("--chakra-brightness", transformFunctions.brightness),
  contrast: t.propT("--chakra-contrast", transformFunctions.contrast),
  hueRotate: t.degreeT("--chakra-hue-rotate"),
  invert: t.propT("--chakra-invert", transformFunctions.invert),
  saturate: t.propT("--chakra-saturate", transformFunctions.saturate),
  dropShadow: t.propT("--chakra-drop-shadow", transformFunctions.dropShadow),
  backdropFilter: {
    transform: transformFunctions.backdropFilter
  },
  backdropBlur: t.blur("--chakra-backdrop-blur"),
  backdropBrightness: t.propT("--chakra-backdrop-brightness", transformFunctions.brightness),
  backdropContrast: t.propT("--chakra-backdrop-contrast", transformFunctions.contrast),
  backdropHueRotate: t.degreeT("--chakra-backdrop-hue-rotate"),
  backdropInvert: t.propT("--chakra-backdrop-invert", transformFunctions.invert),
  backdropSaturate: t.propT("--chakra-backdrop-saturate", transformFunctions.saturate)
};
var flexbox = {
  alignItems: true,
  alignContent: true,
  justifyItems: true,
  justifyContent: true,
  flexWrap: true,
  flexDirection: {
    transform: transformFunctions.flexDirection
  },
  experimental_spaceX: {
    "static": spaceXTemplate,
    transform: createTransform({
      scale: "space",
      transform: function transform(value) {
        return value !== null ? {
          "--chakra-space-x": value
        } : null;
      }
    })
  },
  experimental_spaceY: {
    "static": spaceYTemplate,
    transform: createTransform({
      scale: "space",
      transform: function transform(value) {
        return value != null ? {
          "--chakra-space-y": value
        } : null;
      }
    })
  },
  flex: true,
  flexFlow: true,
  flexGrow: true,
  flexShrink: true,
  flexBasis: t.sizes("flexBasis"),
  justifySelf: true,
  alignSelf: true,
  order: true,
  placeItems: true,
  placeContent: true,
  placeSelf: true,
  gap: t.space("gap"),
  rowGap: t.space("rowGap"),
  columnGap: t.space("columnGap")
};
Object.assign(flexbox, {
  flexDir: flexbox.flexDirection
});
var grid = {
  gridGap: t.space("gridGap"),
  gridColumnGap: t.space("gridColumnGap"),
  gridRowGap: t.space("gridRowGap"),
  gridColumn: true,
  gridRow: true,
  gridAutoFlow: true,
  gridAutoColumns: true,
  gridColumnStart: true,
  gridColumnEnd: true,
  gridRowStart: true,
  gridRowEnd: true,
  gridAutoRows: true,
  gridTemplate: true,
  gridTemplateColumns: true,
  gridTemplateRows: true,
  gridTemplateAreas: true,
  gridArea: true
};
var interactivity = {
  appearance: true,
  cursor: true,
  resize: true,
  userSelect: true,
  pointerEvents: true,
  outline: {
    transform: transformFunctions.outline
  },
  outlineOffset: true,
  outlineColor: t.colors("outlineColor")
};
var layout = {
  width: t.sizesT("width"),
  inlineSize: t.sizesT("inlineSize"),
  height: t.sizes("height"),
  blockSize: t.sizes("blockSize"),
  boxSize: t.sizes(["width", "height"]),
  minWidth: t.sizes("minWidth"),
  minInlineSize: t.sizes("minInlineSize"),
  minHeight: t.sizes("minHeight"),
  minBlockSize: t.sizes("minBlockSize"),
  maxWidth: t.sizes("maxWidth"),
  maxInlineSize: t.sizes("maxInlineSize"),
  maxHeight: t.sizes("maxHeight"),
  maxBlockSize: t.sizes("maxBlockSize"),
  d: t.prop("display"),
  overflow: true,
  overflowX: true,
  overflowY: true,
  overscrollBehavior: true,
  overscrollBehaviorX: true,
  overscrollBehaviorY: true,
  display: true,
  verticalAlign: true,
  boxSizing: true,
  boxDecorationBreak: true,
  "float": t.propT("float", transformFunctions["float"]),
  objectFit: true,
  objectPosition: true,
  visibility: true,
  isolation: true
};
Object.assign(layout, {
  w: layout.width,
  h: layout.height,
  minW: layout.minWidth,
  maxW: layout.maxWidth,
  minH: layout.minHeight,
  maxH: layout.maxHeight,
  overscroll: layout.overscrollBehavior,
  overscrollX: layout.overscrollBehaviorX,
  overscrollY: layout.overscrollBehaviorY
});
/**
 * Types for layout related CSS properties
 */

var list = {
  listStyleType: true,
  listStylePosition: true,
  listStylePos: t.prop("listStylePosition"),
  listStyleImage: true,
  listStyleImg: t.prop("listStyleImage")
};
var srOnly = {
  border: "0px",
  clip: "rect(0, 0, 0, 0)",
  width: "1px",
  height: "1px",
  margin: "-1px",
  padding: "0px",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
};
var srFocusable = {
  position: "static",
  width: "auto",
  height: "auto",
  clip: "auto",
  padding: "0",
  margin: "0",
  overflow: "visible",
  whiteSpace: "normal"
};

var getWithPriority = function getWithPriority(theme, key, styles) {
  var result = {};
  var obj = memoizedGet(theme, key, {});

  for (var prop in obj) {
    var isInStyles = prop in styles && styles[prop] != null;

    if (!isInStyles) {
      result[prop] = obj[prop];
    }
  }

  return result;
};

var others = {
  srOnly: {
    transform: function transform(value) {
      if (value === true) {
        return srOnly;
      }

      if (value === "focusable") {
        return srFocusable;
      }

      return {};
    }
  },
  layerStyle: {
    processResult: true,
    transform: function transform(value, theme, styles) {
      return getWithPriority(theme, "layerStyles." + value, styles);
    }
  },
  textStyle: {
    processResult: true,
    transform: function transform(value, theme, styles) {
      return getWithPriority(theme, "textStyles." + value, styles);
    }
  },
  apply: {
    processResult: true,
    transform: function transform(value, theme, styles) {
      return getWithPriority(theme, value, styles);
    }
  }
};
var position = {
  position: true,
  pos: t.prop("position"),
  zIndex: t.prop("zIndex", "zIndices"),
  inset: t.spaceT("inset"),
  insetX: t.spaceT(["left", "right"]),
  insetInline: t.spaceT("insetInline"),
  insetY: t.spaceT(["top", "bottom"]),
  insetBlock: t.spaceT("insetBlock"),
  top: t.spaceT("top"),
  insetBlockStart: t.spaceT("insetBlockStart"),
  bottom: t.spaceT("bottom"),
  insetBlockEnd: t.spaceT("insetBlockEnd"),
  left: t.spaceT("left"),
  insetInlineStart: t.logical({
    scale: "space",
    property: {
      ltr: "left",
      rtl: "right"
    }
  }),
  right: t.spaceT("right"),
  insetInlineEnd: t.logical({
    scale: "space",
    property: {
      ltr: "right",
      rtl: "left"
    }
  })
};
Object.assign(position, {
  insetStart: position.insetInlineStart,
  insetEnd: position.insetInlineEnd
});
/**
 * Types for position CSS properties
 */

/**
 * The parser configuration for common outline properties
 */

var ring = {
  ring: {
    transform: transformFunctions.ring
  },
  ringColor: t.colors("--chakra-ring-color"),
  ringOffset: t.prop("--chakra-ring-offset-width"),
  ringOffsetColor: t.colors("--chakra-ring-offset-color"),
  ringInset: t.prop("--chakra-ring-inset")
};
var space = {
  margin: t.spaceT("margin"),
  marginTop: t.spaceT("marginTop"),
  marginBlockStart: t.spaceT("marginBlockStart"),
  marginRight: t.spaceT("marginRight"),
  marginInlineEnd: t.spaceT("marginInlineEnd"),
  marginBottom: t.spaceT("marginBottom"),
  marginBlockEnd: t.spaceT("marginBlockEnd"),
  marginLeft: t.spaceT("marginLeft"),
  marginInlineStart: t.spaceT("marginInlineStart"),
  marginX: t.spaceT(["marginInlineStart", "marginInlineEnd"]),
  marginInline: t.spaceT("marginInline"),
  marginY: t.spaceT(["marginTop", "marginBottom"]),
  marginBlock: t.spaceT("marginBlock"),
  padding: t.space("padding"),
  paddingTop: t.space("paddingTop"),
  paddingBlockStart: t.space("paddingBlockStart"),
  paddingRight: t.space("paddingRight"),
  paddingBottom: t.space("paddingBottom"),
  paddingBlockEnd: t.space("paddingBlockEnd"),
  paddingLeft: t.space("paddingLeft"),
  paddingInlineStart: t.space("paddingInlineStart"),
  paddingInlineEnd: t.space("paddingInlineEnd"),
  paddingX: t.space(["paddingInlineStart", "paddingInlineEnd"]),
  paddingInline: t.space("paddingInline"),
  paddingY: t.space(["paddingTop", "paddingBottom"]),
  paddingBlock: t.space("paddingBlock")
};
Object.assign(space, {
  m: space.margin,
  mt: space.marginTop,
  mr: space.marginRight,
  me: space.marginInlineEnd,
  marginEnd: space.marginInlineEnd,
  mb: space.marginBottom,
  ml: space.marginLeft,
  ms: space.marginInlineStart,
  marginStart: space.marginInlineStart,
  mx: space.marginX,
  my: space.marginY,
  p: space.padding,
  pt: space.paddingTop,
  py: space.paddingY,
  px: space.paddingX,
  pb: space.paddingBottom,
  pl: space.paddingLeft,
  ps: space.paddingInlineStart,
  paddingStart: space.paddingInlineStart,
  pr: space.paddingRight,
  pe: space.paddingInlineEnd,
  paddingEnd: space.paddingInlineEnd
});
/**
 * Types for space related CSS properties
 */

var textDecoration = {
  textDecorationColor: t.colors("textDecorationColor"),
  textDecoration: true,
  textDecor: {
    property: "textDecoration"
  },
  textDecorationLine: true,
  textDecorationStyle: true,
  textDecorationThickness: true,
  textUnderlineOffset: true,
  textShadow: t.shadows("textShadow")
};
var transform = {
  clipPath: true,
  transform: t.propT("transform", transformFunctions.transform),
  transformOrigin: true,
  translateX: t.spaceT("--chakra-translate-x"),
  translateY: t.spaceT("--chakra-translate-y"),
  skewX: t.degreeT("--chakra-skew-x"),
  skewY: t.degreeT("--chakra-skew-y"),
  scaleX: t.prop("--chakra-scale-x"),
  scaleY: t.prop("--chakra-scale-y"),
  scale: t.prop(["--chakra-scale-x", "--chakra-scale-y"]),
  rotate: t.degreeT("--chakra-rotate")
};
var transition = {
  transition: true,
  transitionDelay: true,
  animation: true,
  willChange: true,
  transitionDuration: t.prop("transitionDuration", "transition.duration"),
  transitionProperty: t.prop("transitionProperty", "transition.property"),
  transitionTimingFunction: t.prop("transitionTimingFunction", "transition.easing")
};
var typography = {
  fontFamily: t.prop("fontFamily", "fonts"),
  fontSize: t.prop("fontSize", "fontSizes", transformFunctions.px),
  fontWeight: t.prop("fontWeight", "fontWeights"),
  lineHeight: t.prop("lineHeight", "lineHeights"),
  letterSpacing: t.prop("letterSpacing", "letterSpacings"),
  textAlign: true,
  fontStyle: true,
  wordBreak: true,
  overflowWrap: true,
  textOverflow: true,
  textTransform: true,
  whiteSpace: true,
  noOfLines: {
    "static": {
      overflow: "hidden",
      textOverflow: "ellipsis",
      display: "-webkit-box",
      WebkitBoxOrient: "vertical",
      //@ts-ignore
      WebkitLineClamp: "var(--chakra-line-clamp)"
    },
    property: "--chakra-line-clamp"
  },
  isTruncated: {
    transform: function transform(value) {
      if (value === true) {
        return {
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap"
        };
      }
    }
  }
};
/**
 * Types for typography related CSS properties
 */

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) {
    len = arr.length;
  }

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) {
    return;
  }

  if (typeof o === "string") {
    return _arrayLikeToArray(o, minLen);
  }

  var n = Object.prototype.toString.call(o).slice(8, -1);

  if (n === "Object" && o.constructor) {
    n = o.constructor.name;
  }

  if (n === "Map" || n === "Set") {
    return Array.from(o);
  }

  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
    return _arrayLikeToArray(o, minLen);
  }
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (it) {
    return (it = it.call(o)).next.bind(it);
  }

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) {
      o = it;
    }

    var i = 0;
    return function () {
      if (i >= o.length) {
        return {
          done: true
        };
      }

      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var group = {
  hover: function hover(selector) {
    return selector + ":hover &, " + selector + "[data-hover] &";
  },
  focus: function focus(selector) {
    return selector + ":focus &, " + selector + "[data-focus] &";
  },
  focusVisible: function focusVisible(selector) {
    return selector + ":focus-visible &";
  },
  active: function active(selector) {
    return selector + ":active &, " + selector + "[data-active] &";
  },
  disabled: function disabled(selector) {
    return selector + ":disabled &, " + selector + "[data-disabled] &";
  },
  invalid: function invalid(selector) {
    return selector + ":invalid &, " + selector + "[data-invalid] &";
  },
  checked: function checked(selector) {
    return selector + ":checked &, " + selector + "[data-checked] &";
  },
  indeterminate: function indeterminate(selector) {
    return selector + ":indeterminate &, " + selector + "[aria-checked=mixed] &, " + selector + "[data-indeterminate] &";
  },
  readOnly: function readOnly(selector) {
    return selector + ":read-only &, " + selector + "[readonly] &, " + selector + "[data-read-only] &";
  },
  expanded: function expanded(selector) {
    return selector + ":read-only &, " + selector + "[aria-expanded=true] &, " + selector + "[data-expanded] &";
  }
};

var toGroup = function toGroup(fn) {
  return merge(fn, "[role=group]", "[data-group]", ".group");
};

var merge = function merge(fn) {
  var arguments$1 = arguments;

  for (var _len = arguments.length, selectors = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    selectors[_key - 1] = arguments$1[_key];
  }

  return selectors.map(fn).join(", ");
};

var pseudoSelectors = {
  /**
   * Styles for CSS selector `&:hover`
   */
  _hover: "&:hover, &[data-hover]",

  /**
   * Styles for CSS Selector `&:active`
   */
  _active: "&:active, &[data-active]",

  /**
   * Styles for CSS selector `&:focus`
   *
   */
  _focus: "&:focus, &[data-focus]",

  /**
   * Styles for the highlighted state.
   */
  _highlighted: "&[data-highlighted]",

  /**
   * Styles to apply when a child of this element has received focus
   * - CSS Selector `&:focus-within`
   */
  _focusWithin: "&:focus-within",
  _focusVisible: "&:focus-visible",

  /**
   * Styles to apply when this element is disabled. The passed styles are applied to these CSS selectors:
   * - `&[aria-disabled=true]`
   * - `&:disabled`
   * - `&[data-disabled]`
   */
  _disabled: "&[disabled], &[aria-disabled=true], &[data-disabled]",

  /**
   * Styles for CSS Selector `&:readonly`
   */
  _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",

  /**
   * Styles for CSS selector `&::before`
   *
   * NOTE:When using this, ensure the `content` is wrapped in a backtick.
   * @example
   * ```jsx
   * <Box _before={{content:`""` }}/>
   * ```
   */
  _before: "&::before",

  /**
   * Styles for CSS selector `&::after`
   *
   * NOTE:When using this, ensure the `content` is wrapped in a backtick.
   * @example
   * ```jsx
   * <Box _after={{content:`""` }}/>
   * ```
   */
  _after: "&::after",
  _empty: "&:empty",

  /**
   * Styles to apply when the ARIA attribute `aria-expanded` is `true`
   * - CSS selector `&[aria-expanded=true]`
   */
  _expanded: "&[aria-expanded=true], &[data-expanded]",

  /**
   * Styles to apply when the ARIA attribute `aria-checked` is `true`
   * - CSS selector `&[aria-checked=true]`
   */
  _checked: "&[aria-checked=true], &[data-checked]",

  /**
   * Styles to apply when the ARIA attribute `aria-grabbed` is `true`
   * - CSS selector `&[aria-grabbed=true]`
   */
  _grabbed: "&[aria-grabbed=true], &[data-grabbed]",

  /**
   * Styles for CSS Selector `&[aria-pressed=true]`
   * Typically used to style the current "pressed" state of toggle buttons
   */
  _pressed: "&[aria-pressed=true], &[data-pressed]",

  /**
   * Styles to apply when the ARIA attribute `aria-invalid` is `true`
   * - CSS selector `&[aria-invalid=true]`
   */
  _invalid: "&[aria-invalid=true], &[data-invalid]",

  /**
   * Styles for the valid state
   * - CSS selector `&[data-valid], &[data-state=valid]`
   */
  _valid: "&[data-valid], &[data-state=valid]",

  /**
   * Styles for CSS Selector `&[aria-busy=true]` or `&[data-loading=true]`.
   * Useful for styling loading states
   */
  _loading: "&[data-loading], &[aria-busy=true]",

  /**
   * Styles to apply when the ARIA attribute `aria-selected` is `true`
   *
   * - CSS selector `&[aria-selected=true]`
   */
  _selected: "&[aria-selected=true], &[data-selected]",

  /**
   * Styles for CSS Selector `[hidden=true]`
   */
  _hidden: "&[hidden], &[data-hidden]",

  /**
   * Styles for CSS Selector `&:-webkit-autofill`
   */
  _autofill: "&:-webkit-autofill",

  /**
   * Styles for CSS Selector `&:nth-child(even)`
   */
  _even: "&:nth-of-type(even)",

  /**
   * Styles for CSS Selector `&:nth-child(odd)`
   */
  _odd: "&:nth-of-type(odd)",

  /**
   * Styles for CSS Selector `&:first-of-type`
   */
  _first: "&:first-of-type",

  /**
   * Styles for CSS Selector `&:last-of-type`
   */
  _last: "&:last-of-type",

  /**
   * Styles for CSS Selector `&:not(:first-of-type)`
   */
  _notFirst: "&:not(:first-of-type)",

  /**
   * Styles for CSS Selector `&:not(:last-of-type)`
   */
  _notLast: "&:not(:last-of-type)",

  /**
   * Styles for CSS Selector `&:visited`
   */
  _visited: "&:visited",

  /**
   * Used to style the active link in a navigation
   * Styles for CSS Selector `&[aria-current=page]`
   */
  _activeLink: "&[aria-current=page]",

  /**
   * Used to style the current step within a process
   * Styles for CSS Selector `&[aria-current=step]`
   */
  _activeStep: "&[aria-current=step]",

  /**
   * Styles to apply when the ARIA attribute `aria-checked` is `mixed`
   * - CSS selector `&[aria-checked=mixed]`
   */
  _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate]",

  /**
   * Styles to apply when parent is hovered
   */
  _groupHover: toGroup(group.hover),

  /**
   * Styles to apply when parent is focused
   */
  _groupFocus: toGroup(group.focus),
  _groupFocusVisible: toGroup(group.focusVisible),

  /**
   * Styles to apply when parent is active
   */
  _groupActive: toGroup(group.active),

  /**
   * Styles to apply when parent is disabled
   */
  _groupDisabled: toGroup(group.disabled),

  /**
   * Styles to apply when parent is invalid
   */
  _groupInvalid: toGroup(group.invalid),

  /**
   * Styles to apply when parent is checked
   */
  _groupChecked: toGroup(group.checked),

  /**
   * Styles for CSS Selector `&::placeholder`.
   */
  _placeholder: "&::placeholder",

  /**
   * Styles for CSS Selector `&:fullscreen`.
   */
  _fullScreen: "&:fullscreen",

  /**
   * Styles for CSS Selector `&::selection`
   */
  _selection: "&::selection",

  /**
   * Styles for CSS Selector `[dir=rtl] &`
   * It is applied when any parent element has `dir="rtl"`
   */
  _rtl: "[dir=rtl] &",

  /**
   * Styles for CSS Selector `@media (prefers-color-scheme: dark)`
   * used when the user has requested the system
   * use a light or dark color theme.
   */
  _mediaDark: "@media (prefers-color-scheme: dark)",

  /**
   * Styles for when `data-theme` is applied to any parent of
   * this component or element.
   */
  _dark: ".chakra-ui-dark &, [data-theme=dark] &, &[data-theme=dark]",

  /**
   * Styles for when `data-theme` is applied to any parent of
   * this component or element.
   */
  _light: ".chakra-ui-light &, [data-theme=light] &, &[data-theme=light]"
};
var systemProps = lodash_mergewith({}, background, border, color, flexbox, layout, filter, ring, interactivity, grid, others, position, effect, space, typography, textDecoration, transform, list, transition);
var layoutSystem = Object.assign({}, space, layout, flexbox, grid, position);

var styleProps = _extends({}, systemProps, pseudoSelectors);

var isStyleProp = function isStyleProp(prop) {
  return prop in styleProps;
};
/**
 * Expands an array or object syntax responsive style.
 *
 * @example
 * expandResponsive({ mx: [1, 2] })
 * // or
 * expandResponsive({ mx: { base: 1, sm: 2 } })
 *
 * // => { mx: 1, "@media(min-width:<sm>)": { mx: 2 } }
 */


var expandResponsive = function expandResponsive(styles) {
  return function (theme) {
    /**
     * Before any style can be processed, the user needs to call `toCSSVar`
     * which analyzes the theme's breakpoint and appends a `__breakpoints` property
     * to the theme with more details of the breakpoints.
     *
     * To learn more, go here: packages/utils/src/responsive.ts #analyzeBreakpoints
     */
    if (!theme.__breakpoints) {
      return styles;
    }

    var _theme$__breakpoints = theme.__breakpoints,
        isResponsive = _theme$__breakpoints.isResponsive,
        toArrayValue = _theme$__breakpoints.toArrayValue,
        medias = _theme$__breakpoints.media;
    var computedStyles = {};

    for (var key in styles) {
      var value = runIfFn(styles[key], theme);

      if (value == null) {
        continue;
      } // converts the object responsive syntax to array syntax


      value = isObject(value) && isResponsive(value) ? toArrayValue(value) : value;

      if (!Array.isArray(value)) {
        computedStyles[key] = value;
        continue;
      }

      var queries = value.slice(0, medias.length).length;

      for (var index = 0; index < queries; index += 1) {
        var media = medias == null ? void 0 : medias[index];

        if (!media) {
          computedStyles[key] = value[index];
          continue;
        }

        computedStyles[media] = computedStyles[media] || {};

        if (value[index] == null) {
          continue;
        }

        computedStyles[media][key] = value[index];
      }
    }

    return computedStyles;
  };
};

var isCSSVariableTokenValue = function isCSSVariableTokenValue(key, value) {
  return key.startsWith("--") && isString(value) && !isCssVar(value);
};

var resolveTokenValue = function resolveTokenValue(theme, value) {
  var _ref, _getVar2;

  if (value == null) {
    return value;
  }

  var getVar = function getVar(val) {
    var _theme$__cssMap, _theme$__cssMap$val;

    return (_theme$__cssMap = theme.__cssMap) == null ? void 0 : (_theme$__cssMap$val = _theme$__cssMap[val]) == null ? void 0 : _theme$__cssMap$val.varRef;
  };

  var getValue = function getValue(val) {
    var _getVar;

    return (_getVar = getVar(val)) != null ? _getVar : val;
  };

  var valueSplit = value.split(",").map(function (v) {
    return v.trim();
  });
  var tokenValue = valueSplit[0],
      fallbackValue = valueSplit[1];
  value = (_ref = (_getVar2 = getVar(tokenValue)) != null ? _getVar2 : getValue(fallbackValue)) != null ? _ref : getValue(value);
  return value;
};

function getCss(options) {
  var _options$configs = options.configs,
      configs = _options$configs === void 0 ? {} : _options$configs,
      _options$pseudos = options.pseudos,
      pseudos = _options$pseudos === void 0 ? {} : _options$pseudos,
      theme = options.theme;

  var css = function css(stylesOrFn, nested) {
    if (nested === void 0) {
      nested = false;
    }

    var _styles = runIfFn(stylesOrFn, theme);

    var styles = expandResponsive(_styles)(theme);
    var computedStyles = {};

    for (var key in styles) {
      var _config$transform, _config, _config2, _config3, _config4;

      var valueOrFn = styles[key];
      /**
       * allows the user to pass functional values
       * boxShadow: theme => `0 2px 2px ${theme.colors.red}`
       */

      var value = runIfFn(valueOrFn, theme);
      /**
       * converts pseudo shorthands to valid selector
       * "_hover" => "&:hover"
       */

      if (key in pseudos) {
        key = pseudos[key];
      }
      /**
       * allows the user to use theme tokens in css vars
       * { --banner-height: "sizes.md" } => { --banner-height: "var(--chakra-sizes-md)" }
       *
       * You can also provide fallback values
       * { --banner-height: "sizes.no-exist, 40px" } => { --banner-height: "40px" }
       */


      if (isCSSVariableTokenValue(key, value)) {
        value = resolveTokenValue(theme, value);
      }

      var config = configs[key];

      if (config === true) {
        config = {
          property: key
        };
      }

      if (isObject(value)) {
        var _computedStyles$key;

        computedStyles[key] = (_computedStyles$key = computedStyles[key]) != null ? _computedStyles$key : {};
        computedStyles[key] = lodash_mergewith({}, computedStyles[key], css(value, true));
        continue;
      }

      var rawValue = (_config$transform = (_config = config) == null ? void 0 : _config.transform == null ? void 0 : _config.transform(value, theme, _styles)) != null ? _config$transform : value;
      /**
       * Used for `layerStyle`, `textStyle` and `apply`. After getting the
       * styles in the theme, we need to process them since they might
       * contain theme tokens.
       *
       * `processResult` is the config property we pass to `layerStyle`, `textStyle` and `apply`
       */

      rawValue = (_config2 = config) != null && _config2.processResult ? css(rawValue, true) : rawValue;
      /**
       * allows us define css properties for RTL and LTR.
       *
       * const marginStart = {
       *   property: theme => theme.direction === "rtl" ? "marginRight": "marginLeft",
       * }
       */

      var configProperty = runIfFn((_config3 = config) == null ? void 0 : _config3.property, theme);

      if (!nested && (_config4 = config) != null && _config4["static"]) {
        var staticStyles = runIfFn(config["static"], theme);
        computedStyles = lodash_mergewith({}, computedStyles, staticStyles);
      }

      if (configProperty && Array.isArray(configProperty)) {
        for (var _iterator = _createForOfIteratorHelperLoose(configProperty), _step; !(_step = _iterator()).done;) {
          var property = _step.value;
          computedStyles[property] = rawValue;
        }

        continue;
      }

      if (configProperty) {
        if (configProperty === "&" && isObject(rawValue)) {
          computedStyles = lodash_mergewith({}, computedStyles, rawValue);
        } else {
          computedStyles[configProperty] = rawValue;
        }

        continue;
      }

      if (isObject(rawValue)) {
        computedStyles = lodash_mergewith({}, computedStyles, rawValue);
        continue;
      }

      computedStyles[key] = rawValue;
    }

    return computedStyles;
  };

  return css;
}

var css = function css(styles) {
  return function (theme) {
    var cssFn = getCss({
      theme: theme,
      pseudos: pseudoSelectors,
      configs: systemProps
    });
    return cssFn(styles);
  };
};
/**
 * Thank you @markdalgleish for this piece of art!
 */


function resolveReference(operand) {
  if (isObject(operand) && operand.reference) {
    return operand.reference;
  }

  return String(operand);
}

var toExpression = function toExpression(operator) {
  var arguments$1 = arguments;

  for (var _len = arguments.length, operands = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    operands[_key - 1] = arguments$1[_key];
  }

  return operands.map(resolveReference).join(" " + operator + " ").replace(/calc/g, "");
};

var _add = function add() {
  var arguments$1 = arguments;

  for (var _len2 = arguments.length, operands = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    operands[_key2] = arguments$1[_key2];
  }

  return "calc(" + toExpression.apply(void 0, ["+"].concat(operands)) + ")";
};

var _subtract = function subtract() {
  var arguments$1 = arguments;

  for (var _len3 = arguments.length, operands = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    operands[_key3] = arguments$1[_key3];
  }

  return "calc(" + toExpression.apply(void 0, ["-"].concat(operands)) + ")";
};

var _multiply = function multiply() {
  var arguments$1 = arguments;

  for (var _len4 = arguments.length, operands = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    operands[_key4] = arguments$1[_key4];
  }

  return "calc(" + toExpression.apply(void 0, ["*"].concat(operands)) + ")";
};

var _divide = function divide() {
  var arguments$1 = arguments;

  for (var _len5 = arguments.length, operands = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    operands[_key5] = arguments$1[_key5];
  }

  return "calc(" + toExpression.apply(void 0, ["/"].concat(operands)) + ")";
};

var _negate = function negate(x) {
  var value = resolveReference(x);

  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : "-" + value;
  }

  return _multiply(value, -1);
};

var calc = Object.assign(function (x) {
  return {
    add: function add() {
      var arguments$1 = arguments;

      for (var _len6 = arguments.length, operands = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        operands[_key6] = arguments$1[_key6];
      }

      return calc(_add.apply(void 0, [x].concat(operands)));
    },
    subtract: function subtract() {
      var arguments$1 = arguments;

      for (var _len7 = arguments.length, operands = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        operands[_key7] = arguments$1[_key7];
      }

      return calc(_subtract.apply(void 0, [x].concat(operands)));
    },
    multiply: function multiply() {
      var arguments$1 = arguments;

      for (var _len8 = arguments.length, operands = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        operands[_key8] = arguments$1[_key8];
      }

      return calc(_multiply.apply(void 0, [x].concat(operands)));
    },
    divide: function divide() {
      var arguments$1 = arguments;

      for (var _len9 = arguments.length, operands = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        operands[_key9] = arguments$1[_key9];
      }

      return calc(_divide.apply(void 0, [x].concat(operands)));
    },
    negate: function negate() {
      return calc(_negate(x));
    },
    toString: function toString() {
      return x.toString();
    }
  };
}, {
  add: _add,
  subtract: _subtract,
  multiply: _multiply,
  divide: _divide,
  negate: _negate
});

function replaceWhiteSpace(value, replaceValue) {
  if (replaceValue === void 0) {
    replaceValue = "-";
  }

  return value.replace(/\s+/g, replaceValue);
}

function escape(value) {
  var valueStr = replaceWhiteSpace(value.toString());

  if (valueStr.includes("\\.")) {
    return value;
  }

  var isDecimal = !Number.isInteger(parseFloat(value.toString()));
  return isDecimal ? valueStr.replace(".", "\\.") : value;
}

function addPrefix(value, prefix) {
  if (prefix === void 0) {
    prefix = "";
  }

  return [prefix, escape(value)].filter(Boolean).join("-");
}

function toVarReference(name, fallback) {
  return "var(" + escape(name) + (fallback ? ", " + fallback : "") + ")";
}

function toVarDefinition(value, prefix) {
  if (prefix === void 0) {
    prefix = "";
  }

  return "--" + addPrefix(value, prefix);
}

function cssVar(name, fallback, cssVarPrefix) {
  var cssVariable = toVarDefinition(name, cssVarPrefix);
  return {
    variable: cssVariable,
    reference: toVarReference(cssVariable, fallback)
  };
}

function createThemeVars(target, options) {
  var context = {
    cssMap: {},
    cssVars: {}
  };
  walkObject(target, function (value, path) {
    var _tokenHandlerMap$firs; // firstKey will be e.g. "space"


    var firstKey = path[0];
    var handler = (_tokenHandlerMap$firs = tokenHandlerMap[firstKey]) != null ? _tokenHandlerMap$firs : tokenHandlerMap.defaultHandler;

    var _handler = handler(path, value, options),
        cssVars = _handler.cssVars,
        cssMap = _handler.cssMap;

    Object.assign(context.cssVars, cssVars);
    Object.assign(context.cssMap, cssMap);
  });
  return context;
}
/**
 * Define transformation handlers for ThemeScale
 */


var tokenHandlerMap = {
  space: function space(keys, value, options) {
    var _extends2;

    var properties = tokenHandlerMap.defaultHandler(keys, value, options);
    var firstKey = keys[0],
        referenceKeys = keys.slice(1);
    var negativeLookupKey = firstKey + ".-" + referenceKeys.join(".");
    var negativeVarKey = keys.join("-");

    var _cssVar = cssVar(negativeVarKey, undefined, options.cssVarPrefix),
        variable = _cssVar.variable,
        reference = _cssVar.reference;

    var negativeValue = calc.negate(value);
    var varRef = calc.negate(reference);
    return {
      cssVars: properties.cssVars,
      cssMap: _extends({}, properties.cssMap, (_extends2 = {}, _extends2[negativeLookupKey] = {
        value: "" + negativeValue,
        "var": "" + variable,
        varRef: varRef
      }, _extends2))
    };
  },
  defaultHandler: function defaultHandler(keys, value, options) {
    var _cssVars, _cssMap;

    var lookupKey = keys.join(".");
    var varKey = keys.join("-");

    var _cssVar2 = cssVar(varKey, undefined, options.cssVarPrefix),
        variable = _cssVar2.variable,
        reference = _cssVar2.reference;

    return {
      cssVars: (_cssVars = {}, _cssVars[variable] = value, _cssVars),
      cssMap: (_cssMap = {}, _cssMap[lookupKey] = {
        value: value,
        "var": variable,
        varRef: reference
      }, _cssMap)
    };
  }
};

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) {
    return {};
  }

  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];

    if (excluded.indexOf(key) >= 0) {
      continue;
    }

    target[key] = source[key];
  }

  return target;
}

var _excluded = ["__cssMap", "__cssVars", "__breakpoints"];
var tokens = ["colors", "borders", "borderWidths", "borderStyles", "fonts", "fontSizes", "fontWeights", "letterSpacings", "lineHeights", "radii", "space", "shadows", "sizes", "zIndices", "transition", "blur"];

function extractTokens(theme) {
  var _tokens = tokens;
  return pick(theme, _tokens);
}

function omitVars(rawTheme) {
  rawTheme.__cssMap;
  rawTheme.__cssVars;
  rawTheme.__breakpoints;

  var cleanTheme = _objectWithoutPropertiesLoose(rawTheme, _excluded);

  return cleanTheme;
}

function toCSSVar(rawTheme) {
  var _theme$config;
  /**
   * In the case the theme has already been converted to css-var (e.g extending the theme),
   * we can omit the computed css vars and recompute it for the extended theme.
   */


  var theme = omitVars(rawTheme); // omit components and breakpoints from css variable map

  var tokens = extractTokens(theme);
  var cssVarPrefix = (_theme$config = theme.config) == null ? void 0 : _theme$config.cssVarPrefix;

  var _createThemeVars = createThemeVars(tokens, {
    cssVarPrefix: cssVarPrefix
  }),
      cssMap = _createThemeVars.cssMap,
      cssVars = _createThemeVars.cssVars;

  var defaultCssVars = {
    "--chakra-ring-inset": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-ring-offset-width": "0px",
    "--chakra-ring-offset-color": "#fff",
    "--chakra-ring-color": "rgba(66, 153, 225, 0.6)",
    "--chakra-ring-offset-shadow": "0 0 #0000",
    "--chakra-ring-shadow": "0 0 #0000",
    "--chakra-space-x-reverse": "0",
    "--chakra-space-y-reverse": "0"
  };
  Object.assign(theme, {
    __cssVars: _extends({}, defaultCssVars, cssVars),
    __cssMap: cssMap,
    __breakpoints: analyzeBreakpoints(theme.breakpoints)
  });
  return theme;
}

exports.createCommonjsModule = createCommonjsModule;
exports.css = css;
exports.isStyleProp = isStyleProp;
exports.runIfFn = runIfFn;
exports.toCSSVar = toCSSVar;
exports.unwrapExports = unwrapExports;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);
/**
 * Hey! Welcome to @chakra-ui/vue Box
 *
 * Box is the most abstract component on top of which all
 * other @chakra-ui/vue components are built. By default, it renders a `div` element
 *
 * @see Docs     https://vue.chakra-ui.com/box
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CBox/CBox.js
 */

/**
 * CBox component
 *
 * Abstract component on top of which all other Chakra components are built.
 *
 * @see Docs https://vue.chakra-ui.com/box
 */


var CBox = {
  name: 'CBox',
  mixins: [utils.createStyledAttrsMixin('CBox')],
  props: {
    as: {
      type: [String, Object],
      default: 'div'
    },
    to: {
      type: [String, Object],
      default: ''
    }
  },
  render: function render(h) {
    return h(this.as, {
      props: {
        to: this.to
      },
      class: this.className,
      on: this.listeners$,
      attrs: this.computedAttrs
    }, this.$slots.default);
  }
};
exports.default = CBox;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


var StringArray = [String, Array];
var SNA = [Number, String, Array, Object];
var StringNumber = [String, Number];
exports.SNA = SNA;
exports.StringArray = StringArray;
exports.StringNumber = StringNumber;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("ufo");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */

/**
 * Internal icon paths
 */

var icons = {
  star: {
    path: "\n      <path\n        fill=\"currentColor\"\n        d=\"M23.555,8.729a1.505,1.505,0,0,0-1.406-.98H16.062a.5.5,0,0,1-.472-.334L13.405,1.222a1.5,1.5,0,0,0-2.81,0l-.005.016L8.41,7.415a.5.5,0,0,1-.471.334H1.85A1.5,1.5,0,0,0,.887,10.4l5.184,4.3a.5.5,0,0,1,.155.543L4.048,21.774a1.5,1.5,0,0,0,2.31,1.684l5.346-3.92a.5.5,0,0,1,.591,0l5.344,3.919a1.5,1.5,0,0,0,2.312-1.683l-2.178-6.535a.5.5,0,0,1,.155-.543l5.194-4.306A1.5,1.5,0,0,0,23.555,8.729Z\"\n      />\n    "
  },
  email: {
    path: "\n    <g fill=\"currentColor\">\n      <path d=\"M11.114,14.556a1.252,1.252,0,0,0,1.768,0L22.568,4.87a.5.5,0,0,0-.281-.849A1.966,1.966,0,0,0,22,4H2a1.966,1.966,0,0,0-.289.021.5.5,0,0,0-.281.849Z\" />\n      <path d=\"M23.888,5.832a.182.182,0,0,0-.2.039l-6.2,6.2a.251.251,0,0,0,0,.354l5.043,5.043a.75.75,0,1,1-1.06,1.061l-5.043-5.043a.25.25,0,0,0-.354,0l-2.129,2.129a2.75,2.75,0,0,1-3.888,0L7.926,13.488a.251.251,0,0,0-.354,0L2.529,18.531a.75.75,0,0,1-1.06-1.061l5.043-5.043a.251.251,0,0,0,0-.354l-6.2-6.2a.18.18,0,0,0-.2-.039A.182.182,0,0,0,0,6V18a2,2,0,0,0,2,2H22a2,2,0,0,0,2-2V6A.181.181,0,0,0,23.888,5.832Z\" />\n    </g>\n    "
  },
  phone: {
    viewBox: '0 0 14 14',
    path: "\n    <path\n      fill=\"currentColor\"\n      d=\"M2.20731,0.0127209 C2.1105,-0.0066419 1.99432,-0.00664663 1.91687,0.032079 C0.871279,0.438698 0.212942,1.92964 0.0580392,2.95587 C-0.426031,6.28627 2.20731,9.17133 4.62766,11.0689 C6.77694,12.7534 10.9012,15.5223 13.3409,12.8503 C13.6507,12.5211 14.0186,12.037 13.9993,11.553 C13.9412,10.7397 13.186,10.1588 12.6051,9.71349 C12.1598,9.38432 11.2304,8.47427 10.6495,8.49363 C10.1267,8.51299 9.79754,9.05515 9.46837,9.38432 L8.88748,9.96521 C8.79067,10.062 7.55145,9.24878 7.41591,9.15197 C6.91248,8.8228 6.4284,8.45491 6.00242,8.04829 C5.57644,7.64167 5.18919,7.19632 4.86002,6.73161 C4.7632,6.59607 3.96933,5.41495 4.04678,5.31813 C4.04678,5.31813 4.72448,4.58234 4.91811,4.2919 C5.32473,3.67229 5.63453,3.18822 5.16982,2.45243 C4.99556,2.18135 4.78257,1.96836 4.55021,1.73601 C4.14359,1.34875 3.73698,0.942131 3.27227,0.612963 C3.02055,0.419335 2.59457,0.0708094 2.20731,0.0127209 Z\"\n    />\n    "
  },
  info: {
    path: "\n    <path\n      fill=\"currentColor\"\n      d=\"M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z\"\n    />\n    "
  },
  'warning-alt': {
    path: "\n      <path\n        fill=\"currentColor\"\n        d=\"M23.119,20,13.772,2.15h0a2,2,0,0,0-3.543,0L.881,20a2,2,0,0,0,1.772,2.928H21.347A2,2,0,0,0,23.119,20ZM11,8.423a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Zm1.05,11.51h-.028a1.528,1.528,0,0,1-1.522-1.47,1.476,1.476,0,0,1,1.448-1.53h.028A1.527,1.527,0,0,1,13.5,18.4,1.475,1.475,0,0,1,12.05,19.933Z\"\n      />"
  },
  check: {
    path: "\n      <g fill=\"currentColor\">\n        <polygon points=\"5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039\" />\n      </g>\n    ",
    viewBox: '0 0 14 14'
  },
  'check-circle': {
    path: "\n      <path\n        fill=\"currentColor\"\n        d=\"M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z\"\n      />"
  },
  exclamation: {
    path: "\n      <path\n        fill=\"currentColor\"\n        d=\"M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z\"\n      />"
  },
  'question-outline': {
    viewBox: '0 0 24 24',
    path: "\n    <g stroke=\"currentColor\" strokeWidth=\"1.5\">\n      <path\n        strokeLinecap=\"full\"\n        fill=\"none\"\n        d=\"M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25\"\n      />\n      <path\n        fill=\"none\"\n        strokeLinecap=\"full\"\n        d=\"M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0\"\n      />\n      <circle fill=\"none\" strokeMiterlimit=\"10\" cx=\"12\" cy=\"12\" r=\"11.25\" />\n    </g>\n    "
  },
  close: {
    path: "\n      <path\n        fill=\"currentColor\"\n        d=\"M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z\"\n      />"
  },
  'chevron-right': {
    path: "\n    <path\n      fill=\"currentColor\"\n      d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"\n    />"
  },
  'chevron-left': {
    path: "\n      <path\n        fill=\"currentColor\"\n        d=\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\"\n      />"
  },
  'chevron-down': {
    path: "\n    <path\n      fill=\"currentColor\"\n      d=\"M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z\"\n    />"
  },
  'chevron-up': {
    path: "\n    <path\n      fill=\"currentColor\"\n      d=\"M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z\"\n    />"
  },
  'arrow-forward': {
    path: "\n    <path\n      fill=\"currentColor\"\n      d=\"M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z\"\n    />"
  },
  'arrow-up': {
    path: "\n    <path\n      fill=\"currentColor\"\n      d=\"M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z\"\n    />"
  },
  'arrow-down': {
    path: "\n      <path\n        fill=\"currentColor\"\n        d=\"M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z\"\n      />"
  },
  add: {
    path: "\n    <path\n      fill=\"currentColor\"\n      d=\"M0,12a1.5,1.5,0,0,0,1.5,1.5h8.75a.25.25,0,0,1,.25.25V22.5a1.5,1.5,0,0,0,3,0V13.75a.25.25,0,0,1,.25-.25H22.5a1.5,1.5,0,0,0,0-3H13.75a.25.25,0,0,1-.25-.25V1.5a1.5,1.5,0,0,0-3,0v8.75a.25.25,0,0,1-.25.25H1.5A1.5,1.5,0,0,0,0,12Z\"\n    />\n    "
  },
  minus: {
    path: "\n      <g fill=\"currentColor\">\n        <rect height=\"4\" width=\"20\" x=\"2\" y=\"10\" />\n      </g>\n    "
  },
  moon: {
    path: "\n      <path\n        fill=\"currentColor\"\n        d=\"M21.4,13.7C20.6,13.9,19.8,14,19,14c-5,0-9-4-9-9c0-0.8,0.1-1.6,0.3-2.4c0.1-0.3,0-0.7-0.3-1 c-0.3-0.3-0.6-0.4-1-0.3C4.3,2.7,1,7.1,1,12c0,6.1,4.9,11,11,11c4.9,0,9.3-3.3,10.6-8.1c0.1-0.3,0-0.7-0.3-1 C22.1,13.7,21.7,13.6,21.4,13.7z\"\n      />\n    "
  },
  sun: {
    path: "\n      <g\n        strokeLinejoin=\"full\"\n        strokeLinecap=\"full\"\n        strokeWidth=\"2\"\n        fill=\"none\"\n        stroke=\"currentColor\"\n      >\n        <circle cx=\"12\" cy=\"12\" r=\"5\" />\n        <path d=\"M12 1v2\" />\n        <path d=\"M12 21v2\" />\n        <path d=\"M4.22 4.22l1.42 1.42\" />\n        <path d=\"M18.36 18.36l1.42 1.42\" />\n        <path d=\"M1 12h2\" />\n        <path d=\"M21 12h2\" />\n        <path d=\"M4.22 19.78l1.42-1.42\" />\n        <path d=\"M18.36 5.64l1.42-1.42\" />\n      </g>\n    "
  },
  warning: {
    path: "\n    <path\n      fill=\"currentColor\"\n      d=\"M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z\"\n    />"
  },
  'small-close': {
    path: "\n      <path\n        d=\"M9.41 8l2.29-2.29c.19-.18.3-.43.3-.71a1.003 1.003 0 0 0-1.71-.71L8 6.59l-2.29-2.3a1.003 1.003 0 0 0-1.42 1.42L6.59 8 4.3 10.29c-.19.18-.3.43-.3.71a1.003 1.003 0 0 0 1.71.71L8 9.41l2.29 2.29c.18.19.43.3.71.3a1.003 1.003 0 0 0 .71-1.71L9.41 8z\"\n        fillRule=\"evenodd\"\n        fill=\"currentColor\"\n      />\n    ",
    viewBox: '0 0 16 16'
  },
  'triangle-up': {
    path: "\n      <path\n        fill=\"currentColor\"\n        d=\"M12.8,5.4c-0.377-0.504-1.223-0.504-1.6,0l-9,12c-0.228,0.303-0.264,0.708-0.095,1.047 C2.275,18.786,2.621,19,3,19h18c0.379,0,0.725-0.214,0.895-0.553c0.169-0.339,0.133-0.744-0.095-1.047L12.8,5.4z\"\n      />\n    "
  },
  'triangle-down': {
    path: "\n      <path\n        fill=\"currentColor\"\n        d=\"M21,5H3C2.621,5,2.275,5.214,2.105,5.553C1.937,5.892,1.973,6.297,2.2,6.6l9,12 c0.188,0.252,0.485,0.4,0.8,0.4s0.611-0.148,0.8-0.4l9-12c0.228-0.303,0.264-0.708,0.095-1.047C21.725,5.214,21.379,5,21,5z\"\n      />\n    "
  }
};
exports.internalIcons = icons;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


var utils = __webpack_require__(2);

var internalIcons = __webpack_require__(8);

var css = __webpack_require__(1);

var iconProps = {
  name: {
    type: [String, Array]
  },
  use: {
    type: [String, Array],
    required: false
  },
  pack: {
    type: String,
    required: false,
    default: 'fas',
    validator: function validator(value) {
      return value.match(/^(fas|fal|fad)$/);
    }
  },
  size: {
    type: [String, Number, Array],
    default: '1em'
  }
};
/**
 * Hey! Welcome to @chakra-ui/vue Icon
 *
 * CIcon is used for rendering icons.
 *
 * Use the <CIcon> component to easily render <svg> icons.
 *
 * @see Docs     https://vue.chakra-ui.com/icon
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CIcon/CIcon.js
 */

var templateObject = Object.freeze(["\n        flex-shrink: 0;\n        backface-visibility: hidden;\n        &:not(:root) {\n          overflow: hidden;\n        }\n      "]);
var fallbackIcon = internalIcons.internalIcons['question-outline'];
var Svg = {
  name: 'ChakraIconSvg',
  mixins: [utils.createStyledAttrsMixin('ChakraIconSvg')],
  props: iconProps,
  computed: {
    svgClassName: function svgClassName() {
      return css.css(templateObject);
    }
  },
  render: function render(h) {
    return h('svg', {
      class: [this.svgClassName, this.className],
      attrs: this.computedAttrs
    }, this.$slots.default);
  }
};
/**
 * CIcon component
 *
 * CIcon is used for rendering icons.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/icon
 */

var CIcon = {
  name: 'CIcon',
  mixins: [utils.createStyledAttrsMixin('CIcon')],
  inject: ['$chakraIcons'],
  computed: {
    icon: function icon() {
      var icon;

      if (this.name) {
        icon = this.$chakraIcons[this.name];
      } else {
        console.warn('[Chakra]: You need to provide the "name" or "use" prop to for the Icon component');
      }

      if (!icon) {
        icon = fallbackIcon;
      }

      return icon;
    },
    viewBox: function viewBox() {
      return this.icon.viewBox || '0 0 24 24';
    }
  },
  props: iconProps,
  render: function render(h) {
    return h(Svg, {
      class: this.className,
      attrs: Object.assign({}, this.icon.attrs || {}, {
        w: this.size,
        h: this.size,
        color: this.color,
        d: 'inline-block',
        verticalAlign: 'middle',
        viewBox: this.viewBox,
        role: 'presentation',
        focusable: false
      }, this.computedAttrs),
      domProps: {
        innerHTML: this.icon.path
      }
    });
  }
};
exports.CIcon = CIcon;
exports.iconProps = iconProps;

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63);

/** Detect free variable `self`. */

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] || freeSelf || Function('return this')();
/* harmony default export */ __webpack_exports__["a"] = (root);

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var Chakra = __webpack_require__(101);

var utils = __webpack_require__(2);

__webpack_require__(4);

var internalIcons = __webpack_require__(8);

__webpack_require__(25);

__webpack_require__(1);

var Css = __webpack_require__(81);

__webpack_require__(0);

var colorModeObserver = __webpack_require__(3);

var directives = __webpack_require__(80);

__webpack_require__(14);

var CToast = __webpack_require__(82);

var CBox = __webpack_require__(5);

var CIcon = __webpack_require__(9);

var CAlert = __webpack_require__(83);

var CPseudoBox = __webpack_require__(12);

__webpack_require__(16);

var CCloseButton = __webpack_require__(65);

var CThemeProvider = __webpack_require__(84);

var CColorModeProvider = __webpack_require__(85);

var CTransition = __webpack_require__(20);

var CCollapse = __webpack_require__(86);

var CAccordion = __webpack_require__(103);

var CModal = __webpack_require__(66);

var CPortal = __webpack_require__(17);

__webpack_require__(13);

__webpack_require__(6);

var CAlertDialog = __webpack_require__(104);

var CAspectRatioBox = __webpack_require__(105);

__webpack_require__(67);

var CAvatar = __webpack_require__(106);

var CFlex = __webpack_require__(21);

var CAvatarGroup = __webpack_require__(107);

__webpack_require__(57);

var CBadge = __webpack_require__(108);

var CLink = __webpack_require__(87);

var CBreadcrumb = __webpack_require__(109);

var CVisuallyHidden = __webpack_require__(18);

var CSpinner = __webpack_require__(68);

var CButton = __webpack_require__(69);

var CButtonGroup = __webpack_require__(110);

var CControlBox = __webpack_require__(58);

__webpack_require__(70);

var CCheckbox = __webpack_require__(111);

var CCheckboxGroup = __webpack_require__(112);

var CCircularProgress = __webpack_require__(113);

var CCode = __webpack_require__(114);

var CReset = __webpack_require__(115);

var CDivider = __webpack_require__(88);

var CDrawer = __webpack_require__(116);

var CEditable = __webpack_require__(117);

__webpack_require__(59);

var CFormControl = __webpack_require__(118);

var CFormLabel = __webpack_require__(119);

__webpack_require__(22);

var CText = __webpack_require__(26);

var CFormErrorMessage = __webpack_require__(120);

var CFormHelperText = __webpack_require__(121);

var CFragment = __webpack_require__(60);

var CGrid = __webpack_require__(89);

var CHeading = __webpack_require__(122);

var CIconButton = __webpack_require__(123);

var CImage = __webpack_require__(124);

__webpack_require__(15);

var CInput = __webpack_require__(61);

var CInputAddon = __webpack_require__(125);

var CInputElement = __webpack_require__(126);

var CInputGroup = __webpack_require__(127);

var CList = __webpack_require__(128);

var CPopper = __webpack_require__(62);

var CMenu = __webpack_require__(129);

var CNumberInput = __webpack_require__(130);

var CPopover = __webpack_require__(131);

var CProgress = __webpack_require__(132);

var CRadio = __webpack_require__(133);

var CRadioGroup = __webpack_require__(134);

var CRadioButtonGroup = __webpack_require__(135);

var CSimpleGrid = __webpack_require__(136);

var CSelect = __webpack_require__(137);

var CSlider = __webpack_require__(138);

var CStack = __webpack_require__(139);

var CStat = __webpack_require__(140);

var CSwitch = __webpack_require__(141);

var CTabs = __webpack_require__(142);

var CTag = __webpack_require__(143);

var CTextarea = __webpack_require__(144);

var CTooltip = __webpack_require__(145);
/**
 * CMenuItemOption component
 *
 * The menu item option component
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/menu
 */


var CMenuItemOption = {
  name: 'CMenuItemOption',
  inheritAttrs: false,
  inject: ['$MenuContext', '$chakraTheme', '$chakraColorMode'],
  props: {
    type: String,
    isDisabled: Boolean,
    isChecked: Boolean,
    value: [String, Number, Array]
  },
  computed: {
    context: function context() {
      return this.$MenuContext();
    },
    role: function role() {
      return "menuitem" + this.type;
    },
    menuItemStyles: function menuItemStyles() {
      return CMenu.useMenuItemStyle({
        theme: this.theme,
        colorMode: this.colorMode
      });
    },
    theme: function theme() {
      return this.$chakraTheme();
    },
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    }
  },
  methods: {
    /**
     * Handles selection event
     */
    handleSelect: function handleSelect(event) {
      var ref = this.context;
      var closeMenu = ref.closeMenu;
      var closeOnSelect = ref.closeOnSelect;
      this.$emit('click', event);
      closeOnSelect && closeMenu();
    },

    /**
     * Handles click event on menu option
     * @param {Event} event Click event object
     */
    handleClick: function handleClick(event) {
      if (this.isDisabled) {
        event.stopPropagation();
        event.preventDefault();
        return;
      }

      this.handleSelect(event);
    },

    /**
     * Handles keydown events
     * @param {Event} event Keyboard event
     */
    handleKeyDown: function handleKeyDown(event) {
      if (this.isDisabled) {
        return;
      }

      if (['Enter', ' '].includes(event.key)) {
        event.preventDefault();
        this.handleSelect(event);
      }

      this.$emit('keydown', event);
    },

    /**
     * Handles mouseenter event
     * @param {Event} event Mouse event object
     */
    handleMouseEnter: function handleMouseEnter(event) {
      var ref = this.context;
      var focusableItems = ref.focusableItems;
      var focusAtIndex = ref.focusAtIndex;

      if (this.isDisabled) {
        event.stopPropagation();
        event.preventDefault();
        return;
      }

      var nextIndex = focusableItems.indexOf(event.currentTarget);
      focusAtIndex(nextIndex);
      this.$emit('mouseenter', event);
    },

    /**
     * Handles mouseleave event
     * @param {Event} event mouse event object
     */
    handleMouseLeave: function handleMouseLeave(event) {
      var ref = this.context;
      var focusAtIndex = ref.focusAtIndex;
      focusAtIndex(-1);
      this.$emit('mouseleave', event);
    }
  },
  render: function render(h) {
    return h(CPseudoBox.default, {
      props: {
        as: 'button'
      },
      attrs: Object.assign({}, this.menuItemStyles, {
        display: 'flex',
        minHeight: '32px',
        alignItems: 'center'
      }, this.$attrs, {
        role: this.role,
        tabindex: -1,
        'aria-checked': this.isChecked,
        disabled: this.isDisabled,
        'aria-disabled': this.isDisabled,
        'data-chakra-component': 'CMenuItemOption'
      }),
      nativeOn: {
        click: this.handleClick,
        mouseenter: this.handleMouseEnter,
        mouseleave: this.handleMouseLeave,
        keydown: this.handleKeyDown
      }
    }, [h(CIcon.CIcon, {
      props: {
        name: 'check'
      },
      attrs: {
        opacity: this.isChecked ? 1 : 0,
        color: 'currentColor',
        size: '1em',
        ml: '1rem',
        mr: '-4px',
        'aria-hidden': true,
        'data-menuitem-icon': ''
      }
    }), h(CBox.default, {
      props: {
        as: 'span'
      },
      attrs: {
        textAlign: 'left',
        flex: '1',
        mx: '1rem'
      }
    }, this.$slots.default)]);
  }
};
/**
 * CMenuOptionGroup component
 *
 * The menu item option group component
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/menu
 */

var CMenuOptionGroup = {
  name: 'CMenuOptionGroup',
  inheritAttrs: false,
  props: {
    type: {
      type: String,
      default: 'radio'
    },
    name: String,
    title: String,
    value: {
      type: [String, Number, Array],
      default: null
    },
    defaultValue: [String, Number, Array]
  },
  data: function data() {
    return {
      innerValue: this.defaultValue || []
    };
  },
  computed: {
    isControlled: function isControlled() {
      return this.value != null;
    },
    computedValue: {
      get: function get() {
        return this.isControlled ? this.value : this.innerValue;
      },
      set: function set(value) {
        this.innerValue = value;
      }
    },
    fallbackName: function fallbackName() {
      return "radio-" + utils.useId();
    }
  },
  methods: {
    /**
     * Handles change event in menu option group
     * @param {any} value selected value
     */
    handleChange: function handleChange(value) {
      if (this.type === 'radio') {
        if (!this.isControlled) {
          this.computedValue = value;
        }

        this.$emit('change', value);
      }

      if (this.type === 'checkbox') {
        var newValue = this.computedValue.includes(value) ? this.computedValue.filter(function (itemValue) {
          return itemValue !== value;
        }) : this.computedValue.concat([value]);

        if (!this.isControlled) {
          this.computedValue = newValue;
        }

        this.$emit('change', newValue);
      }
    }
  },
  render: function render(h) {
    var this$1 = this; // Check for children nodes

    if (!this.$slots || !this.$slots.default) {
      return h(null);
    } else if (!this.$slots.default.length) {
      return console.error('[Chakra-ui]: <CMenuOptionGroup /> component expects at least one child node.');
    }

    var children = this.$slots.default.filter(function (e) {
      return e.tag;
    });
    var clonedChildNodes = children.map(function (vnode) {
      var result;
      var cloned = utils.cloneVNode(vnode, h);

      if (!cloned.componentOptions) {
        return console.error('Chakra-ui: <CMenuOptionGroup /> component expects valid component as children');
      }

      if (this$1.type === 'radio') {
        result = h(cloned.componentOptions.Ctor, Object.assign({}, cloned.data, {
          props: Object.assign({}, cloned.data.props || {}, cloned.componentOptions.propsData, {
            type: this$1.type,
            name: this$1.name || this$1.fallbackName,
            isChecked: cloned.componentOptions.propsData.value === this$1.computedValue
          }),
          attrs: Object.assign({}, cloned.data.attrs || {}),
          key: cloned.componentOptions.propsData.value,
          nativeOn: {
            click: function click(event) {
              this$1.handleChange(cloned.componentOptions.propsData.value);
            },
            keydown: function keydown(event) {
              if (['Enter', ' '].includes(event.key)) {
                event.preventDefault();
                this$1.handleChange(cloned.componentOptions.propsData.value);
              }
            }
          }
        }), cloned.componentOptions.children);
      }

      if (this$1.type === 'checkbox') {
        result = h(cloned.componentOptions.Ctor, Object.assign({}, cloned.data, {
          props: Object.assign({}, cloned.data.props || {}, cloned.componentOptions.propsData, {
            type: this$1.type,
            isChecked: this$1.computedValue.includes(cloned.componentOptions.propsData.value)
          }),
          attrs: Object.assign({}, cloned.data.attrs || {}),
          key: cloned.componentOptions.propsData.value,
          nativeOn: {
            click: function click(event) {
              this$1.handleChange(cloned.componentOptions.propsData.value);
            },
            keydown: function keydown(event) {
              if (['Enter', ' '].includes(event.key)) {
                event.preventDefault();
                this$1.handleChange(cloned.componentOptions.propsData.value);
              }
            }
          }
        }), cloned.componentOptions.children);
      }

      return result;
    });
    return h(CMenu.CMenuGroup, {
      props: {
        title: this.title
      },
      attrs: Object.assign({}, this.$attrs, {
        'data-chakra-component': 'CMenuOptionGroup'
      })
    }, clonedChildNodes);
  }
};
exports.defaultTheme = Chakra.defaultTheme;
exports.parsePackIcons = utils.parsePackIcons;
exports.internalIcons = internalIcons.internalIcons;
exports.Css = Css.default;
exports.defineColorModeObserver = colorModeObserver.defineColorModeObserver;
exports.localColorModeObserver = colorModeObserver.colorModeObserver;
exports.mode = colorModeObserver.mode;
exports.createClientDirective = directives.createClientDirective;
exports.createServerDirective = directives.createServerDirective;
exports.useToast = CToast.default;
exports.CBox = CBox.default;
exports.CIcon = CIcon.CIcon;
exports.CAlert = CAlert.CAlert;
exports.CAlertDescription = CAlert.CAlertDescription;
exports.CAlertIcon = CAlert.CAlertIcon;
exports.CAlertTitle = CAlert.CAlertTitle;
exports.statuses = CAlert.statuses;
exports.CPseudoBox = CPseudoBox.default;
exports.CCloseButton = CCloseButton.default;
exports.CThemeProvider = CThemeProvider.default;
exports.CColorModeProvider = CColorModeProvider.default;
exports.CDarkMode = CColorModeProvider.CDarkMode;
exports.CLightMode = CColorModeProvider.CLightMode;
exports.CAnimateHeight = CTransition.CAnimateHeight;
exports.CFade = CTransition.CFade;
exports.CRevealHeight = CTransition.CRevealHeight;
exports.CScale = CTransition.CScale;
exports.CSlide = CTransition.CSlide;
exports.CSlideIn = CTransition.CSlideIn;
exports.CCollapse = CCollapse.default;
exports.CAccordion = CAccordion.CAccordion;
exports.CAccordionHeader = CAccordion.CAccordionHeader;
exports.CAccordionIcon = CAccordion.CAccordionIcon;
exports.CAccordionItem = CAccordion.CAccordionItem;
exports.CAccordionPanel = CAccordion.CAccordionPanel;
exports.CModal = CModal.CModal;
exports.CModalBody = CModal.CModalBody;
exports.CModalCloseButton = CModal.CModalCloseButton;
exports.CModalContent = CModal.CModalContent;
exports.CModalFooter = CModal.CModalFooter;
exports.CModalHeader = CModal.CModalHeader;
exports.CModalOverlay = CModal.CModalOverlay;
exports.CPortal = CPortal.default;
exports.CAlertDialog = CAlertDialog.CAlertDialog;
exports.CAlertDialogBody = CAlertDialog.CAlertDialogBody;
exports.CAlertDialogCloseButton = CAlertDialog.CAlertDialogCloseButton;
exports.CAlertDialogContent = CAlertDialog.CAlertDialogContent;
exports.CAlertDialogFooter = CAlertDialog.CAlertDialogFooter;
exports.CAlertDialogHeader = CAlertDialog.CAlertDialogHeader;
exports.CAlertDialogOverlay = CAlertDialog.CAlertDialogOverlay;
exports.CAspectRatioBox = CAspectRatioBox.default;
exports.CAvatar = CAvatar.CAvatar;
exports.CAvatarBadge = CAvatar.CAvatarBadge;
exports.CFlex = CFlex.CFlex;
exports.CAvatarGroup = CAvatarGroup.default;
exports.CBadge = CBadge.default;
exports.CLink = CLink.default;
exports.CBreadcrumb = CBreadcrumb.CBreadcrumb;
exports.CBreadcrumbItem = CBreadcrumb.CBreadcrumbItem;
exports.CBreadcrumbLink = CBreadcrumb.CBreadcrumbLink;
exports.CBreadcrumbSeparator = CBreadcrumb.CBreadcrumbSeparator;
exports.CVisuallyHidden = CVisuallyHidden.default;
exports.CSpinner = CSpinner.default;
exports.CButton = CButton.CButton;
exports.CButtonGroup = CButtonGroup.default;
exports.CControlBox = CControlBox.default;
exports.CCheckbox = CCheckbox.default;
exports.CCheckboxGroup = CCheckboxGroup.default;
exports.CCircularProgress = CCircularProgress.CCircularProgress;
exports.CCircularProgressLabel = CCircularProgress.CCircularProgressLabel;
exports.CCode = CCode.default;
exports.CReset = CReset.default;
exports.CDivider = CDivider.default;
exports.CDrawer = CDrawer.CDrawer;
exports.CDrawerBody = CDrawer.CDrawerBody;
exports.CDrawerCloseButton = CDrawer.CDrawerCloseButton;
exports.CDrawerContent = CDrawer.CDrawerContent;
exports.CDrawerFooter = CDrawer.CDrawerFooter;
exports.CDrawerHeader = CDrawer.CDrawerHeader;
exports.CDrawerOverlay = CDrawer.CDrawerOverlay;
exports.CEditable = CEditable.default;
exports.CEditableInput = CEditable.CEditableInput;
exports.CEditablePreview = CEditable.CEditablePreview;
exports.CFormControl = CFormControl.default;
exports.CFormLabel = CFormLabel.default;
exports.CText = CText.default;
exports.CFormErrorMessage = CFormErrorMessage.default;
exports.CFormHelperText = CFormHelperText.default;
exports.CFragment = CFragment.default;
exports.CGrid = CGrid.CGrid;
exports.CGridItem = CGrid.CGridItem;
exports.CHeading = CHeading.default;
exports.CIconButton = CIconButton.default;
exports.CImage = CImage.default;
exports.CInput = CInput.CInput;
exports.CInputAddon = CInputAddon.default;
exports.CInputLeftAddon = CInputAddon.CInputLeftAddon;
exports.CInputRightAddon = CInputAddon.CInputRightAddon;
exports.CInputElement = CInputElement.default;
exports.CInputLeftElement = CInputElement.CInputLeftElement;
exports.CInputRightElement = CInputElement.CInputRightElement;
exports.CInputGroup = CInputGroup.default;
exports.CList = CList.default;
exports.CListIcon = CList.CListIcon;
exports.CListItem = CList.CListItem;
exports.CPopper = CPopper.CPopper;
exports.CPopperArrow = CPopper.CPopperArrow;
exports.CMenu = CMenu.CMenu;
exports.CMenuButton = CMenu.CMenuButton;
exports.CMenuDivider = CMenu.CMenuDivider;
exports.CMenuGroup = CMenu.CMenuGroup;
exports.CMenuItem = CMenu.CMenuItem;
exports.CMenuList = CMenu.CMenuList;
exports.CNumberDecrementStepper = CNumberInput.CNumberDecrementStepper;
exports.CNumberIncrementStepper = CNumberInput.CNumberIncrementStepper;
exports.CNumberInput = CNumberInput.CNumberInput;
exports.CNumberInputField = CNumberInput.CNumberInputField;
exports.CNumberInputStepper = CNumberInput.CNumberInputStepper;
exports.CPopover = CPopover.CPopover;
exports.CPopoverArrow = CPopover.CPopoverArrow;
exports.CPopoverBody = CPopover.CPopoverBody;
exports.CPopoverCloseButton = CPopover.CPopoverCloseButton;
exports.CPopoverContent = CPopover.CPopoverContent;
exports.CPopoverFooter = CPopover.CPopoverFooter;
exports.CPopoverHeader = CPopover.CPopoverHeader;
exports.CPopoverTrigger = CPopover.CPopoverTrigger;
exports.CProgress = CProgress.CProgress;
exports.CProgressLabel = CProgress.CProgressLabel;
exports.CRadio = CRadio.default;
exports.CRadioGroup = CRadioGroup.default;
exports.CRadioButtonGroup = CRadioButtonGroup.default;
exports.CSimpleGrid = CSimpleGrid.default;
exports.CSelect = CSelect.default;
exports.CSlider = CSlider.default;
exports.CSliderFilledTrack = CSlider.CSliderFilledTrack;
exports.CSliderThumb = CSlider.CSliderThumb;
exports.CSliderTrack = CSlider.CSliderTrack;
exports.CStack = CStack.default;
exports.CStat = CStat.CStat;
exports.CStatArrow = CStat.CStatArrow;
exports.CStatGroup = CStat.CStatGroup;
exports.CStatHelperText = CStat.CStatHelperText;
exports.CStatLabel = CStat.CStatLabel;
exports.CStatNumber = CStat.CStatNumber;
exports.CSwitch = CSwitch.default;
exports.CTab = CTabs.CTab;
exports.CTabList = CTabs.CTabList;
exports.CTabPanel = CTabs.CTabPanel;
exports.CTabPanels = CTabs.CTabPanels;
exports.CTabs = CTabs.CTabs;
exports.CTag = CTag.CTag;
exports.CTagCloseButton = CTag.CTagCloseButton;
exports.CTagIcon = CTag.CTagIcon;
exports.CTagLabel = CTag.CTagLabel;
exports.CTextarea = CTextarea.default;
exports.CTooltip = CTooltip.default;
exports.CMenuItemOption = CMenuItemOption;
exports.CMenuOptionGroup = CMenuOptionGroup;
exports.default = Chakra.Chakra;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);
/**
 * Hey! Welcome to @chakra-ui/vue PseudoBox
 *
 * The PseudoBox component
 *
 * @see Docs     https://vue.chakra-ui.com/pseudobox
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CPseudoBox/CPseudoBox.js
 */

/**
 * CPseudoBox component
 *
 * The pseudobox component that accepts pseudo props
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/pseudobox
 */


var CPseudoBox = {
  name: 'CPseudoBox',
  mixins: [utils.createStyledAttrsMixin('CPseudoBox')],
  props: {
    as: {
      type: [String, Object],
      default: function _default() {
        return 'div';
      }
    },
    to: [String, Object]
  },
  render: function render(h) {
    return h(this.as, {
      props: {
        to: this.to
      },
      class: this.className,
      on: this.listeners$,
      attrs: this.computedAttrs
    }, this.$slots.default);
  }
};
exports.default = CPseudoBox;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * Hey! Welcome to @chakra-ui/vue NoSsr
 *
 * This component is used to defer the rendering of it's children to the client-side.
 *
 * This component is a modification of the fine work of @egoist
 * @see https://github.com/egoist/vue-client-only/blob/master/src/index.js
 */

var NoSsr = {
  name: 'NoSsr',
  functional: true,
  props: {
    placeholder: String,
    placeholderTag: {
      type: String,
      default: 'div'
    }
  },
  render: function render(h, ref) {
    var parent = ref.parent;
    var slots = ref.slots;
    var props = ref.props;
    var ref$1 = slots();
    var defaultSlot = ref$1.default;
    if (defaultSlot === void 0) defaultSlot = [];
    var placeholderSlot = ref$1.placeholder;

    if (parent._isMounted) {
      return defaultSlot;
    }

    parent.$once('hook:mounted', function () {
      parent.$forceUpdate();
    });

    if (props.placeholderTag && (props.placeholder || placeholderSlot)) {
      return h(props.placeholderTag, {
        class: ['client-only-placeholder'],
        attrs: {
          'data-chakra-component': 'CNoSsr'
        }
      }, props.placeholder || placeholderSlot);
    } // Return a placeholder element for each child in the default slot
    // Or if no children return a single placeholder


    return defaultSlot.length > 0 ? defaultSlot.map(function () {
      return h(false);
    }) : h(false);
  }
};
exports.default = NoSsr;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */

/*
 * anime.js v3.1.0
 * (c) 2019 Julian Garnier
 * Released under the MIT license
 * animejs.com
 */
// Defaults

__webpack_require__(102);

__webpack_require__(28);

__webpack_require__(29);

__webpack_require__(30);

__webpack_require__(31);

__webpack_require__(32);

__webpack_require__(33);

__webpack_require__(34);

__webpack_require__(35);

__webpack_require__(36);

__webpack_require__(37);

__webpack_require__(38);

__webpack_require__(39);

__webpack_require__(40);

var defaultInstanceSettings = {
  update: null,
  begin: null,
  loopBegin: null,
  changeBegin: null,
  change: null,
  changeComplete: null,
  loopComplete: null,
  complete: null,
  loop: 1,
  direction: 'normal',
  autoplay: true,
  timelineOffset: 0
};
var defaultTweenSettings = {
  duration: 1000,
  delay: 0,
  endDelay: 0,
  easing: 'easeOutElastic(1, .5)',
  round: 0
};
var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective']; // Caching

var cache = {
  CSS: {},
  springs: {}
}; // Utils

function minMax(val, min, max) {
  return Math.min(Math.max(val, min), max);
}

function stringContains(str, text) {
  return str.indexOf(text) > -1;
}

function applyArguments(func, args) {
  return func.apply(null, args);
}

var is = {
  arr: function (a) {
    return Array.isArray(a);
  },
  obj: function (a) {
    return stringContains(Object.prototype.toString.call(a), 'Object');
  },
  pth: function (a) {
    return is.obj(a) && a.hasOwnProperty('totalLength');
  },
  svg: function (a) {
    return a instanceof SVGElement;
  },
  inp: function (a) {
    return a instanceof HTMLInputElement;
  },
  dom: function (a) {
    return a.nodeType || is.svg(a);
  },
  str: function (a) {
    return typeof a === 'string';
  },
  fnc: function (a) {
    return typeof a === 'function';
  },
  und: function (a) {
    return typeof a === 'undefined';
  },
  hex: function (a) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a);
  },
  rgb: function (a) {
    return /^rgb/.test(a);
  },
  hsl: function (a) {
    return /^hsl/.test(a);
  },
  col: function (a) {
    return is.hex(a) || is.rgb(a) || is.hsl(a);
  },
  key: function (a) {
    return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes';
  }
}; // Easings

function parseEasingParameters(string) {
  var match = /\(([^)]+)\)/.exec(string);
  return match ? match[1].split(',').map(function (p) {
    return parseFloat(p);
  }) : [];
} // Spring solver inspired by Webkit Copyright © 2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js


function spring(string, duration) {
  var params = parseEasingParameters(string);
  var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
  var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
  var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
  var velocity = minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;

  function solver(t) {
    var progress = duration ? duration * t / 1000 : t;

    if (zeta < 1) {
      progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
    } else {
      progress = (a + b * progress) * Math.exp(-progress * w0);
    }

    if (t === 0 || t === 1) {
      return t;
    }

    return 1 - progress;
  }

  function getDuration() {
    var cached = cache.springs[string];

    if (cached) {
      return cached;
    }

    var frame = 1 / 6;
    var elapsed = 0;
    var rest = 0;

    while (true) {
      elapsed += frame;

      if (solver(elapsed) === 1) {
        rest++;

        if (rest >= 16) {
          break;
        }
      } else {
        rest = 0;
      }
    }

    var duration = elapsed * frame * 1000;
    cache.springs[string] = duration;
    return duration;
  }

  return duration ? solver : getDuration;
} // Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function


function steps(steps) {
  if (steps === void 0) {
    steps = 10;
  }

  return function (t) {
    return Math.round(t * steps) * (1 / steps);
  };
} // BezierEasing https://github.com/gre/bezier-easing


var bezier = function () {
  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  function C(aA1) {
    return 3.0 * aA1;
  }

  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX,
        currentT,
        i = 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;

      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > 0.0000001 && ++i < 10);

    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < 4; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }

  function bezier(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
      return;
    }

    var sampleValues = new Float32Array(kSplineTableSize);

    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function getTForX(aX) {
      var intervalStart = 0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample;
      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= 0.001) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    }

    return function (x) {
      if (mX1 === mY1 && mX2 === mY2) {
        return x;
      }

      if (x === 0 || x === 1) {
        return x;
      }

      return calcBezier(getTForX(x), mY1, mY2);
    };
  }

  return bezier;
}();

var penner = function () {
  // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)
  var eases = {
    linear: function () {
      return function (t) {
        return t;
      };
    }
  };
  var functionEasings = {
    Sine: function () {
      return function (t) {
        return 1 - Math.cos(t * Math.PI / 2);
      };
    },
    Circ: function () {
      return function (t) {
        return 1 - Math.sqrt(1 - t * t);
      };
    },
    Back: function () {
      return function (t) {
        return t * t * (3 * t - 2);
      };
    },
    Bounce: function () {
      return function (t) {
        var pow2,
            b = 4;

        while (t < ((pow2 = Math.pow(2, --b)) - 1) / 11) {}

        return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
      };
    },
    Elastic: function (amplitude, period) {
      if (amplitude === void 0) {
        amplitude = 1;
      }

      if (period === void 0) {
        period = .5;
      }

      var a = minMax(amplitude, 1, 10);
      var p = minMax(period, .1, 2);
      return function (t) {
        return t === 0 || t === 1 ? t : -a * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p);
      };
    }
  };
  var baseEasings = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];
  baseEasings.forEach(function (name, i) {
    functionEasings[name] = function () {
      return function (t) {
        return Math.pow(t, i + 2);
      };
    };
  });
  Object.keys(functionEasings).forEach(function (name) {
    var easeIn = functionEasings[name];
    eases['easeIn' + name] = easeIn;

    eases['easeOut' + name] = function (a, b) {
      return function (t) {
        return 1 - easeIn(a, b)(1 - t);
      };
    };

    eases['easeInOut' + name] = function (a, b) {
      return function (t) {
        return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 1 - easeIn(a, b)(t * -2 + 2) / 2;
      };
    };
  });
  return eases;
}();

function parseEasings(easing, duration) {
  if (is.fnc(easing)) {
    return easing;
  }

  var name = easing.split('(')[0];
  var ease = penner[name];
  var args = parseEasingParameters(easing);

  switch (name) {
    case 'spring':
      return spring(easing, duration);

    case 'cubicBezier':
      return applyArguments(bezier, args);

    case 'steps':
      return applyArguments(steps, args);

    default:
      return applyArguments(ease, args);
  }
} // Strings


function selectString(str) {
  try {
    var nodes = document.querySelectorAll(str);
    return nodes;
  } catch (e) {
    return;
  }
} // Arrays


function filterArray(arr, callback) {
  var len = arr.length;
  var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
  var result = [];

  for (var i = 0; i < len; i++) {
    if (i in arr) {
      var val = arr[i];

      if (callback.call(thisArg, val, i, arr)) {
        result.push(val);
      }
    }
  }

  return result;
}

function flattenArray(arr) {
  return arr.reduce(function (a, b) {
    return a.concat(is.arr(b) ? flattenArray(b) : b);
  }, []);
}

function toArray(o) {
  if (is.arr(o)) {
    return o;
  }

  if (is.str(o)) {
    o = selectString(o) || o;
  }

  if (o instanceof NodeList || o instanceof HTMLCollection) {
    return [].slice.call(o);
  }

  return [o];
}

function arrayContains(arr, val) {
  return arr.some(function (a) {
    return a === val;
  });
} // Objects


function cloneObject(o) {
  var clone = {};

  for (var p in o) {
    clone[p] = o[p];
  }

  return clone;
}

function replaceObjectProps(o1, o2) {
  var o = cloneObject(o1);

  for (var p in o1) {
    o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p];
  }

  return o;
}

function mergeObjects(o1, o2) {
  var o = cloneObject(o1);

  for (var p in o2) {
    o[p] = is.und(o1[p]) ? o2[p] : o1[p];
  }

  return o;
} // Colors


function rgbToRgba(rgbValue) {
  var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
  return rgb ? "rgba(" + rgb[1] + ",1)" : rgbValue;
}

function hexToRgba(hexValue) {
  var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  var hex = hexValue.replace(rgx, function (m, r, g, b) {
    return r + r + g + g + b + b;
  });
  var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  var r = parseInt(rgb[1], 16);
  var g = parseInt(rgb[2], 16);
  var b = parseInt(rgb[3], 16);
  return "rgba(" + r + "," + g + "," + b + ",1)";
}

function hslToRgba(hslValue) {
  var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
  var h = parseInt(hsl[1], 10) / 360;
  var s = parseInt(hsl[2], 10) / 100;
  var l = parseInt(hsl[3], 10) / 100;
  var a = hsl[4] || 1;

  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }

    if (t > 1) {
      t -= 1;
    }

    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }

    if (t < 1 / 2) {
      return q;
    }

    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }

    return p;
  }

  var r, g, b;

  if (s == 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }

  return "rgba(" + r * 255 + "," + g * 255 + "," + b * 255 + "," + a + ")";
}

function colorToRgb(val) {
  if (is.rgb(val)) {
    return rgbToRgba(val);
  }

  if (is.hex(val)) {
    return hexToRgba(val);
  }

  if (is.hsl(val)) {
    return hslToRgba(val);
  }
} // Units


function getUnit(val) {
  var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);

  if (split) {
    return split[1];
  }
}

function getTransformUnit(propName) {
  if (stringContains(propName, 'translate') || propName === 'perspective') {
    return 'px';
  }

  if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) {
    return 'deg';
  }
} // Values


function getFunctionValue(val, animatable) {
  if (!is.fnc(val)) {
    return val;
  }

  return val(animatable.target, animatable.id, animatable.total);
}

function getAttribute(el, prop) {
  return el.getAttribute(prop);
}

function convertPxToUnit(el, value, unit) {
  var valueUnit = getUnit(value);

  if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) {
    return value;
  }

  var cached = cache.CSS[value + unit];

  if (!is.und(cached)) {
    return cached;
  }

  var baseline = 100;
  var tempEl = document.createElement(el.tagName);
  var parentEl = el.parentNode && el.parentNode !== document ? el.parentNode : document.body;
  parentEl.appendChild(tempEl);
  tempEl.style.position = 'absolute';
  tempEl.style.width = baseline + unit;
  var factor = baseline / tempEl.offsetWidth;
  parentEl.removeChild(tempEl);
  var convertedUnit = factor * parseFloat(value);
  cache.CSS[value + unit] = convertedUnit;
  return convertedUnit;
}

function getCSSValue(el, prop, unit) {
  if (prop in el.style) {
    var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
    return unit ? convertPxToUnit(el, value, unit) : value;
  }
}

function getAnimationType(el, prop) {
  if (is.dom(el) && !is.inp(el) && (getAttribute(el, prop) || is.svg(el) && el[prop])) {
    return 'attribute';
  }

  if (is.dom(el) && arrayContains(validTransforms, prop)) {
    return 'transform';
  }

  if (is.dom(el) && prop !== 'transform' && getCSSValue(el, prop)) {
    return 'css';
  }

  if (el[prop] != null) {
    return 'object';
  }
}

function getElementTransforms(el) {
  if (!is.dom(el)) {
    return;
  }

  var str = el.style.transform || '';
  var reg = /(\w+)\(([^)]*)\)/g;
  var transforms = new Map();
  var m;

  while (m = reg.exec(str)) {
    transforms.set(m[1], m[2]);
  }

  return transforms;
}

function getTransformValue(el, propName, animatable, unit) {
  var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
  var value = getElementTransforms(el).get(propName) || defaultVal;

  if (animatable) {
    animatable.transforms.list.set(propName, value);
    animatable.transforms['last'] = propName;
  }

  return unit ? convertPxToUnit(el, value, unit) : value;
}

function getOriginalTargetValue(target, propName, unit, animatable) {
  switch (getAnimationType(target, propName)) {
    case 'transform':
      return getTransformValue(target, propName, animatable, unit);

    case 'css':
      return getCSSValue(target, propName, unit);

    case 'attribute':
      return getAttribute(target, propName);

    default:
      return target[propName] || 0;
  }
}

function getRelativeValue(to, from) {
  var operator = /^(\*=|\+=|-=)/.exec(to);

  if (!operator) {
    return to;
  }

  var u = getUnit(to) || 0;
  var x = parseFloat(from);
  var y = parseFloat(to.replace(operator[0], ''));

  switch (operator[0][0]) {
    case '+':
      return x + y + u;

    case '-':
      return x - y + u;

    case '*':
      return x * y + u;
  }
}

function validateValue(val, unit) {
  if (is.col(val)) {
    return colorToRgb(val);
  }

  if (/\s/g.test(val)) {
    return val;
  }

  var originalUnit = getUnit(val);
  var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;

  if (unit) {
    return unitLess + unit;
  }

  return unitLess;
} // getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744


function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function getCircleLength(el) {
  return Math.PI * 2 * getAttribute(el, 'r');
}

function getRectLength(el) {
  return getAttribute(el, 'width') * 2 + getAttribute(el, 'height') * 2;
}

function getLineLength(el) {
  return getDistance({
    x: getAttribute(el, 'x1'),
    y: getAttribute(el, 'y1')
  }, {
    x: getAttribute(el, 'x2'),
    y: getAttribute(el, 'y2')
  });
}

function getPolylineLength(el) {
  var points = el.points;
  var totalLength = 0;
  var previousPos;

  for (var i = 0; i < points.numberOfItems; i++) {
    var currentPos = points.getItem(i);

    if (i > 0) {
      totalLength += getDistance(previousPos, currentPos);
    }

    previousPos = currentPos;
  }

  return totalLength;
}

function getPolygonLength(el) {
  var points = el.points;
  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
} // Path animation


function getTotalLength(el) {
  if (el.getTotalLength) {
    return el.getTotalLength();
  }

  switch (el.tagName.toLowerCase()) {
    case 'circle':
      return getCircleLength(el);

    case 'rect':
      return getRectLength(el);

    case 'line':
      return getLineLength(el);

    case 'polyline':
      return getPolylineLength(el);

    case 'polygon':
      return getPolygonLength(el);
  }
}

function setDashoffset(el) {
  var pathLength = getTotalLength(el);
  el.setAttribute('stroke-dasharray', pathLength);
  return pathLength;
} // Motion path


function getParentSvgEl(el) {
  var parentEl = el.parentNode;

  while (is.svg(parentEl)) {
    if (!is.svg(parentEl.parentNode)) {
      break;
    }

    parentEl = parentEl.parentNode;
  }

  return parentEl;
}

function getParentSvg(pathEl, svgData) {
  var svg = svgData || {};
  var parentSvgEl = svg.el || getParentSvgEl(pathEl);
  var rect = parentSvgEl.getBoundingClientRect();
  var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
  var width = rect.width;
  var height = rect.height;
  var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);
  return {
    el: parentSvgEl,
    viewBox: viewBox,
    x: viewBox[0] / 1,
    y: viewBox[1] / 1,
    w: width / viewBox[2],
    h: height / viewBox[3]
  };
}

function getPath(path, percent) {
  var pathEl = is.str(path) ? selectString(path)[0] : path;
  var p = percent || 100;
  return function (property) {
    return {
      property: property,
      el: pathEl,
      svg: getParentSvg(pathEl),
      totalLength: getTotalLength(pathEl) * (p / 100)
    };
  };
}

function getPathProgress(path, progress) {
  function point(offset) {
    if (offset === void 0) {
      offset = 0;
    }

    var l = progress + offset >= 1 ? progress + offset : 0;
    return path.el.getPointAtLength(l);
  }

  var svg = getParentSvg(path.el, path.svg);
  var p = point();
  var p0 = point(-1);
  var p1 = point(+1);

  switch (path.property) {
    case 'x':
      return (p.x - svg.x) * svg.w;

    case 'y':
      return (p.y - svg.y) * svg.h;

    case 'angle':
      return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
  }
} // Decompose value


function decomposeValue(val, unit) {
  // const rgx = /-?\d*\.?\d+/g; // handles basic numbers
  // const rgx = /[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
  var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation

  var value = validateValue(is.pth(val) ? val.totalLength : val, unit) + '';
  return {
    original: value,
    numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],
    strings: is.str(val) || unit ? value.split(rgx) : []
  };
} // Animatables


function parseTargets(targets) {
  var targetsArray = targets ? flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets)) : [];
  return filterArray(targetsArray, function (item, pos, self) {
    return self.indexOf(item) === pos;
  });
}

function getAnimatables(targets) {
  var parsed = parseTargets(targets);
  return parsed.map(function (t, i) {
    return {
      target: t,
      id: i,
      total: parsed.length,
      transforms: {
        list: getElementTransforms(t)
      }
    };
  });
} // Properties


function normalizePropertyTweens(prop, tweenSettings) {
  var settings = cloneObject(tweenSettings); // Override duration if easing is a spring

  if (/^spring/.test(settings.easing)) {
    settings.duration = spring(settings.easing);
  }

  if (is.arr(prop)) {
    var l = prop.length;
    var isFromTo = l === 2 && !is.obj(prop[0]);

    if (!isFromTo) {
      // Duration divided by the number of tweens
      if (!is.fnc(tweenSettings.duration)) {
        settings.duration = tweenSettings.duration / l;
      }
    } else {
      // Transform [from, to] values shorthand to a valid tween value
      prop = {
        value: prop
      };
    }
  }

  var propArray = is.arr(prop) ? prop : [prop];
  return propArray.map(function (v, i) {
    var obj = is.obj(v) && !is.pth(v) ? v : {
      value: v
    }; // Default delay value should only be applied to the first tween

    if (is.und(obj.delay)) {
      obj.delay = !i ? tweenSettings.delay : 0;
    } // Default endDelay value should only be applied to the last tween


    if (is.und(obj.endDelay)) {
      obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0;
    }

    return obj;
  }).map(function (k) {
    return mergeObjects(k, settings);
  });
}

function flattenKeyframes(keyframes) {
  var propertyNames = filterArray(flattenArray(keyframes.map(function (key) {
    return Object.keys(key);
  })), function (p) {
    return is.key(p);
  }).reduce(function (a, b) {
    if (a.indexOf(b) < 0) {
      a.push(b);
    }

    return a;
  }, []);
  var properties = {};

  var loop = function (i) {
    var propName = propertyNames[i];
    properties[propName] = keyframes.map(function (key) {
      var newKey = {};

      for (var p in key) {
        if (is.key(p)) {
          if (p == propName) {
            newKey.value = key[p];
          }
        } else {
          newKey[p] = key[p];
        }
      }

      return newKey;
    });
  };

  for (var i = 0; i < propertyNames.length; i++) {
    loop(i);
  }

  return properties;
}

function getProperties(tweenSettings, params) {
  var properties = [];
  var keyframes = params.keyframes;

  if (keyframes) {
    params = mergeObjects(flattenKeyframes(keyframes), params);
  }

  for (var p in params) {
    if (is.key(p)) {
      properties.push({
        name: p,
        tweens: normalizePropertyTweens(params[p], tweenSettings)
      });
    }
  }

  return properties;
} // Tweens


function normalizeTweenValues(tween, animatable) {
  var t = {};

  for (var p in tween) {
    var value = getFunctionValue(tween[p], animatable);

    if (is.arr(value)) {
      value = value.map(function (v) {
        return getFunctionValue(v, animatable);
      });

      if (value.length === 1) {
        value = value[0];
      }
    }

    t[p] = value;
  }

  t.duration = parseFloat(t.duration);
  t.delay = parseFloat(t.delay);
  return t;
}

function normalizeTweens(prop, animatable) {
  var previousTween;
  return prop.tweens.map(function (t) {
    var tween = normalizeTweenValues(t, animatable);
    var tweenValue = tween.value;
    var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
    var toUnit = getUnit(to);
    var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
    var previousValue = previousTween ? previousTween.to.original : originalValue;
    var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
    var fromUnit = getUnit(from) || getUnit(originalValue);
    var unit = toUnit || fromUnit;

    if (is.und(to)) {
      to = previousValue;
    }

    tween.from = decomposeValue(from, unit);
    tween.to = decomposeValue(getRelativeValue(to, from), unit);
    tween.start = previousTween ? previousTween.end : 0;
    tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
    tween.easing = parseEasings(tween.easing, tween.duration);
    tween.isPath = is.pth(tweenValue);
    tween.isColor = is.col(tween.from.original);

    if (tween.isColor) {
      tween.round = 1;
    }

    previousTween = tween;
    return tween;
  });
} // Tween progress


var setProgressValue = {
  css: function (t, p, v) {
    return t.style[p] = v;
  },
  attribute: function (t, p, v) {
    return t.setAttribute(p, v);
  },
  object: function (t, p, v) {
    return t[p] = v;
  },
  transform: function (t, p, v, transforms, manual) {
    transforms.list.set(p, v);

    if (p === transforms.last || manual) {
      var str = '';
      transforms.list.forEach(function (value, prop) {
        str += prop + "(" + value + ") ";
      });
      t.style.transform = str;
    }
  }
}; // Set Value helper

function setTargetsValue(targets, properties) {
  var animatables = getAnimatables(targets);
  animatables.forEach(function (animatable) {
    for (var property in properties) {
      var value = getFunctionValue(properties[property], animatable);
      var target = animatable.target;
      var valueUnit = getUnit(value);
      var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
      var unit = valueUnit || getUnit(originalValue);
      var to = getRelativeValue(validateValue(value, unit), originalValue);
      var animType = getAnimationType(target, property);
      setProgressValue[animType](target, property, to, animatable.transforms, true);
    }
  });
} // Animations


function createAnimation(animatable, prop) {
  var animType = getAnimationType(animatable.target, prop.name);

  if (animType) {
    var tweens = normalizeTweens(prop, animatable);
    var lastTween = tweens[tweens.length - 1];
    return {
      type: animType,
      property: prop.name,
      animatable: animatable,
      tweens: tweens,
      duration: lastTween.end,
      delay: tweens[0].delay,
      endDelay: lastTween.endDelay
    };
  }
}

function getAnimations(animatables, properties) {
  return filterArray(flattenArray(animatables.map(function (animatable) {
    return properties.map(function (prop) {
      return createAnimation(animatable, prop);
    });
  })), function (a) {
    return !is.und(a);
  });
} // Create Instance


function getInstanceTimings(animations, tweenSettings) {
  var animLength = animations.length;

  var getTlOffset = function (anim) {
    return anim.timelineOffset ? anim.timelineOffset : 0;
  };

  var timings = {};
  timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) {
    return getTlOffset(anim) + anim.duration;
  })) : tweenSettings.duration;
  timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) {
    return getTlOffset(anim) + anim.delay;
  })) : tweenSettings.delay;
  timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) {
    return getTlOffset(anim) + anim.duration - anim.endDelay;
  })) : tweenSettings.endDelay;
  return timings;
}

var instanceID = 0;

function createNewInstance(params) {
  var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
  var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
  var properties = getProperties(tweenSettings, params);
  var animatables = getAnimatables(params.targets);
  var animations = getAnimations(animatables, properties);
  var timings = getInstanceTimings(animations, tweenSettings);
  var id = instanceID;
  instanceID++;
  return mergeObjects(instanceSettings, {
    id: id,
    children: [],
    animatables: animatables,
    animations: animations,
    duration: timings.duration,
    delay: timings.delay,
    endDelay: timings.endDelay
  });
} // Core


var activeInstances = [];
var pausedInstances = [];
var raf;

var engine = function () {
  function play() {
    raf = requestAnimationFrame(step);
  }

  function step(t) {
    var activeInstancesLength = activeInstances.length;

    if (activeInstancesLength) {
      var i = 0;

      while (i < activeInstancesLength) {
        var activeInstance = activeInstances[i];

        if (!activeInstance.paused) {
          activeInstance.tick(t);
        } else {
          var instanceIndex = activeInstances.indexOf(activeInstance);

          if (instanceIndex > -1) {
            activeInstances.splice(instanceIndex, 1);
            activeInstancesLength = activeInstances.length;
          }
        }

        i++;
      }

      play();
    } else {
      raf = cancelAnimationFrame(raf);
    }
  }

  return play;
}();

function handleVisibilityChange() {
  if (document.hidden) {
    activeInstances.forEach(function (ins) {
      return ins.pause();
    });
    pausedInstances = activeInstances.slice(0);
    anime.running = activeInstances = [];
  } else {
    pausedInstances.forEach(function (ins) {
      return ins.play();
    });
  }
}

if (typeof document !== 'undefined') {
  document.addEventListener('visibilitychange', handleVisibilityChange);
} // Public Instance


function anime(params) {
  if (params === void 0) {
    params = {};
  }

  var startTime = 0,
      lastTime = 0,
      now = 0;
  var children,
      childrenLength = 0;
  var resolve = null;

  function makePromise(instance) {
    var promise = window.Promise && new Promise(function (_resolve) {
      return resolve = _resolve;
    });
    instance.finished = promise;
    return promise;
  }

  var instance = createNewInstance(params);
  var promise = makePromise(instance);

  function toggleInstanceDirection() {
    var direction = instance.direction;

    if (direction !== 'alternate') {
      instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
    }

    instance.reversed = !instance.reversed;
    children.forEach(function (child) {
      return child.reversed = instance.reversed;
    });
  }

  function adjustTime(time) {
    return instance.reversed ? instance.duration - time : time;
  }

  function resetTime() {
    startTime = 0;
    lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
  }

  function seekChild(time, child) {
    if (child) {
      child.seek(time - child.timelineOffset);
    }
  }

  function syncInstanceChildren(time) {
    if (!instance.reversePlayback) {
      for (var i = 0; i < childrenLength; i++) {
        seekChild(time, children[i]);
      }
    } else {
      for (var i$1 = childrenLength; i$1--;) {
        seekChild(time, children[i$1]);
      }
    }
  }

  function setAnimationsProgress(insTime) {
    var i = 0;
    var animations = instance.animations;
    var animationsLength = animations.length;

    while (i < animationsLength) {
      var anim = animations[i];
      var animatable = anim.animatable;
      var tweens = anim.tweens;
      var tweenLength = tweens.length - 1;
      var tween = tweens[tweenLength]; // Only check for keyframes if there is more than one tween

      if (tweenLength) {
        tween = filterArray(tweens, function (t) {
          return insTime < t.end;
        })[0] || tween;
      }

      var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
      var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
      var strings = tween.to.strings;
      var round = tween.round;
      var numbers = [];
      var toNumbersLength = tween.to.numbers.length;
      var progress = void 0;

      for (var n = 0; n < toNumbersLength; n++) {
        var value = void 0;
        var toNumber = tween.to.numbers[n];
        var fromNumber = tween.from.numbers[n] || 0;

        if (!tween.isPath) {
          value = fromNumber + eased * (toNumber - fromNumber);
        } else {
          value = getPathProgress(tween.value, eased * toNumber);
        }

        if (round) {
          if (!(tween.isColor && n > 2)) {
            value = Math.round(value * round) / round;
          }
        }

        numbers.push(value);
      } // Manual Array.reduce for better performances


      var stringsLength = strings.length;

      if (!stringsLength) {
        progress = numbers[0];
      } else {
        progress = strings[0];

        for (var s = 0; s < stringsLength; s++) {
          var a = strings[s];
          var b = strings[s + 1];
          var n$1 = numbers[s];

          if (!isNaN(n$1)) {
            if (!b) {
              progress += n$1 + ' ';
            } else {
              progress += n$1 + b;
            }
          }
        }
      }

      setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
      anim.currentValue = progress;
      i++;
    }
  }

  function setCallback(cb) {
    if (instance[cb] && !instance.passThrough) {
      instance[cb](instance);
    }
  }

  function countIteration() {
    if (instance.remaining && instance.remaining !== true) {
      instance.remaining--;
    }
  }

  function setInstanceProgress(engineTime) {
    var insDuration = instance.duration;
    var insDelay = instance.delay;
    var insEndDelay = insDuration - instance.endDelay;
    var insTime = adjustTime(engineTime);
    instance.progress = minMax(insTime / insDuration * 100, 0, 100);
    instance.reversePlayback = insTime < instance.currentTime;

    if (children) {
      syncInstanceChildren(insTime);
    }

    if (!instance.began && instance.currentTime > 0) {
      instance.began = true;
      setCallback('begin');
    }

    if (!instance.loopBegan && instance.currentTime > 0) {
      instance.loopBegan = true;
      setCallback('loopBegin');
    }

    if (insTime <= insDelay && instance.currentTime !== 0) {
      setAnimationsProgress(0);
    }

    if (insTime >= insEndDelay && instance.currentTime !== insDuration || !insDuration) {
      setAnimationsProgress(insDuration);
    }

    if (insTime > insDelay && insTime < insEndDelay) {
      if (!instance.changeBegan) {
        instance.changeBegan = true;
        instance.changeCompleted = false;
        setCallback('changeBegin');
      }

      setCallback('change');
      setAnimationsProgress(insTime);
    } else {
      if (instance.changeBegan) {
        instance.changeCompleted = true;
        instance.changeBegan = false;
        setCallback('changeComplete');
      }
    }

    instance.currentTime = minMax(insTime, 0, insDuration);

    if (instance.began) {
      setCallback('update');
    }

    if (engineTime >= insDuration) {
      lastTime = 0;
      countIteration();

      if (!instance.remaining) {
        instance.paused = true;

        if (!instance.completed) {
          instance.completed = true;
          setCallback('loopComplete');
          setCallback('complete');

          if (!instance.passThrough && 'Promise' in window) {
            resolve();
            promise = makePromise(instance);
          }
        }
      } else {
        startTime = now;
        setCallback('loopComplete');
        instance.loopBegan = false;

        if (instance.direction === 'alternate') {
          toggleInstanceDirection();
        }
      }
    }
  }

  instance.reset = function () {
    var direction = instance.direction;
    instance.passThrough = false;
    instance.currentTime = 0;
    instance.progress = 0;
    instance.paused = true;
    instance.began = false;
    instance.loopBegan = false;
    instance.changeBegan = false;
    instance.completed = false;
    instance.changeCompleted = false;
    instance.reversePlayback = false;
    instance.reversed = direction === 'reverse';
    instance.remaining = instance.loop;
    children = instance.children;
    childrenLength = children.length;

    for (var i = childrenLength; i--;) {
      instance.children[i].reset();
    }

    if (instance.reversed && instance.loop !== true || direction === 'alternate' && instance.loop === 1) {
      instance.remaining++;
    }

    setAnimationsProgress(instance.reversed ? instance.duration : 0);
  }; // Set Value helper


  instance.set = function (targets, properties) {
    setTargetsValue(targets, properties);
    return instance;
  };

  instance.tick = function (t) {
    now = t;

    if (!startTime) {
      startTime = now;
    }

    setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
  };

  instance.seek = function (time) {
    setInstanceProgress(adjustTime(time));
  };

  instance.pause = function () {
    instance.paused = true;
    resetTime();
  };

  instance.play = function () {
    if (!instance.paused) {
      return;
    }

    if (instance.completed) {
      instance.reset();
    }

    instance.paused = false;
    activeInstances.push(instance);
    resetTime();

    if (!raf) {
      engine();
    }
  };

  instance.reverse = function () {
    toggleInstanceDirection();
    resetTime();
  };

  instance.restart = function () {
    instance.reset();
    instance.play();
  };

  instance.reset();

  if (instance.autoplay) {
    instance.play();
  }

  return instance;
} // Remove targets from animation


function removeTargetsFromAnimations(targetsArray, animations) {
  for (var a = animations.length; a--;) {
    if (arrayContains(targetsArray, animations[a].animatable.target)) {
      animations.splice(a, 1);
    }
  }
}

function removeTargets(targets) {
  var targetsArray = parseTargets(targets);

  for (var i = activeInstances.length; i--;) {
    var instance = activeInstances[i];
    var animations = instance.animations;
    var children = instance.children;
    removeTargetsFromAnimations(targetsArray, animations);

    for (var c = children.length; c--;) {
      var child = children[c];
      var childAnimations = child.animations;
      removeTargetsFromAnimations(targetsArray, childAnimations);

      if (!childAnimations.length && !child.children.length) {
        children.splice(c, 1);
      }
    }

    if (!animations.length && !children.length) {
      instance.pause();
    }
  }
} // Stagger helpers


function stagger(val, params) {
  if (params === void 0) {
    params = {};
  }

  var direction = params.direction || 'normal';
  var easing = params.easing ? parseEasings(params.easing) : null;
  var grid = params.grid;
  var axis = params.axis;
  var fromIndex = params.from || 0;
  var fromFirst = fromIndex === 'first';
  var fromCenter = fromIndex === 'center';
  var fromLast = fromIndex === 'last';
  var isRange = is.arr(val);
  var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
  var val2 = isRange ? parseFloat(val[1]) : 0;
  var unit = getUnit(isRange ? val[1] : val) || 0;
  var start = params.start || 0 + (isRange ? val1 : 0);
  var values = [];
  var maxValue = 0;
  return function (el, i, t) {
    if (fromFirst) {
      fromIndex = 0;
    }

    if (fromCenter) {
      fromIndex = (t - 1) / 2;
    }

    if (fromLast) {
      fromIndex = t - 1;
    }

    if (!values.length) {
      for (var index = 0; index < t; index++) {
        if (!grid) {
          values.push(Math.abs(fromIndex - index));
        } else {
          var fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;
          var fromY = !fromCenter ? Math.floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;
          var toX = index % grid[0];
          var toY = Math.floor(index / grid[0]);
          var distanceX = fromX - toX;
          var distanceY = fromY - toY;
          var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

          if (axis === 'x') {
            value = -distanceX;
          }

          if (axis === 'y') {
            value = -distanceY;
          }

          values.push(value);
        }

        maxValue = Math.max.apply(Math, values);
      }

      if (easing) {
        values = values.map(function (val) {
          return easing(val / maxValue) * maxValue;
        });
      }

      if (direction === 'reverse') {
        values = values.map(function (val) {
          return axis ? val < 0 ? val * -1 : -val : Math.abs(maxValue - val);
        });
      }
    }

    var spacing = isRange ? (val2 - val1) / maxValue : val1;
    return start + spacing * (Math.round(values[i] * 100) / 100) + unit;
  };
} // Timeline


function timeline(params) {
  if (params === void 0) {
    params = {};
  }

  var tl = anime(params);
  tl.duration = 0;

  tl.add = function (instanceParams, timelineOffset) {
    var tlIndex = activeInstances.indexOf(tl);
    var children = tl.children;

    if (tlIndex > -1) {
      activeInstances.splice(tlIndex, 1);
    }

    function passThrough(ins) {
      ins.passThrough = true;
    }

    for (var i = 0; i < children.length; i++) {
      passThrough(children[i]);
    }

    var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
    insParams.targets = insParams.targets || params.targets;
    var tlDuration = tl.duration;
    insParams.autoplay = false;
    insParams.direction = tl.direction;
    insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
    passThrough(tl);
    tl.seek(insParams.timelineOffset);
    var ins = anime(insParams);
    passThrough(ins);
    children.push(ins);
    var timings = getInstanceTimings(children, params);
    tl.delay = timings.delay;
    tl.endDelay = timings.endDelay;
    tl.duration = timings.duration;
    tl.seek(0);
    tl.reset();

    if (tl.autoplay) {
      tl.play();
    }

    return tl;
  };

  return tl;
}

anime.version = '3.1.0';
anime.speed = 1;
anime.running = activeInstances;
anime.remove = removeTargets;
anime.get = getOriginalTargetValue;
anime.set = setTargetsValue;
anime.convertPx = convertPxToUnit;
anime.path = getPath;
anime.setDashoffset = setDashoffset;
anime.stagger = stagger;
anime.timeline = timeline;
anime.easing = parseEasings;
anime.penner = penner;

anime.random = function (min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

exports.anime = anime;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


var utils = __webpack_require__(2);

var outlinedStyle = function outlinedStyle(ref) {
  var theme = ref.theme;
  var colorMode = ref.colorMode;
  var focusBorderColor = ref.focusBorderColor;
  var errorBorderColor = ref.errorBorderColor;
  var bg = {
    light: 'white',
    dark: 'whiteAlpha.100'
  };
  var borderColor = {
    light: 'inherit',
    dark: 'whiteAlpha.50'
  };
  var hoverColor = {
    light: 'gray.300',
    dark: 'whiteAlpha.200'
  };
  /**
   * styled-system's get takes 3 args
   * - object or array to read from
   * - key to get
   * - fallback value
   */

  var _focusBorderColor = utils.__get(theme.colors, focusBorderColor, focusBorderColor // If color doesn't exist in theme, use it's raw value
  );

  var _errorBorderColor = utils.__get(theme.colors, errorBorderColor, errorBorderColor);

  return Object.assign({}, readOnly, {
    borderWidth: '1px',
    borderColor: borderColor[colorMode],
    bg: bg[colorMode],
    _hover: {
      borderColor: hoverColor[colorMode]
    },
    _disabled: {
      opacity: '0.4',
      cursor: 'not-allowed'
    },
    _focus: {
      zIndex: 1,
      borderColor: _focusBorderColor,
      boxShadow: "0 0 0 1px " + _focusBorderColor
    },
    _invalid: {
      borderColor: _errorBorderColor,
      boxShadow: "0 0 0 1px " + _errorBorderColor
    }
  });
};

var readOnly = {
  _readOnly: {
    bg: 'transparent',
    boxShadow: 'none !important',
    userSelect: 'all'
  }
};

var filledStyle = function filledStyle(ref) {
  var theme = ref.theme;
  var focusBorderColor = ref.focusBorderColor;
  var errorBorderColor = ref.errorBorderColor;
  var colorMode = ref.colorMode;
  var bg = {
    light: 'gray.100',
    dark: 'whiteAlpha.50'
  };
  var hoverColor = {
    light: 'gray.200',
    dark: 'whiteAlpha.100'
  };

  var _focusBorderColor = utils.__get(theme.colors, focusBorderColor, focusBorderColor);

  var _errorBorderColor = utils.__get(theme.colors, errorBorderColor, errorBorderColor);

  return Object.assign({}, readOnly, {
    border: '2px',
    borderColor: 'transparent',
    bg: bg[colorMode],
    _hover: {
      bg: hoverColor[colorMode]
    },
    _disabled: {
      opacity: '0.4',
      cursor: 'not-allowed'
    },
    _focus: {
      zIndex: 1,
      bg: 'transparent',
      borderColor: _focusBorderColor
    },
    _invalid: {
      borderColor: _errorBorderColor
    }
  });
};

var flushedStyle = function flushedStyle(ref) {
  var theme = ref.theme;
  var focusBorderColor = ref.focusBorderColor;
  var errorBorderColor = ref.errorBorderColor;

  var _focusBorderColor = utils.__get(theme.colors, focusBorderColor, focusBorderColor);

  var _errorBorderColor = utils.__get(theme.colors, errorBorderColor, errorBorderColor);

  return Object.assign({}, readOnly, {
    borderBottom: '2px',
    borderColor: 'inherit',
    rounded: 0,
    px: undefined,
    bg: 'transparent',
    _focus: {
      zIndex: 1,
      borderColor: _focusBorderColor
    },
    _invalid: {
      borderColor: _errorBorderColor
    }
  });
};

var unstyledStyle = {
  bg: 'transparent',
  px: undefined,
  height: undefined
};

var variantProps = function variantProps(props) {
  switch (props.variant) {
    case 'flushed':
      return flushedStyle(props);

    case 'unstyled':
      return unstyledStyle;

    case 'filled':
      return filledStyle(props);

    case 'outline':
      return outlinedStyle(props);

    default:
      return {};
  }
};

var baseStyles = {
  display: 'flex',
  alignItems: 'center',
  position: 'relative',
  transition: 'all 0.2s',
  outline: 'none',
  appearance: 'none'
};
var inputSizes = {
  lg: {
    fontSize: 'lg',
    px: 4,
    height: 12,
    lineHeight: '3rem',
    rounded: 'md'
  },
  md: {
    fontSize: 'md',
    px: 4,
    height: 10,
    lineHeight: '2.5rem',
    rounded: 'md'
  },
  sm: {
    fontSize: 'sm',
    px: 3,
    height: 8,
    lineHeight: '2rem',
    rounded: 'sm'
  }
};

var sizeProps = function sizeProps(props) {
  return inputSizes[props.size];
};

var useInputStyle = function useInputStyle(props) {
  return Object.assign({}, {
    width: props.isFullWidth ? '100%' : undefined
  }, baseStyles, sizeProps(props), variantProps(props));
};

exports.inputSizes = inputSizes;
exports.useInputStyle = useInputStyle;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


var closeButtonProps = {
  size: {
    type: String,
    default: 'md',
    validator: function validator(value) {
      return value.match(/^(sm|md|lg)$/);
    }
  },
  isDisabled: {
    type: Boolean,
    default: false
  },
  ariaLabel: {
    type: String,
    default: 'Close'
  }
};
var baseProps = {
  display: 'inline-flex',
  alignItems: 'center',
  justifyContent: 'center',
  rounded: 'md',
  transition: 'all 0.2s',
  flex: '0 0 auto',
  _hover: {
    bg: 'blackAlpha.100'
  },
  _active: {
    bg: 'blackAlpha.200'
  },
  _disabled: {
    cursor: 'not-allowed'
  },
  _focus: {
    boxShadow: 'outline'
  },
  border: 'none',
  bg: 'blackAlpha.50'
};
var sizes = {
  lg: {
    button: '40px',
    icon: '16px'
  },
  md: {
    button: '32px',
    icon: '12px'
  },
  sm: {
    button: '24px',
    icon: '10px'
  }
};
exports.baseProps = baseProps;
exports.closeButtonProps = closeButtonProps;
exports.sizes = sizes;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

var Vue = _interopDefault(__webpack_require__(0));

__webpack_require__(3);

var CNoSsr = __webpack_require__(13);

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") {
    return Array.from(iter);
  }
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var inBrowser = typeof window !== 'undefined';

function freeze(item) {
  if (Array.isArray(item) || _typeof(item) === 'object') {
    return Object.freeze(item);
  }

  return item;
}

function combinePassengers(transports) {
  var slotProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return transports.reduce(function (passengers, transport) {
    var temp = transport.passengers[0];
    var newPassengers = typeof temp === 'function' ? temp(slotProps) : transport.passengers;
    return passengers.concat(newPassengers);
  }, []);
}

function stableSort(array, compareFn) {
  return array.map(function (v, idx) {
    return [idx, v];
  }).sort(function (a, b) {
    return compareFn(a[1], b[1]) || a[0] - b[0];
  }).map(function (c) {
    return c[1];
  });
}

function pick(obj, keys) {
  return keys.reduce(function (acc, key) {
    if (obj.hasOwnProperty(key)) {
      acc[key] = obj[key];
    }

    return acc;
  }, {});
}

var transports = {};
var targets = {};
var sources = {};
var Wormhole = Vue.extend({
  data: function data() {
    return {
      transports: transports,
      targets: targets,
      sources: sources,
      trackInstances: inBrowser
    };
  },
  methods: {
    open: function open(transport) {
      if (!inBrowser) {
        return;
      }

      var to = transport.to,
          from = transport.from,
          passengers = transport.passengers,
          _transport$order = transport.order,
          order = _transport$order === void 0 ? Infinity : _transport$order;

      if (!to || !from || !passengers) {
        return;
      }

      var newTransport = {
        to: to,
        from: from,
        passengers: freeze(passengers),
        order: order
      };
      var keys = Object.keys(this.transports);

      if (keys.indexOf(to) === -1) {
        Vue.set(this.transports, to, []);
      }

      var currentIndex = this.$_getTransportIndex(newTransport); // Copying the array here so that the PortalTarget change event will actually contain two distinct arrays

      var newTransports = this.transports[to].slice(0);

      if (currentIndex === -1) {
        newTransports.push(newTransport);
      } else {
        newTransports[currentIndex] = newTransport;
      }

      this.transports[to] = stableSort(newTransports, function (a, b) {
        return a.order - b.order;
      });
    },
    close: function close(transport) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var to = transport.to,
          from = transport.from;

      if (!to || !from && force === false) {
        return;
      }

      if (!this.transports[to]) {
        return;
      }

      if (force) {
        this.transports[to] = [];
      } else {
        var index = this.$_getTransportIndex(transport);

        if (index >= 0) {
          // Copying the array here so that the PortalTarget change event will actually contain two distinct arrays
          var newTransports = this.transports[to].slice(0);
          newTransports.splice(index, 1);
          this.transports[to] = newTransports;
        }
      }
    },
    registerTarget: function registerTarget(target, vm, force) {
      if (!inBrowser) {
        return;
      }

      if (this.trackInstances && !force && this.targets[target]) {
        console.warn("[portal-vue]: Target ".concat(target, " already exists"));
      }

      this.$set(this.targets, target, Object.freeze([vm]));
    },
    unregisterTarget: function unregisterTarget(target) {
      this.$delete(this.targets, target);
    },
    registerSource: function registerSource(source, vm, force) {
      if (!inBrowser) {
        return;
      }

      if (this.trackInstances && !force && this.sources[source]) {
        console.warn("[portal-vue]: source ".concat(source, " already exists"));
      }

      this.$set(this.sources, source, Object.freeze([vm]));
    },
    unregisterSource: function unregisterSource(source) {
      this.$delete(this.sources, source);
    },
    hasTarget: function hasTarget(to) {
      return !!(this.targets[to] && this.targets[to][0]);
    },
    hasSource: function hasSource(to) {
      return !!(this.sources[to] && this.sources[to][0]);
    },
    hasContentFor: function hasContentFor(to) {
      return !!this.transports[to] && !!this.transports[to].length;
    },
    // Internal
    $_getTransportIndex: function $_getTransportIndex(_ref) {
      var to = _ref.to,
          from = _ref.from;

      for (var i in this.transports[to]) {
        if (this.transports[to][i].from === from) {
          return +i;
        }
      }

      return -1;
    }
  }
});
var wormhole = new Wormhole(transports);
var _id = 1;
var Portal = Vue.extend({
  name: 'portal',
  props: {
    disabled: {
      type: Boolean
    },
    name: {
      type: String,
      default: function _default() {
        return String(_id++);
      }
    },
    order: {
      type: Number,
      default: 0
    },
    slim: {
      type: Boolean
    },
    slotProps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    tag: {
      type: String,
      default: 'DIV'
    },
    to: {
      type: String,
      default: function _default() {
        return String(Math.round(Math.random() * 10000000));
      }
    }
  },
  created: function created() {
    var _this = this;

    this.$nextTick(function () {
      wormhole.registerSource(_this.name, _this);
    });
  },
  mounted: function mounted() {
    if (!this.disabled) {
      this.sendUpdate();
    }
  },
  updated: function updated() {
    if (this.disabled) {
      this.clear();
    } else {
      this.sendUpdate();
    }
  },
  beforeDestroy: function beforeDestroy() {
    wormhole.unregisterSource(this.name);
    this.clear();
  },
  watch: {
    to: function to(newValue, oldValue) {
      oldValue && oldValue !== newValue && this.clear(oldValue);
      this.sendUpdate();
    }
  },
  methods: {
    clear: function clear(target) {
      var closer = {
        from: this.name,
        to: target || this.to
      };
      wormhole.close(closer);
    },
    normalizeSlots: function normalizeSlots() {
      return this.$scopedSlots.default ? [this.$scopedSlots.default] : this.$slots.default;
    },
    normalizeOwnChildren: function normalizeOwnChildren(children) {
      return typeof children === 'function' ? children(this.slotProps) : children;
    },
    sendUpdate: function sendUpdate() {
      var slotContent = this.normalizeSlots();

      if (slotContent) {
        var transport = {
          from: this.name,
          to: this.to,
          passengers: _toConsumableArray(slotContent),
          order: this.order
        };
        wormhole.open(transport);
      } else {
        this.clear();
      }
    }
  },
  render: function render(h) {
    var children = this.$slots.default || this.$scopedSlots.default || [];
    var Tag = this.tag;

    if (children && this.disabled) {
      return children.length <= 1 && this.slim ? this.normalizeOwnChildren(children)[0] : h(Tag, [this.normalizeOwnChildren(children)]);
    } else {
      return this.slim ? h() : h(Tag, {
        class: {
          'v-portal': true
        },
        style: {
          display: 'none'
        },
        key: 'v-portal-placeholder'
      });
    }
  }
});
var PortalTarget = Vue.extend({
  name: 'portalTarget',
  props: {
    multiple: {
      type: Boolean,
      default: false
    },
    name: {
      type: String,
      required: true
    },
    slim: {
      type: Boolean,
      default: false
    },
    slotProps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    tag: {
      type: String,
      default: 'div'
    },
    transition: {
      type: [String, Object, Function]
    }
  },
  data: function data() {
    return {
      transports: wormhole.transports,
      firstRender: true
    };
  },
  created: function created() {
    var _this = this;

    this.$nextTick(function () {
      wormhole.registerTarget(_this.name, _this);
    });
  },
  watch: {
    ownTransports: function ownTransports() {
      this.$emit('change', this.children().length > 0);
    },
    name: function name(newVal, oldVal) {
      /**
       * TODO
       * This should warn as well ...
       */
      wormhole.unregisterTarget(oldVal);
      wormhole.registerTarget(newVal, this);
    }
  },
  mounted: function mounted() {
    var _this2 = this;

    if (this.transition) {
      this.$nextTick(function () {
        // only when we have a transition, because it causes a re-render
        _this2.firstRender = false;
      });
    }
  },
  beforeDestroy: function beforeDestroy() {
    wormhole.unregisterTarget(this.name);
  },
  computed: {
    ownTransports: function ownTransports() {
      var transports = this.transports[this.name] || [];

      if (this.multiple) {
        return transports;
      }

      return transports.length === 0 ? [] : [transports[transports.length - 1]];
    },
    passengers: function passengers() {
      return combinePassengers(this.ownTransports, this.slotProps);
    }
  },
  methods: {
    // can't be a computed prop because it has to "react" to $slot changes.
    children: function children() {
      return this.passengers.length !== 0 ? this.passengers : this.$scopedSlots.default ? this.$scopedSlots.default(this.slotProps) : this.$slots.default || [];
    },
    // can't be a computed prop because it has to "react" to this.children().
    noWrapper: function noWrapper() {
      var noWrapper = this.slim && !this.transition;

      if (noWrapper && this.children().length > 1) {
        console.warn('[portal-vue]: PortalTarget with `slim` option received more than one child element.');
      }

      return noWrapper;
    }
  },
  render: function render(h) {
    var noWrapper = this.noWrapper();
    var children = this.children();
    var Tag = this.transition || this.tag;
    return noWrapper ? children[0] : this.slim && !Tag ? h() : h(Tag, {
      props: {
        // if we have a transition component, pass the tag if it exists
        tag: this.transition && this.tag ? this.tag : undefined
      },
      class: {
        'vue-portal-target': true
      }
    }, children);
  }
});
var _id$1 = 0;
var portalProps = ['disabled', 'name', 'order', 'slim', 'slotProps', 'tag', 'to'];
var targetProps = ['multiple', 'transition'];
var MountingPortal = Vue.extend({
  name: 'MountingPortal',
  inheritAttrs: false,
  props: {
    append: {
      type: [Boolean, String]
    },
    bail: {
      type: Boolean
    },
    mountTo: {
      type: String,
      required: true
    },
    // Portal
    disabled: {
      type: Boolean
    },
    // name for the portal
    name: {
      type: String,
      default: function _default() {
        return 'mounted_' + String(_id$1++);
      }
    },
    order: {
      type: Number,
      default: 0
    },
    slim: {
      type: Boolean
    },
    slotProps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    tag: {
      type: String,
      default: 'DIV'
    },
    // name for the target
    to: {
      type: String,
      default: function _default() {
        return String(Math.round(Math.random() * 10000000));
      }
    },
    // Target
    multiple: {
      type: Boolean,
      default: false
    },
    targetSlim: {
      type: Boolean
    },
    targetSlotProps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    targetTag: {
      type: String,
      default: 'div'
    },
    transition: {
      type: [String, Object, Function]
    }
  },
  created: function created() {
    if (typeof document === 'undefined') {
      return;
    }

    var el = document.querySelector(this.mountTo);

    if (!el) {
      console.error("[portal-vue]: Mount Point '".concat(this.mountTo, "' not found in document"));
      return;
    }

    var props = this.$props; // Target already exists

    if (wormhole.targets[props.name]) {
      if (props.bail) {
        console.warn("[portal-vue]: Target ".concat(props.name, " is already mounted.\n        Aborting because 'bail: true' is set"));
      } else {
        this.portalTarget = wormhole.targets[props.name];
      }

      return;
    }

    var append = props.append;

    if (append) {
      var type = typeof append === 'string' ? append : 'DIV';
      var mountEl = document.createElement(type);
      el.appendChild(mountEl);
      el = mountEl;
    } // get props for target from $props
    // we have to rename a few of them


    var _props = pick(this.$props, targetProps);

    _props.slim = this.targetSlim;
    _props.tag = this.targetTag;
    _props.slotProps = this.targetSlotProps;
    _props.name = this.to;
    this.portalTarget = new PortalTarget({
      el: el,
      parent: this.$parent || this,
      propsData: _props
    });
  },
  beforeDestroy: function beforeDestroy() {
    var target = this.portalTarget;

    if (this.append) {
      var el = target.$el;
      el.parentNode.removeChild(el);
    }

    target.$destroy();
  },
  render: function render(h) {
    if (!this.portalTarget) {
      console.warn("[portal-vue] Target wasn't mounted");
      return h();
    } // if there's no "manual" scoped slot, so we create a <Portal> ourselves


    if (!this.$scopedSlots.manual) {
      var props = pick(this.$props, portalProps);
      return h(Portal, {
        props: props,
        attrs: this.$attrs,
        on: this.$listeners,
        scopedSlots: this.$scopedSlots
      }, this.$slots.default);
    } // else, we render the scoped slot


    var content = this.$scopedSlots.manual({
      to: this.to
    }); // if user used <template> for the scoped slot
    // content will be an array

    if (Array.isArray(content)) {
      content = content[0];
    }

    if (!content) {
      return h();
    }

    return content;
  }
});
/**
 * Hey! Welcome to @chakra-ui/vue Portal
 *
 * The Portal component is an internal utility component used
 * to create portals in the browser
 */

/**
 * CPortal component
 *
 * The portal component
 *
 * @extends MountingPortal
 * @see PortalVue https://portal-vue.linusb.org/api/mounting-portal.html
 */

var CPortal = {
  name: 'CPortal',
  props: {
    target: String,
    append: Boolean,
    unmountOnDestroy: Boolean,
    disabled: Boolean,
    name: String,
    order: Number,
    slim: Boolean,
    bail: Boolean,
    targetSlim: Boolean,
    as: {
      type: String,
      default: 'span'
    }
  },
  data: function data() {
    return {
      portalTarget: undefined,
      targetId: undefined
    };
  },
  created: function created() {
    var this$1 = this;

    if (!this.disabled) {
      this.mountTarget();
      this.unmountOnDestroy && this.$once('hook:destroyed', function () {
        utils.canUseDOM && document.body.removeChild(this$1.portalTarget);
      });
    }
  },
  methods: {
    /**
     * @description Creates portal target node. If node doesn't exist, it is created and returned
     * @param {String} target
     * @returns {HTMLElement}
     */
    createPortalTarget: function createPortalTarget(target, tag) {
      if (!utils.canUseDOM) {
        return;
      }

      var existingPortalElement = document.querySelector(target);

      if (existingPortalElement) {
        return existingPortalElement;
      } else {
        var el = document.createElement(tag);

        if (target.startsWith('#')) {
          el.id = utils.getSubstringAfterChar(target, '#');
        }

        if (target.startsWith('.')) {
          el.classList.add(utils.getSubstringAfterChar(target, '.'));
          el.id = utils.useId(4);
        }

        if (document.body != null) {
          document.body.appendChild(el);
        }

        return el;
      }
    },
    mountTarget: function mountTarget() {
      var this$1 = this;

      if (!utils.canUseDOM) {
        return;
      }

      this.portalTarget = this.createPortalTarget(this.target, this.as);
      this.targetId = this.portalTarget.id;
      this.$forceUpdate(); // Force re-render in case of changes.

      if (this.portalTarget && this.portalTarget.isConnected) {
        this.$nextTick(function () {
          this$1.$emit('portal:targetConnected');
        });
      }
    },
    unmountTarget: function unmountTarget() {
      if (!this.disabled) {
        utils.canUseDOM && this.portalTarget.isConnected && document.body.removeChild(this.portalTarget);
      }
    }
  },
  render: function render(h) {
    var children = this.$slots.default;
    return !this.disabled ? h(CNoSsr.default, [h(MountingPortal, {
      props: {
        append: this.append,
        mountTo: "#" + this.targetId,
        disabled: this.disabled,
        name: this.name,
        order: this.order,
        slim: this.slim,
        bail: this.bail,
        targetSlim: this.targetSlim
      },
      attrs: {
        'data-chakra-component': 'CPortal'
      }
    }, children)]) : children[0];
  }
};
exports.default = CPortal;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var css = __webpack_require__(1);
/**
 * Hey! Welcome to @chakra-ui/vue VisuallyHidden
 *
 * This component is used to visually hide elements that have custom
 * appearance. For example, see the CControlBox.
 *
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CVisuallyHidden/CVisuallyHidden.js
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * CVisuallyHidden component
 *
 * the visually hidden wrapper element
 */


var CVisuallyHidden = {
  name: 'CVisuallyHidden',
  functional: true,
  props: {
    as: {
      type: String,
      default: 'div'
    }
  },
  render: function render(h, ref) {
    var props = ref.props;
    var data = ref.data;
    var slots = ref.slots;
    var listeners = ref.listeners;
    var rest$1 = objectWithoutProperties(ref, ["props", "data", "slots", "listeners"]);
    var attrs = data.attrs;
    var domProps = data.domProps;
    var on = data.on;
    var className = css.css({
      border: '0px',
      clip: 'rect(0px, 0px, 0px, 0px)',
      height: "" + (attrs && attrs.w || '1px'),
      width: "" + (attrs && attrs.h || '1px'),
      margin: '-1px',
      padding: '0px',
      overflow: 'hidden',
      whiteSpace: 'nowrap',
      position: "" + (attrs && attrs.pos || 'absolute')
    });
    return h(props.as, {
      class: [className],
      attrs: Object.assign({}, attrs || {}, {
        'data-chakra-component': 'CVisuallyHidden'
      }),
      domProps: domProps,
      on: Object.assign({}, listeners, on)
    }, slots().default);
  }
};
exports.default = CVisuallyHidden;

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent(
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */,
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options =
    typeof scriptExports === 'function' ? scriptExports.options : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) {
    // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
          injectStyles.call(
            this,
            (options.functional ? this.parent : this).$root.$options.shadowRoot
          )
        }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var anime_es = __webpack_require__(14);

var enterEasing = 'spring(1, 100, 50, 0)';
var leaveEasing = 'spring(1, 100, 70, 0)';
var CSlide = {
  name: 'CSlide',
  props: {
    initialHeight: {
      type: Number,
      default: 0
    },
    duration: {
      type: Number,
      default: 150
    },
    enterEasing: {
      type: String,
      default: enterEasing
    },
    leaveEasing: {
      type: String,
      default: leaveEasing
    },
    finalHeight: Number,
    animateOpacity: {
      type: Boolean,
      default: true
    },
    from: {
      type: String,
      default: 'bottom'
    }
  },
  data: function data() {
    return {
      transitionOptions: {
        bottom: {
          offset: '-100%',
          transform: 'translateY'
        },
        top: {
          offset: '100%',
          transform: 'translateY'
        },
        left: {
          offset: '100%',
          transform: 'translateX'
        },
        right: {
          offset: '-100%',
          transform: 'translateX'
        }
      }
    };
  },
  computed: {
    transform: function transform() {
      return this.transitionOptions[this.from].transform;
    },
    transitions: function transitions() {
      var obj, obj$1;
      return {
        enter: (obj = {}, obj[this.transform] = ['0%', this.transitionOptions[this.from].offset], obj.opacity = [0, 1], obj),
        leave: (obj$1 = {}, obj$1[this.transform] = [this.transitionOptions[this.from].offset, '0%'], obj$1.opacity = 0, obj$1)
      };
    }
  },
  methods: {
    enter: function enter(el, complete) {
      anime_es.anime(Object.assign({}, {
        targets: el
      }, this.transitions.enter, {
        complete: complete,
        easing: this.enterEasing
      }));
    },
    leave: function leave(el, complete) {
      anime_es.anime(Object.assign({}, {
        targets: el
      }, this.transitions.leave, {
        complete: complete,
        easing: this.leaveEasing
      }));
    }
  },
  render: function render(h) {
    if (utils.isUndef(this.from)) {
      console.error('[Chakra]: The Slide component expected prop "from" but none was passed.');
      return function () {
        return null;
      };
    }

    var children = this.$slots.default;
    var TransitionElement = children.length > 1 ? 'TransitionGroup' : 'Transition';
    return h(TransitionElement, {
      props: {
        css: false
      },
      on: {
        beforeEnter: function beforeEnter(el) {
          el && el.style.setProperty('will-change', 'opacity, transform');
        },
        enter: this.enter,
        leave: this.enter
      }
    }, this.$slots.default);
  }
};
var CScale = {
  name: 'CScale',
  props: {
    initialHeight: {
      type: Number,
      default: 0
    },
    duration: {
      type: Number,
      default: 150
    },
    enterEasing: {
      type: String,
      default: enterEasing
    },
    leaveEasing: {
      type: String,
      default: leaveEasing
    },
    finalHeight: Number,
    animateOpacity: {
      type: Boolean,
      default: true
    }
  },
  methods: {
    enter: function enter(el, complete) {
      anime_es.anime({
        targets: el,
        opacity: [0, 1],
        scale: [this.initialScale, 1],
        easing: this.enterEasing,
        duration: this.duration,
        complete: complete
      });
    },
    leave: function leave(el, complete) {
      anime_es.anime({
        targets: el,
        opacity: [1, 0],
        scale: [1, this.initialScale],
        easing: this.leaveEasing,
        duration: this.duration,
        complete: complete
      });
    }
  },
  render: function render(h) {
    var finalChildren;
    var children = this.$slots.default || [h(null)];

    if (children.length > 1) {
      var clean = utils.cleanChildren(children);
      finalChildren = clean.map(function (vnode, index) {
        return utils.cloneVNodeElement(vnode, {
          key: "scale-" + index
        }, h);
      });
    } else {
      finalChildren = children;
    }

    var TransitionElement = finalChildren.length > 1 ? 'TransitionGroup' : 'Transition';
    return h(TransitionElement, {
      props: {
        css: false
      },
      on: {
        beforeEnter: function beforeEnter(el) {
          el && el.style.setProperty('will-change', 'opacity, transform');
        },
        enter: this.enter,
        leave: this.leave
      }
    }, finalChildren);
  }
};
var CFade = {
  name: 'CFade',
  props: {
    initialHeight: {
      type: Number,
      default: 0
    },
    duration: {
      type: Number,
      default: 150
    },
    enterEasing: {
      type: String,
      default: enterEasing
    },
    leaveEasing: {
      type: String,
      default: leaveEasing
    },
    finalHeight: Number,
    animateOpacity: {
      type: Boolean,
      default: true
    }
  },
  methods: {
    enter: function enter(el, complete) {
      anime_es.anime({
        targets: el,
        opacity: [0, 1],
        easing: this.enterEasing,
        duration: this.duration,
        complete: complete
      });
    },
    leave: function leave(el, complete) {
      anime_es.anime({
        targets: el,
        opacity: [1, 0],
        easing: this.leaveEasing,
        duration: this.duration,
        complete: complete
      });
    }
  },
  render: function render(h) {
    var finalChildren;
    var children = this.$slots.default || [h(null)];

    if (children.length > 1) {
      var clean = utils.cleanChildren(children);
      finalChildren = clean.map(function (vnode, index) {
        return utils.cloneVNodeElement(vnode, {
          key: "scale-" + index
        }, h);
      });
    } else {
      finalChildren = children;
    }

    var TransitionElement = finalChildren.length > 1 ? 'TransitionGroup' : 'Transition';
    return h(TransitionElement, {
      props: {
        css: false
      },
      on: {
        beforeEnter: function beforeEnter(el) {
          el && el.style.setProperty('will-change', 'opacity, transform');
        },
        enter: this.enter,
        leave: this.leave
      }
    }, finalChildren);
  }
};
var CSlideIn = {
  name: 'CSlideIn',
  props: {
    offset: {
      type: String,
      default: '10px'
    },
    duration: {
      type: Number,
      default: 150
    }
  },
  methods: {
    enter: function enter(el, complete) {
      anime_es.anime({
        targets: el,
        opacity: [0, 1],
        translateY: [this.offset, '0px'],
        easing: enterEasing,
        complete: complete
      });
    },
    leave: function leave(el, complete) {
      anime_es.anime({
        targets: el,
        opacity: [1, 0],
        translateY: ['0px', this.offset],
        easing: leaveEasing,
        complete: complete
      });
    }
  },
  render: function render(h) {
    var finalChildren;
    var children = this.$slots.default || [h(null)];

    if (children.length > 1) {
      var clean = utils.cleanChildren(children);
      finalChildren = clean.map(function (vnode, index) {
        return utils.cloneVNodeElement(vnode, {
          key: "scale-" + index
        }, h);
      });
    } else {
      finalChildren = children;
    }

    var TransitionElement = finalChildren.length > 1 ? 'TransitionGroup' : 'Transition';
    return h(TransitionElement, {
      props: {
        css: false
      },
      on: {
        beforeEnter: function beforeEnter(el) {
          el && el.style.setProperty('will-change', 'opacity, transform');
        },
        enter: this.enter,
        leave: this.leave
      }
    }, finalChildren);
  }
};
var CRevealHeight = {
  name: 'CRevealHeight',
  props: {
    initialHeight: {
      type: Number,
      default: 0
    },
    duration: {
      type: Number,
      default: 150
    },
    enterEasing: {
      type: String,
      default: enterEasing
    },
    leaveEasing: {
      type: String,
      default: leaveEasing
    },
    finalHeight: Number,
    animateOpacity: {
      type: Boolean,
      default: true
    }
  },
  methods: {
    enter: function enter(el, complete) {
      var this$1 = this;
      this.$emit('enter', el);
      el.style.visibility = 'hidden';
      el.style.height = 'auto';
      var ref = getComputedStyle(el);
      var height = ref.height;
      el.style.height = this.initialHeight || 0;
      requestAnimationFrame(function () {
        el.style.visibility = 'visible';
        anime_es.anime(Object.assign({}, {
          targets: el
        }, this$1.animateOpacity && {
          opacity: [0, 1]
        }, {
          height: [this$1.initialHeight || 0, this$1.finalHeight || height],
          easing: this$1.enterEasing,
          duration: this$1.duration,
          complete: complete
        }));
      });
    },
    leave: function leave(el, complete) {
      var this$1 = this;
      this.$emit('leave', el);
      var ref = getComputedStyle(el);
      var height = ref.height;
      requestAnimationFrame(function () {
        anime_es.anime(Object.assign({}, {
          targets: el
        }, this$1.animateOpacity && {
          opacity: [1, 0]
        }, {
          height: [this$1.finalHeight || height, this$1.initialHeight || 0],
          easing: this$1.leaveEasing,
          duration: this$1.duration,
          complete: complete
        }));
      });
    },
    handleEmit: function handleEmit(event, payload) {
      this.$emit(event, payload);
    }
  },
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;

    if (!children) {
      return h();
    }

    var TransitionElement = children ? children.length > 1 ? 'TransitionGroup' : 'Transition' : 'Transition';
    var clones = children.map(function (vnode, index) {
      return utils.cloneVNodeElement(vnode, {
        key: "scale-" + index
      });
    });
    return h(TransitionElement, {
      props: {
        css: false
      },
      on: {
        beforeEnter: function beforeEnter(el) {
          if (el) {
            el.style.setProperty('will-change', 'opacity, transform');
          }

          this$1.handleEmit('beforeEnter', el);
        },
        enter: this.enter,
        leave: this.leave,
        afterEnter: function afterEnter(el) {
          el.style.height = 'auto';
          this$1.handleEmit('afterEnter', el);
        }
      }
    }, clones);
  }
};
var CAnimateHeight = {
  name: 'CAnimateHeight',
  props: {
    isOpen: Boolean,
    initialHeight: {
      type: Number,
      default: 0
    },
    duration: {
      type: Number,
      default: 150
    },
    enterEasing: {
      type: String,
      default: enterEasing
    },
    leaveEasing: {
      type: String,
      default: leaveEasing
    },
    finalHeight: Number,
    animateOpacity: {
      type: Boolean,
      default: true
    }
  },
  data: function data() {
    return {
      el: undefined
    };
  },
  mounted: function mounted() {
    var this$1 = this;
    this.el = this.getNode(this.$el);
    this.$watch('isOpen', function (isOpen) {
      if (isOpen) {
        this$1.enter(this$1.el, function () {});
      } else {
        this$1.leave(this$1.el, function () {});
      }
    }, {
      immediate: true
    });
  },
  methods: {
    enter: function enter(el, complete) {
      var this$1 = this;
      this.$emit('enter', el);
      el.style.visibility = 'hidden';
      el.style.height = this.finalHeight || 'auto';
      var ref = getComputedStyle(el);
      var height = ref.height;
      el.style.height = this.initialHeight || 0;
      requestAnimationFrame(function () {
        el.style.visibility = 'visible';
        anime_es.anime(Object.assign({}, {
          targets: el
        }, this$1.animateOpacity && {
          opacity: [0, 1]
        }, {
          height: [this$1.initialHeight || 0, this$1.finalHeight || height],
          easing: this$1.enterEasing,
          duration: this$1.duration,
          complete: function complete() {
            el.style.height = this$1.finalHeight || 'auto';
          }
        }));
      });
    },
    leave: function leave(el, complete) {
      var this$1 = this;
      this.$emit('leave', el);
      var ref = getComputedStyle(el);
      var height = ref.height;
      requestAnimationFrame(function () {
        anime_es.anime(Object.assign({}, {
          targets: el
        }, this$1.animateOpacity && {
          opacity: [1, 0]
        }, {
          height: [this$1.finalHeight || height, this$1.initialHeight || 0],
          easing: this$1.leaveEasing,
          duration: this$1.duration,
          complete: complete
        }));
      });
    },
    handleEmit: function handleEmit(event, payload) {
      this.$emit(event, payload);
    },
    getNode: function getNode(element) {
      var isVue = utils.isVueComponent(element);
      return isVue ? element.$el : element;
    }
  },
  render: function render(h) {
    var children = this.$slots.default;
    return h('div', {
      style: {
        overflow: 'hidden'
      },
      attrs: {
        'data-chakra-component': 'CAnimateHeight'
      }
    }, children);
  }
};
exports.CAnimateHeight = CAnimateHeight;
exports.CFade = CFade;
exports.CRevealHeight = CRevealHeight;
exports.CScale = CScale;
exports.CSlide = CSlide;
exports.CSlideIn = CSlideIn;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


var utils = __webpack_require__(2);

var props_types = __webpack_require__(6);

var flexProps = {
  as: {
    type: String,
    default: 'div'
  },
  align: props_types.SNA,
  justify: props_types.SNA,
  wrap: props_types.SNA,
  direction: props_types.SNA,
  size: props_types.SNA
};
/**
 * Hey! Welcome to @chakra-ui/vue Flex
 *
 * `CFlex` is `CBox` with `display: flex` and comes with
 * helpful style shorthands. It renders a `div` element.
 *
 * @see Docs     https://vue.chakra-ui.com/flex
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CFlex/CFlex.js
 */

/**
 * CFlex component
 *
 * `CFlex` is `CBox` with display: flex and comes with helpful style shorthands.
 *
 * @see Docs https://vue.chakra-ui.com/flex
 */

var CFlex = {
  name: 'CFlex',
  mixins: [utils.createStyledAttrsMixin('CFlex')],
  props: flexProps,
  computed: {
    componentStyles: function componentStyles() {
      return {
        display: 'flex',
        flexDirection: this.direction,
        alignItems: this.align,
        justifyContent: this.justify,
        flexWrap: this.wrap,
        h: this.size,
        w: this.size
      };
    }
  },
  render: function render(h) {
    return h(this.as, {
      class: this.className,
      attrs: this.computedAttrs,
      on: this.computedListeners
    }, this.$slots.default);
  }
};
exports.CFlex = CFlex;
exports.flexProps = flexProps;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */

/**
 * Returns truncation style props for text elements.
 * @todo Add line-clamp features for text.
 */

var useTruncated = function useTruncated() {
  return {
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap'
  };
};

exports.useTruncated = useTruncated;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(158);
} else {}

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.weak-map.delete-all.js");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */

/**
 * This clickoutside directive has been adpated form vue-bulma's clickoutside directive
 * @see https://github.com/vue-bulma/click-outside
 */

function validate(binding) {
  if (typeof binding.value !== 'function') {
    console.warn('[Vue-click-outside:] provided expression', binding.expression, 'is not a function.');
    return false;
  }

  return true;
}

function isPopup(popupItem, elements) {
  if (!popupItem || !elements) {
    return false;
  }

  for (var i = 0, len = elements.length; i < len; i++) {
    try {
      if (popupItem.contains(elements[i])) {
        return true;
      }

      if (elements[i].contains(popupItem)) {
        return false;
      }
    } catch (e) {
      return false;
    }
  }

  return false;
}

function isServer(vNode) {
  return typeof vNode.componentInstance !== 'undefined' && vNode.componentInstance.$isServer;
}

var ClickOutside = {
  bind: function bind(el, binding, vNode) {
    if (!validate(binding)) {
      return;
    } // Define Handler and cache it on the element


    function handler(e) {
      if (!vNode.context) {
        return;
      } // some components may have related popup item, on which we shall prevent the click outside event handler.


      var elements = e.path || e.composedPath && e.composedPath();
      elements && elements.length > 0 && elements.unshift(e.target);

      if (el.contains(e.target) || isPopup(vNode.context.popupItem, elements)) {
        return;
      }

      el.__vueClickOutside__.callback(e);
    } // add Event Listeners


    el.__vueClickOutside__ = {
      handler: handler,
      callback: binding.value
    };
    var clickHandler = 'ontouchstart' in document.documentElement ? 'touchstart' : 'click';
    !isServer(vNode) && document.addEventListener(clickHandler, handler);
  },
  update: function update(el, binding) {
    if (validate(binding)) {
      el.__vueClickOutside__.callback = binding.value;
    }
  },
  unbind: function unbind(el, binding, vNode) {
    // Remove Event Listeners
    var clickHandler = 'ontouchstart' in document.documentElement ? 'touchstart' : 'click';
    !isServer(vNode) && el.__vueClickOutside__ && document.removeEventListener(clickHandler, el.__vueClickOutside__.handler);
    delete el.__vueClickOutside__;
  }
};
exports.ClickOutside = ClickOutside;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var text_utils = __webpack_require__(22);
/**
 * Hey! Welcome to @chakra-ui/vue Text
 *
 * Text is the used to render text and paragraphs within an interface. It renders a <p> tag by default.
 *
 * @see Docs     https://vue.chakra-ui.com/text
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CText/CText.js
 */

/**
 * CText component
 *
 * the text element component
 *
 * @see Docs https://vue.chakra-ui.com/text
 */


var CText = {
  name: 'CText',
  mixins: [utils.createStyledAttrsMixin('CText')],
  props: {
    as: {
      type: [String, Array],
      default: 'p'
    },
    isTruncated: Boolean,
    fontFamily: {
      type: [String, Array],
      default: 'body'
    }
  },
  computed: {
    componentStyles: function componentStyles() {
      return Object.assign({}, {
        fontFamily: this.as === 'kbd' ? 'mono' : this.fontFamily
      }, this.isTruncated && text_utils.useTruncated());
    }
  },
  render: function render(h) {
    return h(this.as, {
      class: this.className,
      attrs: this.computedAttrs
    }, this.$slots.default);
  }
};
exports.default = CText;

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _stubFalse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(94);


/** Detect free variable `exports`. */

var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? _root_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || _stubFalse_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"];
/* harmony default export */ __webpack_exports__["a"] = (isBuffer);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(90)(module)))

/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.map.delete-all.js");

/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.map.every.js");

/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.map.filter.js");

/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.map.find.js");

/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.map.find-key.js");

/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.map.includes.js");

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.map.key-of.js");

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.map.map-keys.js");

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.map.map-values.js");

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.map.merge.js");

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.map.reduce.js");

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.map.some.js");

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.map.update.js");

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.set.add-all.js");

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.set.delete-all.js");

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.set.difference.js");

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.set.every.js");

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.set.filter.js");

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.set.find.js");

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.set.intersection.js");

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.set.is-disjoint-from.js");

/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.set.is-subset-of.js");

/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.set.is-superset-of.js");

/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.set.join.js");

/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.set.map.js");

/***/ }),
/* 53 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.set.reduce.js");

/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.set.some.js");

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.set.symmetric-difference.js");

/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/esnext.set.union.js");

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


var utils = __webpack_require__(2);

var solidStyle = function solidStyle(ref) {
  var colors = ref.theme.colors;
  var color = ref.color;

  var _color = colors[color] && colors[color][500];

  var darkModebackgroundColor = utils.addOpacity(_color, 0.6);
  return {
    light: {
      backgroundColor: utils.get(color, 500),
      color: 'white'
    },
    dark: {
      backgroundColor: darkModebackgroundColor,
      color: 'whiteAlpha.800'
    }
  };
};

var subtleStyle = function subtleStyle(ref) {
  var colors = ref.theme.colors;
  var color = ref.color;

  var _color = colors[color] && colors[color][200];

  var alphaColors = utils.generateAlphas(_color);
  var darkModebackgroundColor = alphaColors[300];
  return {
    light: {
      backgroundColor: utils.get(color, 100),
      color: utils.get(color, 800)
    },
    dark: {
      backgroundColor: darkModebackgroundColor,
      color: utils.get(color, 200)
    }
  };
};

var outlineStyle = function outlineStyle(ref) {
  var colors = ref.theme.colors;
  var color = ref.color;

  var _color = colors[color] && colors[color][200];

  var darkModeColor = utils.addOpacity(_color, 0.8);
  var boxShadowColor = colors[color] && colors[color][500];
  return {
    light: {
      boxShadow: 'inset 0 0 0px 1px ' + boxShadowColor,
      color: utils.get(color, 500)
    },
    dark: {
      boxShadow: 'inset 0 0 0px 1px ' + darkModeColor,
      color: darkModeColor
    }
  };
};

var variantProps = function variantProps(props) {
  var variant = props.variant;
  var colorMode = props.colorMode;

  switch (variant) {
    case 'solid':
      return solidStyle(props)[colorMode];

    case 'subtle':
      return subtleStyle(props)[colorMode];

    case 'outline':
      return outlineStyle(props)[colorMode];

    default:
      return {};
  }
};

var useBadgeStyle = function useBadgeStyle(props) {
  return variantProps(props);
};

exports.useBadgeStyle = useBadgeStyle;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

var css = __webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);
/**
 * Hey! Welcome to @chakra-ui/vue ControlBox
 *
 * ControlBox provides style props to change it's styles based
 * on a sibling checkbox or radio input.
 *
 * In order to keep prerve accessiblity, it relies on a common
 * [CSS technique](https://dev.to/lkopacz/create-custom-keyboard-accessible-checkboxes-2036)
 * for styling custom controls.
 *
 * > For this component to work, it should have a sibling input and be contained in a label
 *
 * @see Docs     https://vue.chakra-ui.com/controlbox
 * @see Strategy https://dev.to/lkopacz/create-custom-keyboard-accessible-checkboxes-2036
 */


var PseudoPropTypes = [Object, Array];
/**
 * CControlBox component
 *
 * Provides a wrapper to create custom style `radio` and `checkbox` inputs
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/controlbox
 */

var CControlBox = {
  name: 'CControlBox',
  functional: true,
  inject: ['$chakraTheme'],
  props: {
    as: [String, Object],
    type: {
      type: String,
      default: 'checkbox'
    },
    size: {
      type: [Number, String, Array],
      default: 'auto'
    },
    _child: {
      type: PseudoPropTypes,
      default: function _default() {
        return {
          opacity: 0
        };
      }
    },
    _checkedAndChild: {
      type: PseudoPropTypes,
      default: function _default() {
        return {
          opacity: 1
        };
      }
    },
    _checkedAndDisabled: PseudoPropTypes,
    _checkedAndFocus: PseudoPropTypes,
    _checkedAndHover: PseudoPropTypes
  },
  render: function render(h, ref) {
    var obj, obj$1;
    var props = ref.props;
    var data = ref.data;
    var injections = ref.injections;
    var slots = ref.slots;
    var attrs = data.attrs; // Inject theme

    var theme = injections.$chakraTheme(); // Parse child styles

    var checkedAndDisabled = "input[type=" + props.type + "]:checked:disabled + &, input[type=" + props.type + "][aria-checked=mixed]:disabled + &";
    var checkedAndHover = "input[type=" + props.type + "]:checked:hover:not(:disabled) + &, input[type=" + props.type + "][aria-checked=mixed]:hover:not(:disabled) + &";
    var checkedAndFocus = "input[type=" + props.type + "]:checked:focus + &, input[type=" + props.type + "][aria-checked=mixed]:focus + &";
    var disabled = "input[type=" + props.type + "]:disabled + &";
    var focus = "input[type=" + props.type + "]:focus + &";
    var hover = "input[type=" + props.type + "]:hover:not(:disabled):not(:checked) + &";
    var checked = "input[type=" + props.type + "]:checked + &, input[type=" + props.type + "][aria-checked=mixed] + &";
    var invalid = "input[type=" + props.type + "][aria-invalid=true] + &";
    var basePseudoAttrs = attrs && (obj = {}, obj[focus] = attrs._focus, obj[hover] = attrs._hover, obj[disabled] = attrs._disabled, obj[invalid] = attrs._invalid, obj) || {};
    var controlBoxStyleObject = utils.composeSystem(Object.assign({}, basePseudoAttrs, (obj$1 = {}, obj$1[checkedAndDisabled] = props._checkedAndDisabled, obj$1[checkedAndFocus] = props._checkedAndFocus, obj$1[checkedAndHover] = props._checkedAndHover, {
      '& > *': props._child
    }, obj$1[checked] = Object.assign({}, attrs && attrs._checked, {
      '& > *': props._checkedAndChild
    }), obj$1)), theme);
    var className = css.css(controlBoxStyleObject);
    return h(CBox.default, Object.assign({}, data, {
      class: [className],
      props: {
        as: props.as
      },
      attrs: Object.assign({}, {
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        transition: 'all 120ms',
        flexShrink: '0',
        width: props.size,
        height: props.size,
        'aria-hidden': 'true'
      }, attrs, {
        'data-chakra-component': 'CControlBox'
      })
    }), slots().default);
  }
};
exports.default = CControlBox;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


var formControlProps = {
  isInvalid: Boolean,
  isRequired: Boolean,
  isDisabled: Boolean,
  isReadOnly: Boolean
};
exports.formControlProps = formControlProps;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * Fragment component to render multiple child sibling nodes in the place of
 * their parent in the DOM.
 * Note: This is a temporary solution to create fragments in Vue 2
 * until Vue 3 releases internal Fragment support
 */

var CFragment = {
  name: 'CFragment',
  directives: {
    fragment: {
      inserted: function inserted(el) {
        var fragment = document.createDocumentFragment();
        Array.from(el.childNodes).forEach(function (child) {
          return fragment.appendChild(child);
        });
        el.parentNode.insertBefore(fragment, el);
        el.parentNode.removeChild(el);
      }
    }
  },
  render: function render(h) {
    // Here we render div but will remove it when node is inserted.
    // And replace it with children
    return h('div', {
      directives: [{
        name: 'fragment'
      }]
    }, this.$slots.default);
  }
};
exports.default = CFragment;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


var utils = __webpack_require__(2);

var props_types = __webpack_require__(6);

var input_styles = __webpack_require__(15);

var inputProps = {
  size: {
    type: props_types.SNA,
    default: 'md'
  },
  variant: {
    type: props_types.StringArray,
    default: 'outline'
  },
  as: {
    type: String,
    default: 'input'
  },
  _ariaLabel: String,
  _ariaDescribedby: String,
  isFullWidth: {
    type: Boolean,
    default: true
  },
  isReadOnly: Boolean,
  isDisabled: Boolean,
  isInvalid: Boolean,
  isRequired: Boolean,
  focusBorderColor: {
    type: String,
    default: 'blue.200'
  },
  errorBorderColor: {
    type: String,
    default: 'red.300'
  },
  value: {
    type: [String, Number],
    default: undefined
  }
};
/**
 * Hey! Welcome to @chakra-ui/vue Input
 *
 * CInput component is a component that is used to get user input in a text field
 *
 * It is usually used together with the FormControl to provide an accessible label, validation messages, etc.
 *
 * @see Docs     https://vue.chakra-ui.com/input
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CInput/CInput.js
 * @see WAI      https://www.w3.org/WAI/tutorials/forms/
 */

/**
 * CInput component
 *
 * Gets user input in a text field
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/input
 */

var CInput = {
  name: 'CInput',
  mixins: [utils.createStyledAttrsMixin('CInput')],
  inject: {
    $chakraColorMode: {
      default: 'light'
    },
    $chakraTheme: {
      default: function _default() {
        return {};
      }
    },
    $useFormControl: {
      default: null
    }
  },
  model: {
    prop: 'value',
    event: 'input'
  },
  props: inputProps,
  computed: {
    formControl: function formControl() {
      if (!this.$useFormControl) {
        return {
          isReadOnly: this.isReadOnly,
          isDisabled: this.isDisabled,
          isInvalid: this.isInvalid,
          isRequired: this.isRequired
        };
      }

      return this.$useFormControl(this.$props);
    },
    inputStyles: function inputStyles() {
      return input_styles.useInputStyle(Object.assign({}, this.$props, {
        theme: this.theme,
        colorMode: this.colorMode
      }));
    },
    componentStyles: function componentStyles() {
      return Object.assign({}, this.inputStyles, {
        fontFamily: 'body'
      });
    }
  },
  methods: {
    emitValue: function emitValue(event) {
      this.$emit('input', event.target.value, event);
      this.$emit('change', event);
    }
  },
  render: function render(h) {
    return h(this.as, {
      class: [this.className],
      domProps: {
        value: this.value
      },
      attrs: Object.assign({}, {
        'aria-readonly': this.isReadOnly,
        readonly: this.formControl.isReadOnly,
        disabled: this.formControl.isDisabled,
        'aria-disabled': this.formControl.isDisabled,
        'aria-invalid': this.formControl.isInvalid,
        required: this.formControl.isRequired,
        'aria-required': this.formControl.isRequired
      }, this.computedAttrs),
      on: Object.assign({}, this.computedListeners, {
        input: this.emitValue
      }),
      ref: 'input'
    }, this.$slots.default);
  }
};
exports.CInput = CInput;
exports.inputProps = inputProps;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


__webpack_require__(28);

__webpack_require__(29);

__webpack_require__(30);

__webpack_require__(31);

__webpack_require__(32);

__webpack_require__(33);

__webpack_require__(34);

__webpack_require__(35);

__webpack_require__(36);

__webpack_require__(37);

__webpack_require__(38);

__webpack_require__(39);

__webpack_require__(40);

__webpack_require__(41);

__webpack_require__(42);

__webpack_require__(43);

__webpack_require__(44);

__webpack_require__(45);

__webpack_require__(46);

__webpack_require__(47);

__webpack_require__(48);

__webpack_require__(49);

__webpack_require__(50);

__webpack_require__(51);

__webpack_require__(52);

__webpack_require__(53);

__webpack_require__(54);

__webpack_require__(55);

__webpack_require__(56);

Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

var clickoutside_directive = __webpack_require__(25);

var css = __webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

var CPseudoBox = __webpack_require__(12);

var CPortal = __webpack_require__(17);

__webpack_require__(13);

function getBoundingClientRect(element) {
  var rect = element.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height,
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    x: rect.left,
    y: rect.top
  };
}
/*:: import type { Window } from '../types'; */

/*:: declare function getWindow(node: Node | Window): Window; */


function getWindow(node) {
  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }

  return node;
}

function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}
/*:: declare function isElement(node: mixed): boolean %checks(node instanceof
  Element); */


function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
/*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof
  HTMLElement); */


function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

function getDocumentElement(element) {
  // $FlowFixMe: assume body is always available
  return (isElement(element) ? element.ownerDocument : element.document).documentElement;
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle$1(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
} // Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (!isFixed) {
    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
} // Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.


function getLayoutRect(element) {
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}

function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (// $FlowFixMe: this is a quicker (but less type safe) way to save quite some bytes from the bundle
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    // $FlowFixMe: need a better way to handle this...
    element.host || // ShadowRoot detected
    // $FlowFixMe: HTMLElement is a Node
    getDocumentElement(element) // fallback

  );
}

function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe: assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }

  return getScrollParent(getParentNode(node));
}

function listScrollParents(element, list) {
  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
  var isBody = getNodeName(scrollParent) === 'body';
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
}

function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element); // Find the nearest non-table offsetParent

  while (offsetParent && isTableElement(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static') {
    return window;
  }

  return offsetParent || window;
}

var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

function format(str) {
  var arguments$1 = arguments;

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments$1[_key];
  }

  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
}

var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];

function validateModifiers(modifiers) {
  modifiers.forEach(function (modifier) {
    Object.keys(modifier).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }

          break;

        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }

        case 'phase':
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
          }

          break;

        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'effect':
          if (typeof modifier.effect !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'requires':
          if (!Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }

          break;

        case 'requiresIfExists':
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
          }

          break;

        case 'options':
        case 'data':
          break;

        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }

      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function (item) {
    var identifier = fn(item);

    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, {}, current, {
      options: Object.assign({}, existing.options, {}, current.options),
      data: Object.assign({}, existing.data, {}, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  var arguments$1 = arguments;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments$1[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, {}, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(options) {
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, {}, state.options, {}, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned
        // if one of the modifiers is invalid for any reason

        if (false) { var _getComputedStyle, marginTop, marginRight, marginBottom, marginLeft, flipModifier, modifiers; }

        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          if (false) {}

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (false) {}

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      if (false) {}

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


var eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
};

function getVariation(placement) {
  return placement.split('-')[1];
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case start:
        offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference[len] / 2 - element[len] / 2);
        break;

      case end:
        offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference[len] / 2 - element[len] / 2);
        break;
    }
  }

  return offsets;
}

function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name; // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step

  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};
var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsets(_ref) {
  var x = _ref.x,
      y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: Math.round(x * dpr) / dpr || 0,
    y: Math.round(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive;

  var _roundOffsets = roundOffsets(offsets),
      x = _roundOffsets.x,
      y = _roundOffsets.y;

  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = top;
  var win = window;

  if (adaptive) {
    var offsetParent = getOffsetParent(popper);

    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);
    } // $FlowFixMe: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

    /*:: offsetParent = (offsetParent: Element); */


    if (placement === top) {
      sideY = bottom;
      y -= offsetParent.clientHeight - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === left) {
      sideX = right;
      x -= offsetParent.clientWidth - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref3) {
  var state = _ref3.state,
      options = _ref3.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive;

  if (false) { var transitionProperty; }

  var commonStyles = {
    placement: getBasePlacement(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, {}, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, {}, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
}; // and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect$1(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      } // Flow doesn't support to extend this property, but it's the most
      // effective way to apply styles to an HTMLElement
      // $FlowFixMe


      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


var applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect$1,
  requires: ['computeStyles']
};

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var offset$1 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};
var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};

function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

var hash$1 = {
  start: 'end',
  end: 'start'
};

function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash$1[matched];
  });
}

function getViewportRect(element) {
  var win = getWindow(element);
  var visualViewport = win.visualViewport;
  var width = win.innerWidth;
  var height = win.innerHeight; // We don't know which browsers have buggy or odd implementations of this, so
  // for now we're only applying it to iOS to fix the keyboard issue.
  // Investigation required

  if (visualViewport && /iPhone|iPod|iPad/.test(navigator.platform)) {
    width = visualViewport.width;
    height = visualViewport.height;
  }

  return {
    width: width,
    height: height,
    x: 0,
    y: 0
  };
}

function getDocumentRect(element) {
  var win = getWindow(element);
  var winScroll = getWindowScroll(element);
  var documentRect = getCompositeRect(getDocumentElement(element), win);
  documentRect.height = Math.max(documentRect.height, win.innerHeight);
  documentRect.width = Math.max(documentRect.width, win.innerWidth);
  documentRect.x = -winScroll.scrollLeft;
  documentRect.y = -winScroll.scrollTop;
  return documentRect;
}

function toNumber(cssValue) {
  return parseFloat(cssValue) || 0;
}

function getBorders(element) {
  var computedStyle = isHTMLElement(element) ? getComputedStyle$1(element) : {};
  return {
    top: toNumber(computedStyle.borderTopWidth),
    right: toNumber(computedStyle.borderRightWidth),
    bottom: toNumber(computedStyle.borderBottomWidth),
    left: toNumber(computedStyle.borderLeftWidth)
  };
}

function getDecorations(element) {
  var win = getWindow(element);
  var borders = getBorders(element);
  var isHTML = getNodeName(element) === 'html';
  var winScrollBarX = getWindowScrollBarX(element);
  var x = element.clientWidth + borders.right;
  var y = element.clientHeight + borders.bottom; // HACK:
  // document.documentElement.clientHeight on iOS reports the height of the
  // viewport including the bottom bar, even if the bottom bar isn't visible.
  // If the difference between window innerHeight and html clientHeight is more
  // than 50, we assume it's a mobile bottom bar and ignore scrollbars.
  // * A 50px thick scrollbar is likely non-existent (macOS is 15px and Windows
  //   is about 17px)
  // * The mobile bar is 114px tall

  if (isHTML && win.innerHeight - element.clientHeight > 50) {
    y = win.innerHeight - borders.bottom;
  }

  return {
    top: isHTML ? 0 : element.clientTop,
    right: // RTL scrollbar (scrolling containers only)
    element.clientLeft > borders.left ? borders.right : // LTR scrollbar
    isHTML ? win.innerWidth - x - winScrollBarX : element.offsetWidth - x,
    bottom: isHTML ? win.innerHeight - y : element.offsetHeight - y,
    left: isHTML ? winScrollBarX : element.clientLeft
  };
}

function contains(parent, child) {
  // $FlowFixMe: hasOwnProperty doesn't seem to work in tests
  var isShadow = Boolean(child.getRootNode && child.getRootNode().host); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (isShadow) {
    var next = child;

    do {
      if (next && parent.isSameNode(next)) {
        return true;
      } // $FlowFixMe: need a better way to handle this...


      next = next.parentNode || next.host;
    } while (next);
  } // Give up, the result is false


  return false;
}

function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listScrollParents(element);
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement);
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    var decorations = getDecorations(isHTMLElement(clippingParent) ? clippingParent : getDocumentElement(element));
    accRect.top = Math.max(rect.top + decorations.top, accRect.top);
    accRect.right = Math.min(rect.right - decorations.right, accRect.right);
    accRect.bottom = Math.min(rect.bottom - decorations.bottom, accRect.bottom);
    accRect.left = Math.max(rect.left + decorations.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), {}, paddingObject);
}

function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var referenceElement = state.elements.reference;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(referenceElement);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, {}, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}
/*:: type OverflowsMap = { [ComputedPlacement]: number }; */

/*;; type OverflowsMap = { [key in ComputedPlacement]: number }; */


function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = (variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements).filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  }); // $FlowFixMe: Flow seems to have problems with two array unions...

  var overflows = placements$1.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }

  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = getBasePlacement(placement);

    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }

    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases – research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") {
        break;
      }
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


var flip$1 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};

function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

function within(min, value, max) {
  return Math.max(min, Math.min(value, max));
}

function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = popperOffsets[mainAxis] + overflow[mainSide];
    var max = popperOffsets[mainAxis] - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _mainSide = mainAxis === 'x' ? top : left;

    var _altSide = mainAxis === 'x' ? bottom : right;

    var _offset = popperOffsets[altAxis];

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var _preventedOffset = within(_min, _offset, _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = state.modifiersData[name + "#persistent"].padding;
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect$2(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element,
      _options$padding = options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (false) {}

  if (!contains(state.elements.popper, arrowElement)) {
    if (false) {}

    return;
  }

  state.elements.arrow = arrowElement;
  state.modifiersData[name + "#persistent"] = {
    padding: mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements))
  };
} // eslint-disable-next-line import/no-unused-modules


var arrow$1 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect$2,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};

function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


var hide$1 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

/**
 * Evaluates popper arrow styles
 * @param {{ arrowSize: String, arrowShadowColor: String, hasArrow: Boolean}} props
 * @returns {String} Popper Arrow styles
 */

var getPopperArrowStyle = function getPopperArrowStyle(ref) {
  var arrowSize = ref.arrowSize;
  if (arrowSize === void 0) arrowSize = '1rem';
  var arrowShadowColor = ref.arrowShadowColor;
  if (arrowShadowColor === void 0) arrowShadowColor = 'rgba(0, 0, 0, 0.1)';
  var hasArrow = ref.hasArrow;
  if (hasArrow === void 0) hasArrow = true;
  var bg = ref.bg;
  if (bg === void 0) bg = 'inherit';
  var popoverMargin = hasArrow ? "calc(" + arrowSize + " / 2)" : null;
  var arrowPos = "calc(" + arrowSize + " / 2 * -1)";
  return css.css({
    display: 'none',
    '[data-show]': {
      display: 'block'
    },
    '[data-popper-arrow]': {
      position: 'absolute',
      zIndex: -1,
      '&::before': {
        content: '""',
        transform: 'rotate(45deg)',
        backgroundColor: bg,
        display: 'block',
        width: arrowSize,
        height: arrowSize
      }
    },
    '&[data-popper-placement^="top"]': {
      marginBottom: popoverMargin,
      transformOrigin: 'bottom center'
    },
    '&[data-popper-placement^="top"] [data-popper-arrow]': {
      bottom: arrowPos,
      '&::before': {
        boxShadow: "2px 2px 2px 0 " + arrowShadowColor
      }
    },
    '&[data-popper-placement^="bottom"]': {
      marginTop: popoverMargin,
      transformOrigin: 'top center'
    },
    '&[data-popper-placement^="bottom"] [data-popper-arrow]': {
      top: arrowPos,
      '&::before': {
        boxShadow: "-1px -1px 1px 0 " + arrowShadowColor
      }
    },
    '&[data-popper-placement^="right"]': {
      marginLeft: popoverMargin,
      transformOrigin: 'left center'
    },
    '&[data-popper-placement^="right"] [data-popper-arrow]': {
      left: arrowPos,
      '&::before': {
        boxShadow: "-1px 1px 1px 0 " + arrowShadowColor
      }
    },
    '&[data-popper-placement^="left"]': {
      marginRight: popoverMargin,
      transformOrigin: 'right center'
    },
    '&[data-popper-placement^="left"] [data-popper-arrow]': {
      right: arrowPos,
      '&::before': {
        boxShadow: "1px -1px 1px 0 " + arrowShadowColor
      }
    }
  });
};
/**
 * Hey! Welcome to @chakra-ui/vue Popper
 *
 * The Popper component is an internal utility component used
 * to wrap the Popper.js library in to a Vue component
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * Flips placement if in <body dir="rtl" />
 * @param {string} placement
 */


function flipPlacement(placement) {
  var direction = utils.canUseDOM && document.body.getAttribute('dir') || 'ltr';

  if (direction !== 'rtl') {
    return placement;
  }

  switch (placement) {
    case 'bottom-end':
      return 'bottom-start';

    case 'bottom-start':
      return 'bottom-end';

    case 'top-end':
      return 'top-start';

    case 'top-start':
      return 'top-end';

    default:
      return placement;
  }
}
/**
 * Call _.merge() for each item of `object` array with the corresponding
 * item of `source` array
 * @param {*} object The destination Modifiers array.
 * @param {*} source The source array.
 * @returns Returns merged `array`
 */


function mergeModifiers(object, source) {
  if (!Array.isArray(object)) {
    throw new Error('`object` must be an array');
  }

  var _source = Array.isArray(source) ? source : [source];

  object.forEach(function (o) {
    var name = o.name;

    var _s = _source.find(function (s) {
      return s.name === name;
    });

    if (_s) {
      utils.merge(o, _s);
    }
  });
  return object;
}
/**
 * CPopper component
 *
 * The popper.js component
 *
 * @extends CPseudoBox
 * @see PopperJs https://popper.js.org/
 */


var CPopper = {
  name: 'CPopper',
  inheritAttrs: false,
  directives: {
    ClickOutside: clickoutside_directive.ClickOutside
  },
  props: {
    as: {
      type: [String, Object],
      default: 'div'
    },
    isOpen: Boolean,
    placement: {
      type: String,
      default: 'bottom',
      validator: function validator(value) {
        return value.match(/^(top|top-start|top-end|right|right-start|right-end|bottom|bottom-start|bottom-end|left|left-start|left-end)$/);
      }
    },
    usePortal: {
      type: Boolean,
      default: true
    },
    onClose: {
      type: Function,
      default: function _default() {
        return null;
      }
    },
    closeOnClickAway: {
      type: Boolean,
      default: true
    },
    modifiers: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    anchorEl: utils.HTMLElement,
    eventsEnabled: {
      type: Boolean,
      default: true
    },
    arrowSize: {
      type: String,
      default: '1rem'
    },
    arrowShadowColor: {
      type: String,
      default: 'rgba(0, 0, 0, 0.1)'
    },
    hasArrow: {
      type: Boolean,
      default: true
    },
    positionFixed: Boolean,
    usePortalTarget: String
  },
  data: function data() {
    return {
      popper: null,
      referenceBackgroundColor: undefined
    };
  },
  watch: {
    placement: function placement(newValue) {
      if (this.popper) {
        this.popper.options.placement = newValue;
        this.reference.setAttribute('data-show', '');
      }
    },
    isOpen: function isOpen(newValue) {
      if (newValue) {
        this.handleOpen();
      } else {
        this.handleClose();
      }
    }
  },
  computed: {
    arrowStyles: function arrowStyles() {
      return getPopperArrowStyle({
        arrowSize: this.arrowSize,
        arrowShadowColor: this.arrowShadowColor,
        hasArrow: this.hasArrow,
        bg: this.referenceBackgroundColor
      });
    },
    portalTarget: function portalTarget() {
      return this.usePortalTarget || "#chakra-portal-" + utils.useId(4);
    },
    popperId: function popperId() {
      return "popper_" + utils.useId(4);
    },
    rtlPlacement: function rtlPlacement() {
      return flipPlacement(this.placement);
    },
    anchor: function anchor() {
      return this.getNode(this.anchorEl);
    },
    reference: function reference() {
      var ref = this.usePortal // There should be a much cleaner way to do this.
      // But for now this works. Should return with bigger guns.
      ? utils.canUseDOM && document.querySelector(this.portalTarget).firstChild : this.getNode(this.$el);
      return ref;
    },
    computedModifiers: function computedModifiers() {
      return mergeModifiers([this.usePortal && {
        name: 'preventOverflow',
        options: {
          boundary: 'window'
        }
      }, {
        name: 'offset',
        options: {
          offset: [0, 10]
        }
      }, {
        name: 'arrow',
        options: {
          element: '[data-popper-arrow]',
          transform: 'rotate(45deg)'
        }
      }], this.modifiers);
    }
  },
  methods: {
    /**
     * Handles open state for Popper
     */
    handleOpen: function handleOpen() {
      var this$1 = this; // Double check to make sure portal target is mounted
      // If it already is mounted, Portal component will use
      // the existing portal target to mount popper children

      this.usePortal && this.$refs.portalRef && this.$refs.portalRef.mountTarget();

      if (!this.anchor || !this.reference) {
        return;
      }

      if (this.popper) {
        this.reference.setAttribute('data-show', '');
        this.popper.update().then(function () {
          if (this$1.hasArrow) {
            var arrow = this$1.reference.querySelector(['[data-popper-arrow]']);

            if (arrow) {
              this$1.$nextTick(function () {
                this$1.referenceBackgroundColor = getComputedStyle(this$1.reference).backgroundColor || getComputedStyle(this$1.reference).background;
              });
            }
          }
        });
      } else {
        this.popper = createPopper(this.anchor, this.reference, {
          placement: this.rtlPlacement,
          modifiers: this.computedModifiers,
          onUpdate: utils.createChainedFunction(this.handlePopperUpdate),
          onFirstUpdate: utils.createChainedFunction(this.handlePopperCreated),
          eventListeners: {
            resize: true,
            scroll: true
          },
          eventsEnabled: this.eventsEnabled,
          positionFixed: this.positionFixed
        });
        this.reference.setAttribute('data-show', '');
        this.popper.update().then(function () {
          if (this$1.hasArrow) {
            var arrow = this$1.reference.querySelector(['[data-popper-arrow]']);

            if (arrow) {
              this$1.$nextTick(function () {
                this$1.referenceBackgroundColor = getComputedStyle(this$1.reference).backgroundColor || getComputedStyle(this$1.reference).background;
              });
            }
          }
        });
      }
    },

    /**
     * Returns the HTML element of a Vue component or native element
     * @param {Vue.Component|HTMLElement} element HTMLElement or Vue Component
     */
    getNode: function getNode(element) {
      var isVue = utils.isVueComponent(element);
      return isVue ? element.$el : element;
    },

    /**
     * Closes Popper Element
     */
    handleClose: function handleClose() {
      if (this.popper) {
        this.reference.removeAttribute('data-show');
        this.$emit('close', {});
      }
    },

    /**
     * Wrapped handler for clickaway events
     */
    wrapClose: function wrapClose(e) {
      if (this.popper && !this.anchor.contains(e.target)) {
        this.closeOnClickAway && this.handleClose();
      }
    },

    /**
     * Handle's popper updates when update is called
     * @param {Object} payload
     */
    handlePopperUpdate: function handlePopperUpdate(payload) {
      this.$emit('update', payload);
      this.isOpen && this.$emit('open');
    },

    /**
     * Handle's popper updates when update is called
     * @param {Object} payload
     */
    handlePopperCreated: function handlePopperCreated(payload) {
      this.$emit('create', payload);
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.popper && this.popper.destroy();
    this.popper = null;
  },
  render: function render(h) {
    if (this.isOpen && !this.popper) {
      this.handleOpen();
    }

    return h(CPortal.default, {
      props: {
        append: true,
        target: this.portalTarget,
        disabled: !this.usePortal,
        slim: true,
        unmountOnDestroy: true,
        targetSlim: true
      },
      ref: 'portalRef'
    }, [h(CPseudoBox.default, {
      class: [this.arrowStyles],
      style: {
        display: this.isOpen ? 'unset' : 'none'
      },
      props: {
        as: this.as
      },
      directives: [{
        name: 'click-outside',
        value: this.wrapClose
      }],
      attrs: Object.assign({}, this.$attrs, {
        id: this.$attrs.id || "chakra-" + this.popperId,
        'data-popper-id': "chakra-" + this.popperId,
        'data-chakra-component': 'CPopper'
      }),
      scopedSlots: {
        popperId: "chakra-" + this.popperId
      },
      ref: 'handleRef'
    }, this.$slots.default)]);
  }
};
var CPopperArrow = {
  name: 'CPopperArrow',
  functional: true,
  render: function render(h, ref) {
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["data"]);
    var rest = rest$1;
    return h(CBox.default, Object.assign({}, rest, {
      attrs: Object.assign({}, data.attrs, {
        'x-arrow': true,
        'data-popper-arrow': true,
        role: 'presentation',
        'data-chakra-component': 'CPopperArrow'
      })
    }));
  }
};
exports.CPopper = CPopper;
exports.CPopperArrow = CPopperArrow;

/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/* harmony default export */ __webpack_exports__["a"] = (freeGlobal);

/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = require("vue-no-ssr");

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(8);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CIcon = __webpack_require__(9);

var CPseudoBox = __webpack_require__(12);

var closebutton_styles = __webpack_require__(16);
/**
 * Hey! Welcome to @chakra-ui/vue CloseButton
 *
 * The CloseButton is essentially a button with a close icon.
 *
 * It is used to handle the close functionality in feedback
 * and overlay components like Alerts, Toasts, Drawers and Modals.
 *
 * @see Docs     https://vue.chakra-ui.com/closebutton
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CCloseButton/CCloseButton.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CCloseButton/accessibility.md
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * CCloseButton component
 *
 * Component as button with close icon
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/closebutton
 */


var CCloseButton = {
  name: 'CCloseButton',
  functional: true,
  inject: ['$chakraColorMode'],
  props: closebutton_styles.closeButtonProps,
  render: function render(h, context) {
    var props = context.props;
    var data = context.data;
    var injections = context.injections;
    var listeners = context.listeners;
    var rest$1 = objectWithoutProperties(context, ["props", "data", "injections", "listeners"]);
    var rest = rest$1;
    var colorMode = injections.$chakraColorMode(); // Pseudo styles

    var hoverColor = {
      light: 'blackAlpha.100',
      dark: 'whiteAlpha.100'
    };
    var activeColor = {
      light: 'blackAlpha.200',
      dark: 'whiteAlpha.200'
    }; // Size styles

    var buttonSize = closebutton_styles.sizes[props.size] && closebutton_styles.sizes[props.size].button;
    var iconSize = closebutton_styles.sizes[props.size] && closebutton_styles.sizes[props.size].icon; // Event listeners

    var nonNativeEvents = {
      click: function click(e) {
        var emitClick = context.listeners.click;

        if (emitClick) {
          emitClick(e);
        }
      }
    };
    var ref = utils.extractListeners(context, nonNativeEvents);
    var native = ref.native;
    var nonNative = ref.nonNative;
    return h(CPseudoBox.default, Object.assign({}, rest, {
      props: {
        as: 'button'
      },
      on: nonNative,
      nativeOn: native,
      attrs: Object.assign({}, {
        'aria-label': props.ariaLabel,
        'aria-disabled': props.isDisabled,
        outline: 'none',
        h: buttonSize,
        w: buttonSize,
        disabled: props.isDisabled,
        cursor: 'pointer',
        _hover: {
          bg: hoverColor[colorMode]
        },
        _active: {
          bg: activeColor[colorMode]
        }
      }, closebutton_styles.baseProps, data.attrs, {
        'data-chakra-component': 'CCloseButton'
      })
    }), [h(CIcon.CIcon, {
      props: {
        name: 'close',
        size: iconSize
      },
      attrs: {
        focusable: false,
        'aria-hidden': true
      }
    })]);
  }
};
exports.default = CCloseButton;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


__webpack_require__(24);

Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(8);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

__webpack_require__(14);

var CBox = __webpack_require__(5);

var CIcon = __webpack_require__(9);

var closebutton_styles = __webpack_require__(16);

var CTransition = __webpack_require__(20);

var CPortal = __webpack_require__(17);

__webpack_require__(13);

var props_types = __webpack_require__(6);

var defaultParent = typeof document !== 'undefined' ? document.body : null;
var counterMap = new WeakMap();
var uncontrolledNodes = new WeakMap();
var markerMap = {};
var lockCount = 0;

var hideOthers = function (originalTarget, parentNode, markerName) {
  if (parentNode === void 0) {
    parentNode = defaultParent;
  }

  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }

  var targets = Array.isArray(originalTarget) ? originalTarget : [originalTarget];

  if (!markerMap[markerName]) {
    markerMap[markerName] = new WeakMap();
  }

  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];

  var deep = function (parent) {
    if (!parent || targets.indexOf(parent) >= 0) {
      return;
    }

    Array.prototype.forEach.call(parent.children, function (node) {
      if (targets.some(function (target) {
        return node.contains(target);
      })) {
        deep(node);
      } else {
        var attr = node.getAttribute('aria-hidden');
        var alreadyHidden = attr !== null && attr !== 'false';
        var counterValue = (counterMap.get(node) || 0) + 1;
        var markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenNodes.push(node);

        if (counterValue === 1 && alreadyHidden) {
          uncontrolledNodes.set(node, true);
        }

        if (markerValue === 1) {
          node.setAttribute(markerName, 'true');
        }

        if (!alreadyHidden) {
          node.setAttribute('aria-hidden', 'true');
        }
      }
    });
  };

  deep(parentNode);
  lockCount++;
  return function () {
    hiddenNodes.forEach(function (node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);

      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute('aria-hidden');
        }

        uncontrolledNodes.delete(node);
      }

      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;

    if (!lockCount) {
      counterMap = new WeakMap();
      counterMap = new WeakMap();
      uncontrolledNodes = new WeakMap();
      markerMap = {};
    }
  };
};

var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])'];
var candidateSelector = candidateSelectors.join(',');
var matches = typeof Element === 'undefined' ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

function tabbable(el, options) {
  options = options || {};
  var regularTabbables = [];
  var orderedTabbables = [];
  var candidates = el.querySelectorAll(candidateSelector);

  if (options.includeContainer) {
    if (matches.call(el, candidateSelector)) {
      candidates = Array.prototype.slice.apply(candidates);
      candidates.unshift(el);
    }
  }

  var i, candidate, candidateTabindex;

  for (i = 0; i < candidates.length; i++) {
    candidate = candidates[i];

    if (!isNodeMatchingSelectorTabbable(candidate)) {
      continue;
    }

    candidateTabindex = getTabindex(candidate);

    if (candidateTabindex === 0) {
      regularTabbables.push(candidate);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        node: candidate
      });
    }
  }

  var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function (a) {
    return a.node;
  }).concat(regularTabbables);
  return tabbableNodes;
}

tabbable.isTabbable = isTabbable;
tabbable.isFocusable = isFocusable;

function isNodeMatchingSelectorTabbable(node) {
  if (!isNodeMatchingSelectorFocusable(node) || isNonTabbableRadio(node) || getTabindex(node) < 0) {
    return false;
  }

  return true;
}

function isTabbable(node) {
  if (!node) {
    throw new Error('No node provided');
  }

  if (matches.call(node, candidateSelector) === false) {
    return false;
  }

  return isNodeMatchingSelectorTabbable(node);
}

function isNodeMatchingSelectorFocusable(node) {
  if (node.disabled || isHiddenInput(node) || isHidden(node)) {
    return false;
  }

  return true;
}

var focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');

function isFocusable(node) {
  if (!node) {
    throw new Error('No node provided');
  }

  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }

  return isNodeMatchingSelectorFocusable(node);
}

function getTabindex(node) {
  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);

  if (!isNaN(tabindexAttr)) {
    return tabindexAttr;
  } // Browsers do not return `tabIndex` correctly for contentEditable nodes;
  // so if they don't have a tabindex attribute specifically set, assume it's 0.


  if (isContentEditable(node)) {
    return 0;
  }

  return node.tabIndex;
}

function sortOrderedTabbables(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
}

function isContentEditable(node) {
  return node.contentEditable === 'true';
}

function isInput(node) {
  return node.tagName === 'INPUT';
}

function isHiddenInput(node) {
  return isInput(node) && node.type === 'hidden';
}

function isRadio(node) {
  return isInput(node) && node.type === 'radio';
}

function isNonTabbableRadio(node) {
  return isRadio(node) && !isTabbableRadio(node);
}

function getCheckedRadio(nodes) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked) {
      return nodes[i];
    }
  }
}

function isTabbableRadio(node) {
  if (!node.name) {
    return true;
  } // This won't account for the edge case where you have radio groups with the same
  // in separate forms on the same page.


  var radioSet = node.ownerDocument.querySelectorAll('input[type="radio"][name="' + node.name + '"]');
  var checked = getCheckedRadio(radioSet);
  return !checked || checked === node;
}

function isHidden(node) {
  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,
  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.
  return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';
}

var tabbable_1 = tabbable;
var immutable = extend;
var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
  var arguments$1 = arguments;
  var target = {};

  for (var i = 0; i < arguments.length; i++) {
    var source = arguments$1[i];

    for (var key in source) {
      if (hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
}

var activeFocusDelay;

var activeFocusTraps = function () {
  var trapQueue = [];
  return {
    activateTrap: function (trap) {
      if (trapQueue.length > 0) {
        var activeTrap = trapQueue[trapQueue.length - 1];

        if (activeTrap !== trap) {
          activeTrap.pause();
        }
      }

      var trapIndex = trapQueue.indexOf(trap);

      if (trapIndex === -1) {
        trapQueue.push(trap);
      } else {
        // move this existing trap to the front of the queue
        trapQueue.splice(trapIndex, 1);
        trapQueue.push(trap);
      }
    },
    deactivateTrap: function (trap) {
      var trapIndex = trapQueue.indexOf(trap);

      if (trapIndex !== -1) {
        trapQueue.splice(trapIndex, 1);
      }

      if (trapQueue.length > 0) {
        trapQueue[trapQueue.length - 1].unpause();
      }
    }
  };
}();

function focusTrap(element, userOptions) {
  var doc = document;
  var container = typeof element === 'string' ? doc.querySelector(element) : element;
  var config = immutable({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true
  }, userOptions);
  var state = {
    firstTabbableNode: null,
    lastTabbableNode: null,
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false
  };
  var trap = {
    activate: activate,
    deactivate: deactivate,
    pause: pause,
    unpause: unpause
  };
  return trap;

  function activate(activateOptions) {
    if (state.active) {
      return;
    }

    updateTabbableNodes();
    state.active = true;
    state.paused = false;
    state.nodeFocusedBeforeActivation = doc.activeElement;
    var onActivate = activateOptions && activateOptions.onActivate ? activateOptions.onActivate : config.onActivate;

    if (onActivate) {
      onActivate();
    }

    addListeners();
    return trap;
  }

  function deactivate(deactivateOptions) {
    if (!state.active) {
      return;
    }

    clearTimeout(activeFocusDelay);
    removeListeners();
    state.active = false;
    state.paused = false;
    activeFocusTraps.deactivateTrap(trap);
    var onDeactivate = deactivateOptions && deactivateOptions.onDeactivate !== undefined ? deactivateOptions.onDeactivate : config.onDeactivate;

    if (onDeactivate) {
      onDeactivate();
    }

    var returnFocus = deactivateOptions && deactivateOptions.returnFocus !== undefined ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate;

    if (returnFocus) {
      delay(function () {
        tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
      });
    }

    return trap;
  }

  function pause() {
    if (state.paused || !state.active) {
      return;
    }

    state.paused = true;
    removeListeners();
  }

  function unpause() {
    if (!state.paused || !state.active) {
      return;
    }

    state.paused = false;
    updateTabbableNodes();
    addListeners();
  }

  function addListeners() {
    if (!state.active) {
      return;
    } // There can be only one listening focus trap at a time


    activeFocusTraps.activateTrap(trap); // Delay ensures that the focused element doesn't capture the event
    // that caused the focus trap activation.

    activeFocusDelay = delay(function () {
      tryFocus(getInitialFocusNode());
    });
    doc.addEventListener('focusin', checkFocusIn, true);
    doc.addEventListener('mousedown', checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener('touchstart', checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener('click', checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener('keydown', checkKey, {
      capture: true,
      passive: false
    });
    return trap;
  }

  function removeListeners() {
    if (!state.active) {
      return;
    }

    doc.removeEventListener('focusin', checkFocusIn, true);
    doc.removeEventListener('mousedown', checkPointerDown, true);
    doc.removeEventListener('touchstart', checkPointerDown, true);
    doc.removeEventListener('click', checkClick, true);
    doc.removeEventListener('keydown', checkKey, true);
    return trap;
  }

  function getNodeForOption(optionName) {
    var optionValue = config[optionName];
    var node = optionValue;

    if (!optionValue) {
      return null;
    }

    if (typeof optionValue === 'string') {
      node = doc.querySelector(optionValue);

      if (!node) {
        throw new Error('`' + optionName + '` refers to no known node');
      }
    }

    if (typeof optionValue === 'function') {
      node = optionValue();

      if (!node) {
        throw new Error('`' + optionName + '` did not return a node');
      }
    }

    return node;
  }

  function getInitialFocusNode() {
    var node;

    if (getNodeForOption('initialFocus') !== null) {
      node = getNodeForOption('initialFocus');
    } else if (container.contains(doc.activeElement)) {
      node = doc.activeElement;
    } else {
      node = state.firstTabbableNode || getNodeForOption('fallbackFocus');
    }

    if (!node) {
      throw new Error('Your focus-trap needs to have at least one focusable element');
    }

    return node;
  }

  function getReturnFocusNode(previousActiveElement) {
    var node = getNodeForOption('setReturnFocus');
    return node ? node : previousActiveElement;
  } // This needs to be done on mousedown and touchstart instead of click
  // so that it precedes the focus event.


  function checkPointerDown(e) {
    if (container.contains(e.target)) {
      return;
    }

    if (config.clickOutsideDeactivates) {
      deactivate({
        returnFocus: !tabbable_1.isFocusable(e.target)
      });
      return;
    } // This is needed for mobile devices.
    // (If we'll only let `click` events through,
    // then on mobile they will be blocked anyways if `touchstart` is blocked.)


    if (config.allowOutsideClick && config.allowOutsideClick(e)) {
      return;
    }

    e.preventDefault();
  } // In case focus escapes the trap for some strange reason, pull it back in.


  function checkFocusIn(e) {
    // In Firefox when you Tab out of an iframe the Document is briefly focused.
    if (container.contains(e.target) || e.target instanceof Document) {
      return;
    }

    e.stopImmediatePropagation();
    tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
  }

  function checkKey(e) {
    if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
      e.preventDefault();
      deactivate();
      return;
    }

    if (isTabEvent(e)) {
      checkTab(e);
      return;
    }
  } // Hijack Tab events on the first and last focusable nodes of the trap,
  // in order to prevent focus from escaping. If it escapes for even a
  // moment it can end up scrolling the page and causing confusion so we
  // kind of need to capture the action at the keydown phase.


  function checkTab(e) {
    updateTabbableNodes();

    if (e.shiftKey && e.target === state.firstTabbableNode) {
      e.preventDefault();
      tryFocus(state.lastTabbableNode);
      return;
    }

    if (!e.shiftKey && e.target === state.lastTabbableNode) {
      e.preventDefault();
      tryFocus(state.firstTabbableNode);
      return;
    }
  }

  function checkClick(e) {
    if (config.clickOutsideDeactivates) {
      return;
    }

    if (container.contains(e.target)) {
      return;
    }

    if (config.allowOutsideClick && config.allowOutsideClick(e)) {
      return;
    }

    e.preventDefault();
    e.stopImmediatePropagation();
  }

  function updateTabbableNodes() {
    var tabbableNodes = tabbable_1(container);
    state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();
    state.lastTabbableNode = tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();
  }

  function tryFocus(node) {
    if (node === doc.activeElement) {
      return;
    }

    if (!node || !node.focus) {
      tryFocus(getInitialFocusNode());
      return;
    }

    node.focus();
    state.mostRecentlyFocusedNode = node;

    if (isSelectableInput(node)) {
      node.select();
    }
  }
}

function isSelectableInput(node) {
  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';
}

function isEscapeEvent(e) {
  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
}

function isTabEvent(e) {
  return e.key === 'Tab' || e.keyCode === 9;
}

function delay(fn) {
  return setTimeout(fn, 0);
}

var focusTrap_1 = focusTrap;
/*!
  * focus-trap-vue v0.0.4
  * (c) 2019 Eduardo San Martin Morote
  * @license MIT
  */
// import Component from 'vue-class-component'
// @ts-ignore

var FocusTrap = {
  // @ts-ignore
  props: {
    active: {
      // TODO: could be options for activate
      type: Boolean,
      default: true
    },
    escapeDeactivates: {
      type: Boolean,
      default: true
    },
    returnFocusOnDeactivate: {
      type: Boolean,
      default: true
    },
    allowOutsideClick: {
      type: Boolean,
      default: true
    },
    initialFocus: [String, Function],
    fallbackFocus: [String, Function]
  },
  model: {
    event: 'update:active',
    prop: 'active'
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$watch('active', function (active) {
      if (active) {
        // has no effect if already activated
        this$1.trap = focusTrap_1( // @ts-ignore
        this$1.$el, {
          escapeDeactivates: this$1.escapeDeactivates,
          allowOutsideClick: function () {
            return this$1.allowOutsideClick;
          },
          returnFocusOnDeactivate: this$1.returnFocusOnDeactivate,
          onActivate: function () {
            this$1.$emit('update:active', true);
            this$1.$emit('activate');
          },
          onDeactivate: function () {
            this$1.$emit('update:active', false);
            this$1.$emit('deactivate');
          },
          initialFocus: this$1.initialFocus || function () {
            return this$1.$el;
          },
          fallbackFocus: this$1.fallbackFocus
        });
        this$1.trap.activate();
      } else {
        this$1.trap && this$1.trap.deactivate();
      }
    }, {
      immediate: true
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.trap && this.trap.deactivate(); // @ts-ignore

    this.trap = null;
  },
  methods: {
    activate: function activate() {
      // @ts-ignore
      this.trap.activate();
    },
    deactivate: function deactivate() {
      // @ts-ignore
      this.trap.deactivate();
    }
  },
  render: function render() {
    var content = this.$slots.default;

    if (!content || !content.length || content.length > 1) {
      throw new Error('FocusTrap requires exactly one child');
    }

    return content[0];
  }
};
var props = {
  isOpen: Boolean,
  initialFocusRef: [utils.HTMLElement, Object, String, Function],
  finalFocusRef: [utils.HTMLElement, Object, String, Function],
  contentRef: [utils.HTMLElement, Object, String],
  blockScrollOnMount: {
    type: Boolean,
    default: true
  },
  closeOnEsc: {
    type: Boolean,
    default: true
  },
  closeOnOverlayClick: {
    type: Boolean,
    default: true
  },
  useInert: {
    type: Boolean,
    default: true
  },
  scrollBehavior: {
    type: props_types.StringArray,
    default: 'outside'
  },
  isCentered: Boolean,
  addAriaLabels: {
    type: [Boolean, Object],
    default: true
  },
  preserveScrollBarGap: Boolean,
  formatIds: {
    type: Function,
    default: function _default(id) {
      return {
        content: "modal-" + id,
        header: "modal-" + id + "-header",
        body: "modal-" + id + "-body"
      };
    }
  },
  container: utils.HTMLElement,
  returnFocusOnClose: {
    type: Boolean,
    default: true
  },
  id: String,
  size: {
    type: String,
    default: 'md'
  },
  onClose: {
    type: Function,
    default: function _default() {
      return null;
    }
  }
};
/**
 * Hey! Welcome to @chakra-ui/vue Menu
 *
 * The `CModal` is a dialog window overlaid on either the primary window or another dialog
 *  window. Contents behind a modal dialog are **inert** meaning that users cannot
 * interact with content behind the dialog.
 *
 * @see Docs     https://vue.chakra-ui.com/modal
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CModal/CModal.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CModal/accessibility.md
 */

function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * CModal component
 *
 * The wrapper for `CModal` components. It provides context and state for the modal.
 *
 * @extends CPortal
 * @see Docs https://vue.chakra-ui.com/modal
 */


var CModal = {
  name: 'CModal',
  props: props,
  data: function data() {
    return {
      addAriaLabelledby: false,
      addAriaDescribedby: false,
      modalNode: undefined,
      contentNode: undefined
    };
  },
  provide: function provide() {
    var this$1 = this;
    return {
      $ModalContext: function $ModalContext() {
        return this$1.ModalContext;
      }
    };
  },
  computed: {
    _id: function _id() {
      return this.id || utils.useId(4);
    },
    contentId: function contentId() {
      return this.formatIds(this._id).content;
    },
    headerId: function headerId() {
      return this.formatIds(this._id).header;
    },
    bodyId: function bodyId() {
      return this.formatIds(this._id).body;
    },
    modalId: function modalId() {
      return "modal-" + this._id;
    },
    portalTarget: function portalTarget() {
      return "#modal-portal-" + this._id;
    },
    ModalContext: function ModalContext() {
      return {
        isOpen: this.isOpen,
        initialFocusRef: this.initialFocusRef,
        onClose: this.onClose,
        blockScrollOnMount: this.blockScrollOnMount,
        closeOnEsc: this.closeOnEsc,
        closeOnOverlayClick: this.closeOnOverlayClick,
        returnFocusOnClose: this.returnFocusOnClose,
        contentNode: this.contentNode,
        scrollBehavior: this.scrollBehavior,
        isCentered: this.isCentered,
        size: this.size,
        headerId: this.headerId,
        bodyId: this.bodyId,
        contentId: this.contentId,
        addAriaLabelledby: this.addAriaLabelledby,
        addAriaDescribedby: this.addAriaDescribedby
      };
    }
  },
  mounted: function mounted() {
    var this$1 = this;

    if (utils._typeof(this.addAriaLabels) === 'object') {
      this.addAriaLabelledby = this.addAriaLabels.header;
      this.addAriaDescribedby = this.addAriaLabels.body;
    }

    if (typeof this.addAriaLabels === 'boolean') {
      this.addAriaLabelledby = this.addAriaLabels;
      this.addAriaDescribedby = this.addAriaLabels;
    }

    this.$nextTick(function () {
      this$1.modalNode = utils.getElById(this$1.modalId);
    });
    /**
     * Escape key press event handler for modal
     * @param {Event} event Keyboard Event
     */

    var handler = function handler(event) {
      if (event.key === 'Escape' && this$1.closeOnEsc) {
        this$1.onClose(event, 'pressedEscape');
      }
    };

    this.$watch(function (vm) {
      return [vm.isOpen, vm.blockScrollOnMount];
    }, function () {
      if (this$1.isOpen && !this$1.closeOnOverlayClick) {
        utils.canUseDOM && document.addEventListener('keydown', handler);
      } else {
        document.addEventListener('keydown', handler);
      }
    });
    this.$watch('isOpen', function () {
      if (!this$1.isOpen) {
        document.removeEventListener('keydown', handler);
      }
    });
    var undoAriaHidden = null;
    this.$watch(function (vm) {
      return [vm.isOpen, vm.useInert];
    }, function () {
      var mountNode = this$1.mountNode;

      if (this$1.isOpen && utils.canUseDOM) {
        if (this$1.useInert) {
          undoAriaHidden = hideOthers(mountNode);
        }

        this$1.contentNode = utils.getElById(this$1.contentId);
      } else if (this$1.useInert && undoAriaHidden != null) {
        undoAriaHidden();
      }
    });
  },
  methods: {
    /**
     * Handles focus trap activation
     */
    activateFocusLock: function activateFocusLock() {
      var this$1 = this;
      setTimeout(function () {
        if (this$1.initialFocusRef) {
          var initialFocusRef = utils.isFunction(this$1.initialFocusRef) ? this$1.getNode(this$1.initialFocusRef()) : this$1.getNode(this$1.initialFocusRef);

          if (initialFocusRef) {
            initialFocusRef.focus();
          }
        } else {
          var contentNode = utils.getElById(this$1.contentId);

          if (contentNode) {
            var focusables = utils.getFocusables(contentNode);

            if (focusables.length === 0) {
              contentNode.focus();
            } else {
              var el = focusables[0];
              el && el.focus();
            }
          }
        }
      });
    },

    /**
     * Handles focus trap deactivation
     */
    deactivateFocusLock: function deactivateFocusLock() {
      var this$1 = this;
      setTimeout(function () {
        if (this$1.finalFocusRef) {
          var finalFocusRef = utils.isFunction(this$1.finalFocusRef) ? this$1.getNode(this$1.finalFocusRef()) : this$1.getNode(this$1.finalFocusRef);

          if (finalFocusRef) {
            utils.canUseDOM && finalFocusRef.focus();
          } else {
            console.warn("[ChakraUI Modal]: Unable to locate final focus node \"" + this$1.finalFocusRef + "\".");
          }
        }
      });
    },

    /**
     * Gets the HTML element for a component or selector
     * @param {Object|String} element Element or selector
     */
    getNode: function getNode(element) {
      if (utils._typeof(element) === 'object') {
        var isVue = utils.isVueComponent(element);
        return isVue ? element.$el : element;
      } else if (typeof element === 'string') {
        return utils.getElement(element);
      }

      return null;
    }
  },
  render: function render(h) {
    var children = utils.cleanChildren(this.$slots.default);
    return h(CPortal.default, {
      props: {
        append: true,
        target: this.portalTarget,
        disabled: false,
        slim: true,
        unmountOnDestroy: true,
        targetSlim: true
      },
      attrs: {
        'data-chakra-component': 'CModal'
      }
    }, [h(FocusTrap, {
      props: {
        returnFocusOnDeactivate: this.returnFocusOnClose && !this.finalFocusRef,
        active: this.isOpen
      },
      on: {
        activate: this.activateFocusLock,
        deactivate: this.deactivateFocusLock
      }
    }, [h('div', {
      style: {
        position: 'relative'
      },
      directives: [{
        name: 'scroll-lock',
        value: this.isOpen && this.blockScrollOnMount
      }]
    }, [h(CTransition.CFade, {
      props: {
        enterEasing: 'easeInCubic',
        leaveEasing: 'easeOutCubic'
      }
    }, this.isOpen && [h('div', {
      style: {
        position: 'fixed',
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    }, children)])])])]);
  }
};
/**
 * CModalOverlay component
 *
 * The background overlay for the `CModal` component
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/modal
 */

var CModalOverlay = {
  name: 'CModalOverlay',
  functional: true,
  render: function render(h, ref) {
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["data"]);
    var rest = rest$1;
    return h(CBox.default, Object.assign({}, rest, {
      attrs: Object.assign({}, {
        pos: 'fixed',
        bg: 'rgba( 0, 0, 0, 0.4)',
        left: '0',
        top: '0',
        w: '100vw',
        h: '100vh',
        zIndex: 'overlay'
      }, data.attrs, {
        'data-chakra-component': 'CModalOverlay'
      })
    }));
  }
};
/**
 * CModalContent component
 *
 * The container for the CModal content
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/modal
 */

var CModalContent = {
  name: 'CModalContent',
  inheritAttrs: false,
  inject: ['$ModalContext', '$chakraColorMode'],
  props: {
    noStyles: Boolean,
    zIndex: {
      type: String,
      default: 'modal'
    }
  },
  data: function data() {
    return {
      colorModeStyles: {
        light: {
          bg: 'white',
          shadow: '0 7px 14px 0 rgba(0, 0, 0, 0.1), 0 3px 6px 0 rgba(0, 0, 0, .07)'
        },
        dark: {
          bg: 'gray.700',
          shadow: 'rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px',
          color: 'whiteAlpha.900'
        }
      },
      wrapperStyle: {},
      contentStyle: {}
    };
  },
  computed: {
    context: function context() {
      return this.$ModalContext();
    },
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    },
    boxStyleProps: function boxStyleProps() {
      return this.colorModeStyles[this.colorMode];
    },
    componentStyles: function componentStyles() {
      return Object.assign({}, this.wrapperStyle, {
        pos: 'fixed',
        left: '0',
        top: '0',
        w: '100%',
        h: '100%',
        zIndex: this.zIndex || 'modal'
      });
    }
  },
  created: function created() {
    var ref = this.context;
    var isCentered = ref.isCentered;
    var scrollBehavior = ref.scrollBehavior;
    var wrapperStyle = {};
    var contentStyle = {};

    if (isCentered) {
      wrapperStyle = {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      };
    } else {
      contentStyle = {
        top: '3.75rem',
        mx: 'auto'
      };
    }

    if (scrollBehavior === 'inside') {
      wrapperStyle = Object.assign({}, wrapperStyle, {
        maxHeight: 'calc(100vh - 7.5rem)',
        overflow: 'hidden',
        top: '3.75rem'
      });
      contentStyle = Object.assign({}, contentStyle, {
        height: '100%',
        top: 0
      });
    }

    if (scrollBehavior === 'outside') {
      wrapperStyle = Object.assign({}, wrapperStyle, {
        overflowY: 'auto',
        overflowX: 'hidden'
      });
      contentStyle = Object.assign({}, contentStyle, {
        my: '3.75rem',
        top: 0
      });
    }

    if (this.noStyles) {
      wrapperStyle = {};
      contentStyle = {};
    }

    this.wrapperStyle = wrapperStyle;
    this.contentStyle = contentStyle;
  },
  render: function render(h) {
    var this$1 = this;
    var ref = this.context;
    var onClose = ref.onClose;
    var bodyId = ref.bodyId;
    var headerId = ref.headerId;
    var contentId = ref.contentId;
    var size = ref.size;
    var closeOnEsc = ref.closeOnEsc;
    var addAriaLabelledby = ref.addAriaLabelledby;
    var addAriaDescribedby = ref.addAriaDescribedby;
    var closeOnOverlayClick = ref.closeOnOverlayClick;
    return h(CBox.default, {
      attrs: Object.assign({}, this.wrapperStyle, {
        pos: 'fixed',
        left: '0',
        top: '0',
        w: '100%',
        h: '100%',
        zIndex: this.zIndex || 'modal'
      }),
      on: {
        click: function click(event) {
          event.stopPropagation();

          if (closeOnOverlayClick) {
            onClose && onClose(event, 'clickedOverlay');
            this$1.$emit('clickedOverlay', event);
          }
        },
        keydown: function keydown(event) {
          if (event.key === 'Escape') {
            event.stopPropagation();

            if (closeOnEsc) {
              onClose(event, 'pressedEscape');
            }
          }
        }
      }
    }, [h(CBox.default, {
      props: {
        as: 'section'
      },
      attrs: Object.assign({}, {
        role: 'dialog',
        'aria-modal': 'true',
        tabindex: -1,
        id: contentId
      }, addAriaDescribedby && {
        'aria-describedby': bodyId
      }, addAriaLabelledby && {
        'aria-labelledby': headerId
      }, {
        outline: 0,
        maxWidth: size,
        w: '100%',
        pos: 'relative',
        d: 'flex',
        flexDir: 'column',
        zIndex: this.zIndex,
        fontFamily: 'body'
      }, this.boxStyleProps, this.contentStyle, {
        'data-chakra-component': 'CModalContent'
      }, this.$attrs),
      nativeOn: {
        click: utils.wrapEvent(function (e) {
          return this$1.$emit('click', e);
        }, function (event) {
          return event.stopPropagation();
        })
      }
    }, this.$slots.default)]);
  }
};
/**
 * CModalHeader component
 *
 * The header that labels the modal dialog
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/modal
 */

var CModalHeader = {
  name: 'CModalHeader',
  mixins: [utils.createStyledAttrsMixin('CModalHeader')],
  inject: ['$ModalContext'],
  computed: {
    context: function context() {
      return this.$ModalContext();
    },
    componentStyles: function componentStyles() {
      return {
        px: 6,
        py: 4,
        position: 'relative',
        fontSize: 'xl',
        fontWeight: 'semibold'
      };
    }
  },
  render: function render(h) {
    var ref = this.context;
    var headerId = ref.headerId;
    return h('header', {
      class: [this.className],
      attrs: Object.assign({}, {
        id: headerId
      }, this.computedAttrs),
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CModalFooter component
 *
 * The footer that houses the modal actions
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/modal
 */

var CModalFooter = {
  name: 'CModalFooter',
  functional: true,
  render: function render(h, ref) {
    var slots = ref.slots;
    var data = ref.data;
    return h(CBox.default, Object.assign({}, data, {
      attrs: Object.assign({}, {
        as: 'footer',
        display: 'flex',
        px: 6,
        py: 4,
        justifyContent: 'flex-end',
        'data-chakra-component': 'CModalFooter'
      }, data.attrs)
    }), slots().default);
  }
};
/**
 * CModalBody component
 *
 * The wrapper that houses the modal's main content
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/modal
 */

var CModalBody = {
  name: 'CModalBody',
  mixins: [utils.createStyledAttrsMixin('CModalBody')],
  inject: ['$ModalContext'],
  computed: {
    context: function context() {
      return this.$ModalContext();
    },
    componentStyles: function componentStyles() {
      var ref = this.context;
      var scrollBehavior = ref.scrollBehavior;
      var style = {};

      if (scrollBehavior === 'inside') {
        style = {
          overflowY: 'auto'
        };
      }

      return Object.assign({}, {
        px: 6,
        py: 2,
        flex: 1
      }, style);
    }
  },
  render: function render(h) {
    var ref = this.context;
    var bodyId = ref.bodyId;
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, {
        id: bodyId,
        'data-chakra-component': 'CModalBody'
      }, this.computedAttrs),
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CCloseButton component
 *
 * The button that closes the modal.
 *
 * @extends CCloseButton
 * @see Docs https://vue.chakra-ui.com/modal
 */

var CModalCloseButton = {
  name: 'CModalCloseButton',
  mixins: [utils.createStyledAttrsMixin('CModalCloseButton')],
  inject: ['$ModalContext'],
  props: closebutton_styles.closeButtonProps,
  computed: {
    context: function context() {
      return this.$ModalContext();
    },
    componentStyles: function componentStyles() {
      var colorMode = this.colorMode; // Pseudo styles

      var hoverColor = {
        light: 'blackAlpha.100',
        dark: 'whiteAlpha.100'
      };
      var activeColor = {
        light: 'blackAlpha.200',
        dark: 'whiteAlpha.200'
      }; // Size styles

      var buttonSize = closebutton_styles.sizes[this.size] && closebutton_styles.sizes[this.size].button;
      return Object.assign({}, {
        outline: 'none',
        h: buttonSize,
        w: buttonSize,
        disabled: this.isDisabled,
        cursor: 'pointer',
        _hover: {
          bg: hoverColor[colorMode]
        },
        _active: {
          bg: activeColor[colorMode]
        },
        position: 'absolute',
        top: '8px',
        right: '12px'
      }, closebutton_styles.baseProps);
    }
  },
  render: function render(h) {
    var this$1 = this;
    var ref = this.context;
    var onClose = ref.onClose;
    var iconSize = closebutton_styles.sizes[this.size] && closebutton_styles.sizes[this.size].icon;
    return h('button', {
      class: [this.className],
      attrs: Object.assign({}, {
        'data-chakra-component': 'CModalCloseButton'
      }, this.computedAttrs, {
        'aria-label': this.ariaLabel,
        'aria-disabled': this.isDisabled
      }),
      on: Object.assign({}, this.computedListeners, {
        click: function click(e) {
          utils.wrapEvent(onClose, function (event) {
            return this$1.$emit('click', event);
          })(e);
        }
      }, this.computedListeners)
    }, [h(CIcon.CIcon, {
      props: {
        color: props.color,
        name: 'close',
        size: iconSize
      },
      attrs: {
        focusable: false,
        'aria-hidden': true
      }
    })]);
  }
};
exports.CModal = CModal;
exports.CModalBody = CModalBody;
exports.CModalCloseButton = CModalCloseButton;
exports.CModalContent = CModalContent;
exports.CModalFooter = CModalFooter;
exports.CModalHeader = CModalHeader;
exports.CModalOverlay = CModalOverlay;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


var utils = __webpack_require__(2);
/**
 * @description Converts a string variable to hex code.
 * @param {String} str
 * @note Found this on ChakraUI and StackOverflow :D
 * @returns {String}
 */


function string2Hex(str) {
  var hash = 0;

  if (str.length === 0) {
    return hash;
  }

  for (var i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
    hash = hash & hash;
  }

  var color = '#';

  for (var j = 0; j < 3; j++) {
    var value = hash >> j * 8 & 255;
    color += ('00' + value.toString(16)).substr(-2);
  }

  return color;
}

var avatarSizes = {
  '2xs': 4,
  xs: 6,
  sm: 8,
  md: 12,
  lg: 16,
  xl: 24,
  '2xl': 32,
  full: 'full'
};
/**
 * @description Evaluate style props for avatar
 * @param {{ size: String, name: String, showBorder: Boolean, borderColor: String, theme: Function colorMode: String }} param0
 * @returns {Object} Style props object
 */

function useAvatarStyles(ref) {
  var size = ref.size;
  var name = ref.name;
  var showBorder = ref.showBorder;
  var borderColor = ref.borderColor;
  var theme = ref.theme;
  var colorMode = ref.colorMode;
  var colors = theme.colors;
  var bg = name ? string2Hex(name) : colors.gray[400];
  var color = name ? utils.isDarkColor(bg) ? '#fff' : 'gray.800' : '#fff';
  var _borderColor = {
    light: '#fff',
    dark: 'gray.800'
  };
  var baseProps = {
    display: 'inline-flex',
    rounded: 'full',
    alignItems: 'center',
    flexShrink: '0',
    justifyContent: 'center',
    position: 'relative'
  };
  return Object.assign({}, baseProps, {
    w: avatarSizes[size],
    h: avatarSizes[size],
    bg: bg,
    color: color
  }, showBorder && {
    border: '2px',
    borderColor: borderColor || _borderColor[colorMode]
  });
}

exports.avatarSizes = avatarSizes;
exports.useAvatarStyles = useAvatarStyles;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

var css = __webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CVisuallyHidden = __webpack_require__(18);

var templateObject = Object.freeze(["\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n"]);
var spin = css.keyframes(templateObject);
var sizes = {
  xs: {
    w: '0.75rem',
    h: '0.75rem'
  },
  sm: {
    w: '1rem',
    h: '1rem'
  },
  md: {
    w: '1.5rem',
    h: '1.5rem'
  },
  lg: {
    w: '2rem',
    h: '2rem'
  },
  xl: {
    w: '3rem',
    h: '3rem'
  }
};

var createCustomSize = function createCustomSize(size) {
  return {
    w: size,
    h: size
  };
};

var setSizes = function setSizes(props) {
  return sizes[props.size] || createCustomSize(props.size);
};
/**
 * CSpinner component
 *
 * The spinner componenet
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/spinner
 */


var CSpinner = {
  name: 'CSpinner',
  mixins: [utils.createStyledAttrsMixin('CSpinner')],
  props: {
    size: {
      type: [String, Array],
      default: 'md'
    },
    label: {
      type: String,
      default: 'Loading...'
    },
    thickness: {
      type: [String, Array],
      default: '2px'
    },
    speed: {
      type: [String, Array],
      default: '0.45s'
    },
    color: {
      type: [String, Array],
      default: 'gray.200'
    },
    emptyColor: {
      type: [String, Array],
      default: 'transparent'
    }
  },
  computed: {
    componentStyles: function componentStyles() {
      return Object.assign({}, {
        d: 'inline-block',
        borderWidth: this.thickness,
        borderColor: 'currentColor',
        borderStyle: 'solid',
        rounded: 'full',
        color: this.color,
        borderBottomColor: this.emptyColor,
        borderLeftColor: this.emptyColor,
        animation: spin + " " + this.speed + " linear infinite"
      }, setSizes(this.$props));
    }
  },
  render: function render(h) {
    return h('div', {
      class: this.className,
      attrs: this.computedAttrs
    }, this.label && h(CVisuallyHidden.default, {}, this.label));
  }
};
exports.default = CSpinner;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


var utils = __webpack_require__(2);

var CBox = __webpack_require__(5);

var CIcon = __webpack_require__(9);

var CSpinner = __webpack_require__(68);

var baseStyles = {
  display: 'inline-flex',
  appearance: 'none',
  alignItems: 'center',
  justifyContent: 'center',
  transition: 'all 250ms',
  userSelect: 'none',
  position: 'relative',
  whiteSpace: 'nowrap',
  verticalAlign: 'middle',
  lineHeight: '1.2',
  outline: 'none',
  fontWeight: 'bold',
  rounded: 'md'
};
var disabledProps = {
  _disabled: {
    opacity: '0.4',
    cursor: 'not-allowed',
    boxShadow: 'none'
  }
};
var buttonSizes = {
  xs: {
    w: '0.75rem',
    h: '0.75rem'
  },
  sm: {
    w: '1rem',
    h: '1rem'
  },
  md: {
    w: '1.5rem',
    h: '1.5rem'
  },
  lg: {
    w: '2rem',
    h: '2rem'
  },
  xl: {
    w: '3rem',
    h: '3rem'
  }
};

var createCustomSize = function createCustomSize(size) {
  return {
    w: size,
    h: size
  };
};

var unstyledStyle = {
  userSelect: 'inherit',
  bg: 'none',
  border: 0,
  color: 'inherit',
  display: 'inline',
  font: 'inherit',
  lineHeight: 'inherit',
  m: 0,
  p: 0,
  textAlign: 'inherit'
};
/**
 * @description Evaluates button icon sizes and returns wight and height parameters
 * @param {Object} props
 */

var setIconSizes = function setIconSizes(props) {
  return buttonSizes[props.size] || createCustomSize(props.size);
};
/**
 * Size values
 */


var sizes = {
  lg: {
    h: 12,
    minW: 12,
    fontSize: 'lg',
    px: 6
  },
  md: {
    h: 10,
    minW: 10,
    fontSize: 'md',
    px: 4
  },
  sm: {
    h: 8,
    minW: 8,
    fontSize: 'sm',
    px: 3
  },
  xs: {
    h: 6,
    minW: 6,
    fontSize: 'xs',
    px: 2
  }
};
/**
 * @description Determines size props
 * @param {Object} param0 Props object
 * @returns {Object} Size style props
 */

var sizeProps = function sizeProps(ref) {
  var size = ref.size;
  return sizes[size];
};

var graySolidStyle = {
  light: {
    bg: 'gray.100',
    _hover: {
      bg: 'gray.200'
    },
    _active: {
      bg: 'gray.300'
    }
  },
  dark: {
    bg: 'whiteAlpha.200',
    _hover: {
      bg: 'whiteAlpha.300'
    },
    _active: {
      bg: 'whiteAlpha.400'
    }
  }
};
/**
 * @description Get solid button style values
 * @param {Object} props - Style props object
 * @returns {Object} - Solid styles object
 */

var getSolidStyles = function getSolidStyles(ref) {
  var color = ref.color;
  var colorMode = ref.colorMode;
  var style = {
    light: {
      bg: color + ".400",
      color: 'white',
      _hover: {
        bg: color + ".500"
      },
      _active: {
        bg: color + ".600"
      }
    },
    dark: {
      bg: color + ".200",
      color: 'gray.800',
      _hover: {
        bg: color + ".300"
      },
      _active: {
        bg: color + ".400"
      }
    }
  };

  if (color === 'gray') {
    style = graySolidStyle;
  }

  return style[colorMode];
};
/**
 * @description Get ghost button style values
 * @param {Object} props - Style Props
 * @returns {Object} - Ghost styles object
 */


var getGhostStyles = function getGhostStyles(ref) {
  var color = ref.color;
  var colorMode = ref.colorMode;
  var theme = ref.theme;

  var _color = theme.colors[color] && theme.colors[color][200];

  var result = {
    light: {
      color: color + ".500",
      bg: 'transparent',
      _hover: {
        bg: color + ".50"
      },
      _active: {
        bg: color + ".100"
      }
    },
    dark: {
      color: color + ".200",
      bg: 'transparent',
      _hover: {
        bg: utils.addOpacity(_color, 0.12)
      },
      _active: {
        bg: utils.addOpacity(_color, 0.24)
      }
    }
  };
  return result[colorMode];
};
/**
 * @description Get flat button style values
 * @param {Object} props - Style Props
 * @returns {Object} - Ghost styles object
 */


var getFlatStyles = function getFlatStyles(ref) {
  var color = ref.color;
  var colorMode = ref.colorMode;
  var theme = ref.theme;

  var _color = theme.colors[color] && theme.colors[color][200];

  var result = {
    light: {
      color: color + ".400",
      bg: 'transparent',
      _hover: {
        bg: color + ".50"
      },
      _active: {
        bg: color + ".100"
      }
    },
    dark: {
      color: color + ".200",
      bg: 'transparent',
      _hover: {
        bg: utils.addOpacity(_color, 0.12)
      },
      _active: {
        bg: utils.addOpacity(_color, 0.24)
      }
    }
  };
  return result[colorMode];
};
/**
 * @description Get outline button style values
 * @param {Object} props - Style props object
 * @returns {Object} - Solid styles object
 */


var getOutlineStyles = function getOutlineStyles(props) {
  var color = props.color;
  var colorMode = props.colorMode;
  var borderColor = {
    light: 'gray.200',
    dark: 'whiteAlpha.300'
  };
  return Object.assign({}, {
    border: '1px',
    borderColor: color === 'gray' ? borderColor[colorMode] : 'current'
  }, getFlatStyles(props));
};
/**
 * @description Get link button style values
 * @param {Object} props - Style props object
 * @returns {Object} - Solid styles object
 */


var getLinkStyles = function getLinkStyles(ref) {
  var color = ref.color;
  var colorMode = ref.colorMode;
  var _color = {
    light: color + ".400",
    dark: color + ".200"
  };
  var _activeColor = {
    light: color + ".700",
    dark: color + ".500"
  };
  return {
    p: 0,
    height: 'auto',
    lineHeight: 'normal',
    color: _color[colorMode],
    _hover: {
      textDecoration: 'underline'
    },
    _active: {
      color: _activeColor[colorMode]
    }
  };
};
/**
 * @description Determines styles for a given v
 * @param {Object} props - Props Object
 * @returns {Object} - Variant styles object
 */


var getVariantStyles = function getVariantStyles(props) {
  switch (props.variant) {
    case 'solid':
      return getSolidStyles(props);

    case 'outline':
      return getOutlineStyles(props);

    case 'ghost':
      return getGhostStyles(props);

    case 'flat':
      return getFlatStyles(props);

    case 'link':
      return getLinkStyles(props);

    case 'unstyled':
      return unstyledStyle;

    default:
      return graySolidStyle;
  }
};
/**
 * Button focus styles
 */


var focusStyles = {
  _focus: {
    outline: 'none',
    boxShadow: 'outline'
  }
};
/**
 * @description Generates Button styles based on passed variant props and theme colors.
 * @param {{color: String|Array<String>, theme: Object, colorMode: String, size: String|Array<String>}} props - Style props object
 * @returns {Object} Style object to be passed to styled component
 * @todo Pass the `theme` from the ThemeProvider context. Will need to create a context provider for theme.
 */

var createButtonStyles = function createButtonStyles(props) {
  return Object.assign({}, baseStyles, focusStyles, sizeProps(props), getVariantStyles(props), disabledProps);
};

var buttonProps = {
  as: {
    type: [String, Object],
    default: 'button'
  },
  to: [String, Object],
  type: {
    type: String,
    default: 'button'
  },
  variant: {
    type: String,
    default: 'solid',
    validator: function validator(value) {
      return value.match(/^(solid|outline|ghost|flat|link|unstyled)$/);
    }
  },
  variantColor: {
    type: [String, Array],
    default: 'gray'
  },
  isDisabled: {
    type: Boolean,
    default: false
  },
  isLoading: {
    type: Boolean,
    default: false
  },
  isActive: {
    type: Boolean,
    default: false
  },
  size: {
    type: String,
    default: 'md',
    validator: function validator(value) {
      return value.match(/^(xs|sm|md|lg|xl)$/);
    }
  },
  loadingText: {
    type: String,
    default: null
  },
  iconSpacing: {
    type: [String, Number],
    default: '1'
  },
  leftIcon: {
    type: String,
    default: null
  },
  rightIcon: {
    type: String,
    default: null
  }
};
/**
 * Hey! Welcome to @chakra-ui/vue Button
 *
 * Button component is used to trigger an action or event, such as
 * submitting a form, opening a Dialog, canceling an action, or
 * performing a delete operation
 *
 * @see Docs     https://vue.chakra-ui.com/button
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CButton/CButton.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CButton/accessibility.md
 * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#button
 */

/**
 * CButtonIcon component
 *
 * The icon component inside a button
 *
 * @extends CIcon
 * @see Docs https://vue.chakra-ui.com/button
 */

var CButtonIcon = {
  mixins: [utils.createStyledAttrsMixin('CButtonIcon')],
  props: {
    icon: {
      type: [String, Object]
    },
    size: {
      type: [String, Number]
    }
  },
  render: function render(h) {
    if (typeof this.icon === 'string') {
      return h(CIcon.CIcon, {
        class: this.className,
        props: {
          name: this.icon
        },
        attrs: Object.assign({}, {
          color: 'currentColor',
          focusable: false
        }, setIconSizes(this.$props), this.computedAttrs)
      });
    } else {
      return h(CBox.default, {
        class: this.className,
        props: {
          as: this.icon
        },
        attrs: Object.assign({}, setIconSizes(this.$props), {
          color: 'currentColor',
          'data-custom-icon': true
        }, this.computedAttrs, {
          focusable: false
        })
      });
    }
  }
};
/**
 * CButton component
 *
 * The Button component is an accessible rich component that does what a button does :)
 *
 * @see Docs https://vue.chakra-ui.com/button
 */

var CButton = {
  name: 'CButton',
  mixins: [utils.createStyledAttrsMixin('CButton')],
  props: buttonProps,
  computed: {
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    },
    theme: function theme() {
      return this.$chakraTheme();
    },
    componentStyles: function componentStyles() {
      return createButtonStyles({
        color: this.variantColor,
        variant: this.variant,
        theme: this.theme,
        ripple: this.ripple,
        colorMode: this.colorMode,
        size: this.size || 'md'
      });
    }
  },
  render: function render(h) {
    var this$1 = this;
    return h(this.as, {
      class: this.className,
      props: this.$props,
      attrs: Object.assign({}, {
        type: this.type,
        tabindex: 0,
        disabled: this.isDisabled || this.isLoading,
        'aria-disabled': this.isDisabled || this.isLoading,
        dataActive: this.isActive ? 'true' : undefined
      }, this.computedAttrs),
      on: {
        click: function click($event) {
          return this$1.$emit('click', $event);
        }
      }
    }, [this.leftIcon && h(CButtonIcon, {
      props: {
        icon: this.leftIcon
      },
      attrs: {
        mr: this.iconSpacing,
        mb: 'px',
        icon: this.leftIcon,
        size: '1em',
        opacity: this.isLoading ? 0 : 1
      }
    }), this.isLoading && h(CSpinner.default, {
      attrs: {
        position: this.loadingText ? 'relative' : 'absolute',
        color: 'currentColor',
        mb: '-4px',
        mr: this.loadingText ? this.iconSpacing : 0,
        size: '1em'
      }
    }), this.isLoading ? this.loadingText || h(CBox.default, {
      props: {
        as: 'span'
      },
      attrs: {
        opacity: 0
      }
    }, this.$slots.default) : this.$slots.default, this.rightIcon && h(CButtonIcon, {
      props: {
        icon: this.rightIcon
      },
      attrs: {
        ml: this.iconSpacing,
        mb: 'px',
        size: '1em',
        opacity: this.isLoading ? 0 : 1
      }
    })]);
  }
};
exports.CButton = CButton;
exports.buttonProps = buttonProps;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


var utils = __webpack_require__(2);

var baseProps = {
  userSelect: 'none',
  border: '2px',
  rounded: 'md',
  borderColor: 'inherit',
  transition: 'background-color 120ms, box-shadow 250ms'
};

var interactionProps = function interactionProps(ref) {
  var color = ref.color;
  var colorMode = ref.colorMode;
  var isDarkMode = colorMode === 'dark';

  var _color = isDarkMode ? 200 : 500;

  return {
    color: 'white',
    _checked: {
      bg: utils.get(color, _color),
      borderColor: utils.get(color, _color),
      color: isDarkMode ? 'gray.900' : undefined
    },
    _checkedAndDisabled: {
      borderColor: isDarkMode ? 'transparent' : 'gray.200',
      bg: isDarkMode ? 'whiteAlpha.300' : 'gray.200',
      color: isDarkMode ? 'whiteAlpha.500' : 'gray.500'
    },
    _disabled: {
      bg: isDarkMode ? 'whiteAlpha.100' : 'gray.100',
      borderColor: isDarkMode ? 'transparent' : 'gray.100'
    },
    _focus: {
      boxShadow: 'outline'
    },
    _invalid: {
      borderColor: isDarkMode ? 'red.300' : 'red.500'
    }
  };
};
/**
 * Creates checkbox styles
 * @param {{colorMode: String, size: String, color: String, type: String}} props
 */


var useCheckboxStyle = function useCheckboxStyle(props) {
  var sizes = {
    lg: 5,
    md: 4,
    sm: props.type === 'radio' ? 3 : 'auto'
  };
  return Object.assign({}, baseProps, props.size && {
    rounded: 'sm'
  }, interactionProps(props), {
    size: sizes[props.size]
  });
};

exports.useCheckboxStyle = useCheckboxStyle;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(159);
} else {}

/***/ }),
/* 72 */
/***/ (function(module, exports) {

module.exports = require("vue-client-only");

/***/ }),
/* 73 */
/***/ (function(module, exports) {

module.exports = require("vue-router");

/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63);

/** Detect free variable `exports`. */

var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

/* harmony default export */ __webpack_exports__["a"] = (nodeUtil);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(90)(module)))

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ addStylesServer; });

// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/listToStyles.js
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}

// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/addStylesServer.js


function addStylesServer (parentId, list, isProduction, context) {
  if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
    context = __VUE_SSR_CONTEXT__
  }
  if (context) {
    if (!context.hasOwnProperty('styles')) {
      Object.defineProperty(context, 'styles', {
        enumerable: true,
        get: function() {
          return renderStyles(context._styles)
        }
      })
      // expose renderStyles for vue-server-renderer (vuejs/#6353)
      context._renderStyles = renderStyles
    }

    var styles = context._styles || (context._styles = {})
    list = listToStyles(parentId, list)
    if (isProduction) {
      addStyleProd(styles, list)
    } else {
      addStyleDev(styles, list)
    }
  }
}

// In production, render as few style tags as possible.
// (mostly because IE9 has a limit on number of style tags)
function addStyleProd (styles, list) {
  for (var i = 0; i < list.length; i++) {
    var parts = list[i].parts
    for (var j = 0; j < parts.length; j++) {
      var part = parts[j]
      // group style tags by media types.
      var id = part.media || 'default'
      var style = styles[id]
      if (style) {
        if (style.ids.indexOf(part.id) < 0) {
          style.ids.push(part.id)
          style.css += '\n' + part.css
        }
      } else {
        styles[id] = {
          ids: [part.id],
          css: part.css,
          media: part.media
        }
      }
    }
  }
}

// In dev we use individual style tag for each module for hot-reload
// and source maps.
function addStyleDev (styles, list) {
  for (var i = 0; i < list.length; i++) {
    var parts = list[i].parts
    for (var j = 0; j < parts.length; j++) {
      var part = parts[j]
      styles[part.id] = {
        ids: [part.id],
        css: part.css,
        media: part.media
      }
    }
  }
}

function renderStyles (styles) {
  var css = ''
  for (var key in styles) {
    var style = styles[key]
    css += '<style data-vue-ssr-id="' + style.ids.join(' ') + '"' +
        (style.media ? ( ' media="' + style.media + '"' ) : '') + '>' +
        style.css + '</style>'
  }
  return css
}


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(98);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add CSS to SSR context
var add = __webpack_require__(76).default
module.exports.__inject__ = function (context) {
  add("1a25bb1a", content, true, context)
};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(100);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add CSS to SSR context
var add = __webpack_require__(76).default
module.exports.__inject__ = function (context) {
  add("1a73ea6b", content, true, context)
};

/***/ }),
/* 79 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

var clickoutside_directive = __webpack_require__(25);

var css = __webpack_require__(1);

var Css = __webpack_require__(81);

__webpack_require__(0);

__webpack_require__(3);
/** Purify Chakra attributes */


var purifyAttrs = function purifyAttrs(el, props) {
  for (var attr in props) {
    el.removeAttribute(attr);
    el.removeAttribute(utils.kebabify(attr));
  }
};
/** Purify's Chakra Attributes from VNode object */


var purifyVNodeAttrs = function purifyVNodeAttrs(vnode, props) {
  if (props && vnode.data.attrs) {
    for (var attr in props) {
      delete vnode.data.attrs[utils.kebabify(attr)];
    }
  }
};
/** Creates SSR `v-chakra` directive for Nuxt */


function createServerDirective(theme) {
  /** Applies server-side className */
  var applyServerClassName = function applyServerClassName(vnode, className, styleAttrs) {
    if (vnode.data.class) {
      vnode.data.class += " " + className;
    } else {
      vnode.data.class = className;
    }
    /**
     * Only remove style attributes
     * from VNode if directive has no
     * arguments
     **/


    if (styleAttrs) {
      purifyVNodeAttrs(vnode, styleAttrs);
    }
  };

  return function (vnode, directive) {
    var ref = utils.extractChakraAttrs(vnode.data.attrs);
    var styleAttrs = ref.styleAttrs;
    var className = css.css(Css.default(styleAttrs)(theme));
    applyServerClassName(vnode, className, styleAttrs);

    if (directive.value) {
      if (utils._typeof(directive.value) === 'object') {
        var className$1 = css.css(Css.default(directive.value)(theme));
        applyServerClassName(vnode, className$1);
      }

      if (typeof directive.value === 'function') {
        var styles = directive.value(theme);
        var className$2 = css.css(Css.default(styles)(theme));
        applyServerClassName(vnode, className$2);
      }
    }
  };
}
/** Creates Client `v-chakra` Directive */


function createClientDirective(theme) {
  function applyClientStyles(el, binding, vnode) {
    var ref = utils.extractChakraAttrs(vnode.data.attrs);
    var styleAttrs = ref.styleAttrs;
    var className = css.css(Css.default(styleAttrs)(theme));
    el.classList.add(className);
    purifyAttrs(el, styleAttrs);

    if (binding.value) {
      if (utils._typeof(binding.value) === 'object') {
        var className$1 = css.css(Css.default(binding.value)(theme));
        el.classList.add(className$1);
      }

      if (typeof binding.value === 'function') {
        var styles = binding.value(theme);
        var className$2 = css.css(Css.default(styles)(theme));
        el.classList.add(className$2);
      }
    }
  }

  return {
    bind: applyClientStyles,
    update: applyClientStyles,
    componentUpdated: applyClientStyles,
    unbind: applyClientStyles
  };
}

exports.ClickOutsideDirective = clickoutside_directive.ClickOutside;
exports.createClientDirective = createClientDirective;
exports.createServerDirective = createServerDirective;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var chakraUiStyledSystem_esm = __webpack_require__(4);
/**
 * Build a CSS factory function, to create CSS object by given a theme
 * @param {Object} styleProps Styles object
 * @returns {Function} (theme) => CSSStyleObject
 */


var buildCssFn = function buildCssFn(styleProps) {
  return chakraUiStyledSystem_esm.css(styleProps);
};

exports.default = buildCssFn;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

var utils = __webpack_require__(2);

var chakraUiStyledSystem_esm = __webpack_require__(4);

__webpack_require__(8);

__webpack_require__(1);

var Vue = _interopDefault(__webpack_require__(0));

var colorModeObserver = __webpack_require__(3);

var anime_es = __webpack_require__(14);

var CBox = __webpack_require__(5);

__webpack_require__(9);

var CAlert = __webpack_require__(83);

__webpack_require__(12);

__webpack_require__(16);

var CCloseButton = __webpack_require__(65);

var CThemeProvider = __webpack_require__(84);

var CColorModeProvider = __webpack_require__(85);

var Alert_1 = chakraUiStyledSystem_esm.createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Close = exports.Alert = void 0;
  var Alert = {
    name: 'Alert',
    props: {
      id: [String, Number],
      title: [String, Object],
      close: Function,
      clear: Function,
      reset: Function
    },
    render: function render(h) {
      return h('span', {
        class: ['Breadstick__alert'],
        attrs: {
          id: this.id
        },
        on: {
          mouseenter: this.clear,
          mouseleave: this.reset
        }
      }, [typeof title === 'string' ? h('div', {
        class: ['Breadstick__alert_text']
      }, this.title) : this.title, !this.title && this.$slots.default, this.close && h(Close, {
        props: {
          close: this.close
        }
      })]);
    }
  };
  exports.Alert = Alert;
  var Close = {
    name: 'Close',
    props: {
      close: {
        type: Function,
        default: function _default() {
          return null;
        }
      }
    },
    render: function render(h) {
      return h('button', {
        class: ['Breadstick__alert_close'],
        attrs: {
          type: 'button',
          'aria-label': this.close
        },
        on: {
          click: this.close
        }
      }, [h('span', {
        attrs: {
          'aria-hidden': true
        }
      }, '×')]);
    }
  };
  exports.Close = Close;
});
chakraUiStyledSystem_esm.unwrapExports(Alert_1);
var Alert_2 = Alert_1.Close;
var Alert_3 = Alert_1.Alert;
var Message_1 = chakraUiStyledSystem_esm.createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  /**
   * Message component
   */

  var Message = {
    name: 'Message',
    props: {
      id: {
        type: Number,
        default: null
      },
      message: {
        type: [String, Function, Object],
        default: null
      },
      position: {
        type: String
      },
      requestClose: {
        type: Boolean,
        default: false
      },
      duration: {
        type: Number,
        default: 5000
      }
    },
    data: function data() {
      return {
        timeout: undefined
      };
    },
    mounted: function mounted() {
      this.createTimeout();
    },
    methods: {
      close: function close() {
        this.$emit('remove', {
          id: this.id,
          position: this.position
        });
        clearTimeout(this.timeout);
      },
      onMouseEnter: function onMouseEnter() {
        if (this.timeout) {
          clearTimeout(this.timeout);
        }
      },
      onMouseLeave: function onMouseLeave() {
        this.createTimeout();
      },
      createTimeout: function createTimeout() {
        this.timeout = setTimeout(this.close, this.duration);
        return this.timeout;
      },
      renderMessage: function renderMessage(h) {
        // The returned message is a string
        if (typeof this.message === 'string') {
          return h(Alert_1.Alert, {
            attrs: {
              id: this.id
            },
            props: {
              clear: this.onMouseEnter,
              reset: this.onMouseLeave,
              title: this.message,
              close: this.close
            }
          }, this.message);
        } // The returned message is a function with Vue's render function callback


        if (typeof this.message === 'function') {
          var message = this.message({
            h: h,
            id: this.id,
            onClose: this.close
          });
          return h('span', {
            on: {
              mouseenter: this.onMouseEnter,
              mouseleave: this.onMouseLeave
            }
          }, [message]);
        } // The returned message is a component VNode


        if (this.message.constructor && this.message.constructor.name === 'VNode') {
          return h('span', {
            on: {
              'mouseenter': this.onMouseEnter,
              'mouseleave': this.onMouseLeave
            }
          }, [this.message]);
        }

        return null;
      }
    },
    render: function render(h) {
      return h('span', {}, [this.renderMessage(h)]);
    }
  };
  var _default = Message;
  exports.default = _default;
});
chakraUiStyledSystem_esm.unwrapExports(Message_1);
var BreadstickManager_1 = chakraUiStyledSystem_esm.createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _animejs = _interopRequireDefault(anime_es.anime);

  var _Message = _interopRequireDefault(Message_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);

      if (enumerableOnly) {
        symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }

      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread(target) {
    var arguments$1 = arguments;

    for (var i = 1; i < arguments.length; i++) {
      var source = arguments$1[i] != null ? arguments$1[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var positions = {
    top: [],
    'top-left': [],
    'top-right': [],
    'bottom-left': [],
    bottom: [],
    'bottom-right': []
  };
  /**
   * @description Compute styles for specific position
   * @param {String} position
   * @returns {Object} Styles object
   */

  var computeBreadstickStyle = function computeBreadstickStyle(position) {
    var style = {
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center'
    };

    if (position.includes('right')) {
      style.alignItems = 'flex-end';
    } else if (position.includes('left')) {
      style.alignItems = 'flex-start';
    }

    return style;
  };
  /**
   * Breadstick Animations
   */


  var animations = {
    enter: function enter(el) {
      var height = el.clientHeight;
      return {
        height: [0, height],
        opacity: [0, 1],
        scale: [0.9, 1]
      };
    },
    leave: {
      height: 0,
      opacity: [1, 0],
      scale: [1, 0.9]
    }
  };
  /**
   * Breadstick component
   */

  var BreadstickManager = {
    name: 'BreadstickManager',
    data: function data() {
      return {
        idCounter: 0,
        positions: positions
      };
    },
    props: {
      notify: Function,
      default: function _default() {
        return null;
      }
    },
    created: function created() {
      this.notify(this._notify, this.closeAll);
    },
    methods: {
      /**
       * @description Creates toast state for single toast notification
       * @param {Object|Vue.Component|String} message
       * @param {Object} options
       * @returns {Object} Toast state object
       */
      createToastState: function createToastState(message, options) {
        var _this = this;

        var id = ++this.idCounter; // a bit messy, but object.position returns a number because
        // it's a method argument.

        var position = options.hasOwnProperty('position') && typeof options.position === 'string' ? options.position : 'top';
        return {
          id: id,
          message: message,
          position: position,
          showing: true,
          duration: typeof options.duration === 'undefined' ? 5000 : options.duration,
          onRequestRemove: function onRequestRemove() {
            return _this.removeToast(String(id), position);
          },
          type: options.type
        };
      },

      /**
       * @description Shows notification
       * @param {Object|Vue.Component|String} message
       * @param {Object} options
       */
      _notify: function _notify(message, options) {
        var toast = this.createToastState(message, options);
        var position = toast.position; // prepend the toast for toasts positioned at the top of
        // the screen, otherwise append it.

        var isTop = position.includes('top');
        isTop ? this.positions[position].unshift(toast) : this.positions[position].push(toast);
      },

      /**
       * @description Close all toast components
       */
      closeAll: function closeAll() {
        var _this2 = this;

        Object.keys(this.positions).forEach(function (pos) {
          var position = _this2.positions[pos];
          position.forEach(function (toast) {
            _this2.removeToast(toast.id, pos);
          });
        });
      },

      /**
       * @description Remove toast from position list
       * @param {String} id
       * @param {String} position
       */
      removeToast: function removeToast(id, position) {
        this.positions[position] = this.positions[position].filter(function (toast) {
          return toast.id !== id;
        });
        return this.positions[position];
      },

      /**
      * @description Compute styles for  toast component
      * @param {String} position
      */
      getStyle: function getStyle(position) {
        var style = {
          width: 'fit-content',
          position: 'fixed',
          zIndex: 5500
        };

        if (position === 'top' || position === 'bottom') {
          style.margin = '0 auto';
          style.textAlign = 'center';
        }

        if (position.includes('top')) {
          style.top = 0;
        }

        if (position.includes('bottom')) {
          style.bottom = 0;
        }

        if (!position.includes('left')) {
          style.right = 0;
        }

        if (!position.includes('right')) {
          style.left = 0;
        }

        return style;
      },

      /**
       * @description Get animation for transition
       * @param {String} key Type of animation phase
       * @param {HTMLElement} el Element
       */
      getAnimation: function getAnimation(key, el) {
        var animation = animations[key];
        return typeof animation === 'function' ? animation.call(this, el) : animation;
      },

      /**
       * @description Calls enter animation
       * @param {{el: HTMLElement, complete: Function}} el
       */
      enter: function enter(el, complete) {
        var animation = this.getAnimation('enter', el);
        (0, _animejs.default)(_objectSpread({
          targets: el
        }, animation, {
          complete: complete,
          easing: 'spring(1, 100, 50, 0)'
        }));
      },

      /**
       * @description Calls leave animation
       * @param {{el: HTMLElement, complete: Function}} el
       */
      leave: function leave(el, complete) {
        var animation = this.getAnimation('leave', el);
        (0, _animejs.default)(_objectSpread({
          targets: el
        }, animation, {
          complete: complete,
          easing: 'spring(1, 100, 70, 0)'
        }));
      }
    },
    render: function render(h) {
      var _this3 = this;

      return h('span', [Object.keys(this.positions).map(function (position) {
        var pos = position;
        var toasts = _this3.positions[pos];
        return h('TransitionGroup', {
          style: _this3.getStyle(pos),
          props: {
            css: false
          },
          on: {
            enter: _this3.enter,
            leave: _this3.leave
          },
          key: position,
          class: ['Breadstick__manager-' + pos],
          ref: "BreadstickManager_".concat(pos)
        }, [toasts.map(function (toast) {
          return h(_Message.default, {
            props: _objectSpread({
              position: pos,
              key: toast.id,
              message: toast.message
            }, toast),
            style: _objectSpread({}, computeBreadstickStyle(pos)),
            on: {
              remove: function remove(_ref) {
                var id = _ref.id,
                    position = _ref.position;

                _this3.removeToast(id, position);
              }
            },
            key: toast.id
          }, _this3.$slots.default);
        })]);
      })]);
    }
  };
  var _default2 = BreadstickManager;
  exports.default = _default2;
});
chakraUiStyledSystem_esm.unwrapExports(BreadstickManager_1);
var Breadstick_1 = chakraUiStyledSystem_esm.createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _vue = _interopRequireDefault(Vue);

  var _BreadstickManager = _interopRequireDefault(BreadstickManager_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';
  var PORTAL_ID = 'breadstick-kitchen';
  var ROOT_ID = 'breadstick-chef';
  var VM = typeof window !== 'undefined' && window.Vue ? window.Vue : _vue.default;
  /**
   * @description Create Toast Portal
   * @returns {HTMLElement}
   */

  function createPortal() {
    if (!isBrowser) {
      return;
    }

    var portalElement;
    var existingPortalElement = document.getElementById(PORTAL_ID);

    if (existingPortalElement) {
      portalElement = existingPortalElement;
    } else {
      var el = document.createElement('div');
      el.id = PORTAL_ID;
      el.className = 'Breadstick';

      if (document.body != null) {
        document.body.appendChild(el);
      }

      portalElement = el;
    } // Create toaster-kitchen root instance


    var root = document.createElement('div');
    root.id = ROOT_ID;
    portalElement.appendChild(root);
    return portalElement;
  }

  function createBreadstick(boundNotify) {
    new VM({
      el: "#".concat(ROOT_ID),
      render: function render(h) {
        return h(_BreadstickManager.default, {
          props: {
            notify: boundNotify
          }
        }, this.$slots.default);
      }
    }).$mount();
  }
  /**
   * Toaster returns breadstick instance
   */


  var Breadstick = function Breadstick() {
    var _this = this;

    _classCallCheck(this, Breadstick);

    _defineProperty(this, "closeAll", function () {
      if (_this.removeAll) {
        _this.removeAll();
      }
    });

    _defineProperty(this, "bindNotify", function (fn, removeAll) {
      _this.createNotification = fn;
      _this.removeAll = removeAll;
    });

    _defineProperty(this, "notify", function (message) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (_this.createNotification) {
        _this.createNotification(message, options);
      }
    });

    createPortal();
    createBreadstick(this.bindNotify);
  };

  var _default = Breadstick;
  exports.default = _default;
});
chakraUiStyledSystem_esm.unwrapExports(Breadstick_1);
var plugin = chakraUiStyledSystem_esm.createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _Breadstick = _interopRequireDefault(Breadstick_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  var breadstick = new _Breadstick.default();
  /**
   * Breadstick plugin
   */

  var _default = {
    install: function install(Vue) {
      Vue.prototype.$breadstick = breadstick;
    }
  };
  exports.default = _default;
});
chakraUiStyledSystem_esm.unwrapExports(plugin);
var es = chakraUiStyledSystem_esm.createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "BreadstickBakery", {
    enumerable: true,
    get: function get() {
      return _plugin.default;
    }
  });
  exports.default = void 0;

  var _Breadstick = _interopRequireDefault(Breadstick_1);

  var _plugin = _interopRequireDefault(plugin);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  var _default = _Breadstick.default;
  exports.default = _default;
});
var Breadstick = chakraUiStyledSystem_esm.unwrapExports(es);
/**
 * Hey! Welcome to @chakra-ui/vue Toast
 *
 * The toast is used to show alerts on top of an overlay.
 *
 * @see Docs     https://vue.chakra-ui.com/toast
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CToast/CToast.js
 */

var breadstick = new Breadstick();
/**
 * CToast component
 *
 * the toast element component
 *
 * @extends CAlert
 * @see Docs https://vue.chakra-ui.com/toast
 */

var CToast = {
  name: 'CToast',
  inheritAttrs: false,
  props: {
    status: {
      type: String,
      default: 'info'
    },
    variant: {
      type: String,
      default: 'solid'
    },
    id: {
      type: String
    },
    title: {
      type: String,
      default: ''
    },
    isClosable: {
      type: Boolean,
      default: true
    },
    onClose: {
      type: Function,
      default: function _default() {
        return null;
      }
    },
    description: {
      type: String,
      default: ''
    }
  },
  render: function render(h) {
    return h(CAlert.CAlert, {
      props: Object.assign({}, {
        status: this.status,
        variant: this.variant
      }, utils.pickProperty(this.$props)),
      attrs: Object.assign({}, {
        textAlign: 'left',
        boxShadow: 'lg',
        rounded: 'md',
        alignItems: 'start',
        fontFamily: 'body',
        m: 2,
        pr: 2,
        p: 4,
        id: this.id
      }, this.$attrs || {}, {
        'data-chakra-component': 'CToast'
      })
    }, [h(CAlert.CAlertIcon), h(CBox.default, {
      props: {
        flex: '1'
      }
    }, [this.title && h(CAlert.CAlertTitle, {}, this.title), this.description && h(CAlert.CAlertDescription, {}, this.description)]), this.isClosable && h(CCloseButton.default, {
      props: {
        size: 'sm'
      },
      attrs: {
        position: 'absolute',
        right: '4px',
        top: '4px',
        color: 'currentColor'
      },
      on: {
        click: this.onClose
      }
    })]);
  }
};
/**
 * @description Toast initialization API
 * TODO: In Vue 3 this should be exposed as a hook of it's own so as to
 * to inject theme and icons variables provided by theme provider component.
 */

function useToast() {
  var theme = colorModeObserver.colorModeObserver.theme;
  /**
   * @description Notify Method for Kiwi
   * @param {Object} options
   * @property {String} position
   * @property {Number} duration
   * @property {Function} render
   * @property {String} title
   * @property {String} description
   * @property {String} status
   * @property {String} variant
   * @property {Boolean} isClosable
   */

  function notify(ref) {
    var position = ref.position;
    if (position === void 0) position = 'bottom';
    var duration = ref.duration;
    if (duration === void 0) duration = 5000;
    var render = ref.render;
    var title = ref.title;
    var description = ref.description;
    var status = ref.status;
    var variant = ref.variant;
    if (variant === void 0) variant = 'solid';
    var isClosable = ref.isClosable;
    var options = {
      position: position,
      duration: duration
    };

    if (render) {
      return breadstick.notify(function (ref) {
        var h = ref.h;
        var onClose = ref.onClose;
        var id = ref.id;
        return h(CThemeProvider.default, {
          props: {
            theme: theme
          }
        }, [render({
          onClose: onClose,
          id: id
        })]);
      }, options);
    }
    /**
     * @todo Need to battletest breadstick to RELIABLY support JSX API and render function API globally.
     */


    breadstick.notify(function (ref) {
      var h = ref.h;
      var onClose = ref.onClose;
      var id = ref.id;
      var theme = colorModeObserver.colorModeObserver.theme;
      var colorMode = colorModeObserver.colorModeObserver.colorMode;
      var icons = colorModeObserver.colorModeObserver.icons;
      return h(CThemeProvider.default, {
        props: {
          icons: icons,
          theme: theme
        }
      }, [h(CColorModeProvider.default, {
        props: {
          value: colorMode || 'light'
        }
      }, [h(CToast, {
        props: {
          status: status,
          variant: variant,
          id: "" + id,
          title: title,
          isClosable: isClosable,
          onClose: onClose,
          description: description
        }
      })])]);
    }, options);
  }

  return notify;
}

exports.default = useToast;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(8);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

var CIcon = __webpack_require__(9);

var baseProps = {
  display: 'flex',
  alignItems: 'center',
  position: 'relative',
  overflow: 'hidden',
  pl: 4,
  pr: 4,
  pt: 3,
  pb: 3
};
/**
 * @description Create leftAccent alert styles
 * @param {Object} props
 * @property {String} color
 */

var leftAccent = function leftAccent(props) {
  var color = props.color;
  return {
    light: Object.assign({}, {
      pl: 3
    }, subtle(props).light, {
      borderLeft: '4px',
      borderColor: color + ".500"
    }),
    dark: Object.assign({}, {
      pl: 3
    }, subtle(props).dark, {
      borderLeft: '4px',
      borderColor: color + ".200"
    })
  };
};
/**
 * @description Create topAccent alert styles
 * @param {Object} props
 * @property {String} color
 */


var topAccent = function topAccent(props) {
  var color = props.color;
  return {
    light: Object.assign({}, {
      pt: 2
    }, subtle(props).light, {
      borderTop: '4px',
      borderColor: color + ".500"
    }),
    dark: Object.assign({}, {
      pt: 2
    }, subtle(props).dark, {
      borderTop: '4px',
      borderColor: color + ".200"
    })
  };
};
/**
 * @description Create solid alert styles
 * @param {Object} props
 * @property {String} color
 */


var solid = function solid(ref) {
  var color = ref.color;
  return {
    light: {
      bg: color + ".500",
      color: 'white'
    },
    dark: {
      bg: color + ".200",
      color: 'gray.900'
    }
  };
};
/**
 * @description Create subtle alert styles
 * @param {Object} props
 * @property {String} color
 */


var subtle = function subtle(ref) {
  var color = ref.color;
  var colors = ref.theme.colors;
  var darkBg = colors[color] && colors[color][200];
  return {
    light: {
      bg: color + ".100"
    },
    dark: {
      bg: utils.colorEmphasis(darkBg, 'lowest')
    }
  };
};
/**
 * @description Evaluate variant styles
 * @param {Object} props
 * @returns {Object} Style props
 */


var statusStyleProps = function statusStyleProps(props) {
  switch (props.variant) {
    case 'solid':
      return solid(props);

    case 'subtle':
      return subtle(props);

    case 'top-accent':
      return topAccent(props);

    case 'left-accent':
      return leftAccent(props);

    default:
      return {};
  }
};
/**
 * @description Create styles for alert component.
 * @param {Object} context
 * @property {String} variant
 * @property {String} color
 * @property {String} colorMode
 * @property {Object} theme
 * @returns {Object} Style props
 */


var useAlertStyle = function useAlertStyle(ref) {
  var variant = ref.variant;
  var color = ref.color;
  var colorMode = ref.colorMode;
  var theme = ref.theme;
  var _props = {
    variant: variant,
    color: color,
    theme: theme
  };
  return Object.assign({}, baseProps, statusStyleProps(_props)[colorMode]);
};
/**
 * @description Create alert icon styles
 * @param {Object} context
 * @property {String} variant
 * @property {String} colorMode
 * @property {String} color
 * @returns {Object} Style props
 */


var useAlertIconStyle = function useAlertIconStyle(ref) {
  var variant = ref.variant;
  var colorMode = ref.colorMode;
  var color = ref.color;

  if (['left-accent', 'top-accent', 'subtle'].includes(variant)) {
    var result = {
      light: {
        color: color + ".500"
      },
      dark: {
        color: color + ".200"
      }
    };
    return result[colorMode];
  }
};
/**
 * Hey! Welcome to @chakra-ui/vue Alert
 *
 * Alerts are used to communicate a state
 * that affects a system, feature or page
 *
 * An alert is an element that displays a brief,
 * important message in a way that attracts the user's
 * attention without interrupting the user's task.
 *
 * @see Docs     https://vue.chakra-ui.com/alert
 * @see Source   link to source
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CAlert/accessibility.md
 * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#alert
 */


var statuses = {
  info: {
    icon: 'info',
    color: 'blue'
  },
  warning: {
    icon: 'warning-alt',
    color: 'orange'
  },
  success: {
    icon: 'check-circle',
    color: 'green'
  },
  error: {
    icon: 'warning',
    color: 'red'
  }
};
/**
 * CAlert component
 *
 * The wrapper for alert components.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/alert
 */

var CAlert = {
  name: 'CAlert',
  mixins: [utils.createStyledAttrsMixin('CAlert')],
  provide: function provide() {
    return {
      _status: this.status,
      _variant: this.variant
    };
  },
  computed: {
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    },
    componentStyles: function componentStyles() {
      return Object.assign({}, {
        fontFamily: 'body'
      }, useAlertStyle({
        variant: this.variant,
        color: statuses[this.status] && statuses[this.status].color,
        colorMode: this.colorMode,
        theme: this.$chakraTheme()
      }));
    }
  },
  props: {
    status: {
      type: [String, Array],
      default: 'info'
    },
    variant: {
      type: [String, Array],
      default: 'subtle'
    }
  },
  render: function render(h) {
    return h('div', {
      class: this.className,
      attrs: Object.assign({}, {
        role: 'alert'
      }, this.computedAttrs)
    }, this.$slots.default);
  }
};
/**
 * CAlertIcon component
 *
 * The visual icon for the alert that changes
 * based on the `status` prop
 *
 * @extends CIcon
 * @see Docs https://vue.chakra-ui.com/alert
 */

var CAlertIcon = {
  name: 'CAlertIcon',
  inheritAttrs: false,
  inject: ['_status', '_variant', '$chakraColorMode', '$chakraTheme'],
  props: {
    size: {
      default: 5
    },
    name: String
  },
  computed: {
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    },
    alertIconStyles: function alertIconStyles() {
      return useAlertIconStyle({
        variant: this._variant,
        colorMode: this.colorMode,
        color: statuses[this._status] && statuses[this._status].color
      });
    }
  },
  render: function render(h) {
    return h(CIcon.CIcon, {
      props: {
        size: this.size,
        name: this.name || statuses[this._status] && statuses[this._status].icon
      },
      attrs: Object.assign({}, {
        focusable: false,
        'data-chakra-component': 'CAlertIcon',
        mr: this.$attrs.mr || 3
      }, this.alertIconStyles, this.$attrs)
    });
  }
};
/**
 * CAlertTitle component
 *
 * The title of the alert to be announced
 * by screen readers.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/alert
 */

var CAlertTitle = {
  name: 'CAlertTitle',
  mixins: [utils.createStyledAttrsMixin('CAlertTitle')],
  render: function render(h) {
    return h(CBox.default, {
      class: this.className,
      attrs: Object.assign({}, {
        fontWeight: 'bold',
        lineHeight: 'normal'
      }, this.computedAttrs, {
        'data-chakra-component': 'CAlertTitle'
      })
    }, this.$slots.default);
  }
};
/**
 * CAlertDescription component
 *
 * The description of the alert to be announced
 * by screen readers.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/alert
 */

var CAlertDescription = {
  name: 'CAlertDescription',
  mixins: [utils.createStyledAttrsMixin('CAlertDescription')],
  render: function render(h) {
    return h(CBox.default, {
      class: this.className,
      attrs: Object.assign({}, this.computedAttrs, {
        'data-chakra-component': 'CAlertDescription'
      })
    }, this.$slots.default);
  }
};
exports.CAlert = CAlert;
exports.CAlertDescription = CAlertDescription;
exports.CAlertIcon = CAlertIcon;
exports.CAlertTitle = CAlertTitle;
exports.statuses = statuses;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var css = __webpack_require__(1);

__webpack_require__(0);

var colorModeObserver = __webpack_require__(3);
/**
 * Hey! Welcome to @chakra-ui/vue CThemeProvider
 *
 * The CThemeProvider componeent provides theme context to all it's
 * children.
 *
 * @see Docs     https://vue.chakra-ui.com/getting-started
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CThemeProvider/CThemeProvider.js
 */

/**
 * CThemeProvider component
 */


var CThemeProvider = {
  name: 'CThemeProvider',
  provide: function provide() {
    var this$1 = this;
    return {
      $chakraTheme: function $chakraTheme() {
        return this$1.theme;
      },
      $chakraIcons: this.icons,

      /**
       * By default the ThemeProvider exposes a colorMode value of light
       * If no `ColorModeProvider` is provided in children/ consumer app, all chakra
       * components will consume the $chakraColorMode from here.
       */
      $chakraColorMode: function $chakraColorMode() {
        return 'light';
      }
    };
  },
  props: {
    rootKey: {
      type: String,
      default: ':root'
    }
  },
  computed: {
    icons: function icons() {
      return this.$chakra ? this.$chakra.icons : {};
    },
    theme: function theme() {
      return this.$chakra.theme;
    }
  },
  watch: {
    theme: {
      immediate: true,
      handler: function handler(newVal) {
        colorModeObserver.colorModeObserver.theme = newVal;
        this.updateGlobalCssVars();
      }
    },
    icons: {
      immediate: true,
      handler: function handler(newVal) {
        colorModeObserver.colorModeObserver.icons = newVal;
      }
    }
  },
  methods: {
    updateGlobalCssVars: function updateGlobalCssVars() {
      var obj;
      var rootKey = this.rootKey || ':root';
      css.injectGlobal((obj = {}, obj[rootKey] = this.theme.__cssVars, obj));
    }
  },
  render: function render(h) {
    return h('div', {
      attrs: {
        id: '__chakra-app',
        'data-chakra-component': 'CThemeProvider'
      }
    }, this.$slots.default);
  }
};
exports.default = CThemeProvider;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

__webpack_require__(0);

var colorModeObserver = __webpack_require__(3);
/**
 * Hey! Welcome to @chakra-ui/vue ColorModePovider
 *
 * The `CColorModeProvider` component provides the current color mode value ("light" or "dark")
 * to all it's descendants. This variable can be injected as `$chakraColorMode`.
 * `$chakraColorMode` is a function that returns the current color mode value.
 *
 * The `CColorModeProvider` component also provides a function `$toggleColorMode` to switch
 * the `$chakraColorMode` between light and dark values at runtime.
 *
 * This file also exports the `CDarkMode` and `CLightMode` components that respectively
 * provide the "dark" and "light" color modes to their respective children.
 *
 * @see Example  https://chakra-ui-vue.netlify.com/?path=/story/ui-popover--hover-trigger
 * @see Docs     https://vue.chakra-ui.com/color-mode
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CColorModePovider/CColorModePovider.js
 */

/**
 * CColorModeProvider component
 *
 * The ColorModeProvider component provides the current color mode value
 *
 * @see Docs https://vue.chakra-ui.com/color-mode
 */


var CColorModeProvider = {
  name: 'CColorModeProvider',
  props: {
    value: String
  },
  data: function data() {
    return {
      colorMode: 'light'
    };
  },
  provide: function provide() {
    var this$1 = this;
    return {
      $chakraColorMode: function $chakraColorMode() {
        return this$1._colorMode;
      },
      $toggleColorMode: this.toggleColorMode
    };
  },
  computed: {
    _colorMode: {
      get: function get() {
        return this.value ? this.value : this.colorMode;
      },
      set: function set(value) {
        this.colorMode = value;
      }
    }
  },
  created: function created() {
    var this$1 = this;
    colorModeObserver.colorModeObserverEventBus.$emit('change:colorMode', this._colorMode);
    this.$watch(function () {
      return this$1._colorMode;
    }, function (newColorMode) {
      colorModeObserver.colorModeObserverEventBus.$emit('change:colorMode', newColorMode);
    });
    colorModeObserver.colorModeObserverEventBus.$on('command:toggleColorMode', this.toggleColorMode);
  },
  methods: {
    toggleColorMode: function toggleColorMode() {
      /** Toggles colorMode */
      this._colorMode = this._colorMode === 'light' ? 'dark' : 'light';
    }
  },
  render: function render() {
    return this.$scopedSlots.default({
      colorMode: this._colorMode,
      toggleColorMode: this.toggleColorMode
    });
  }
};
/**
 * CDarkMode component
 *
 * Provides `$chakraColorMode` of value "light" to its descendants
 *
 * @see Docs https://vue.chakra-ui.com/color-mode
 */

var CDarkMode = {
  name: 'CDarkMode',
  render: function render(h) {
    return h(CColorModeProvider, {
      props: {
        value: 'dark'
      }
    }, this.$slots.default);
  }
};
/**
 * CLightMode component
 *
 * Provides `$chakraColorMode` of value "light" to its descendants
 *
 * @see Docs https://vue.chakra-ui.com/color-mode
 */

var CLightMode = {
  name: 'CLightMode',
  render: function render(h) {
    return h(CColorModeProvider, {
      props: {
        value: 'light'
      }
    }, this.$slots.default);
  }
};
exports.CDarkMode = CDarkMode;
exports.CLightMode = CLightMode;
exports.default = CColorModeProvider;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

__webpack_require__(14);

var CBox = __webpack_require__(5);

var CTransition = __webpack_require__(20);
/**
 * Hey! Welcome to @chakra-ui/vue Collapse
 *
 * The Collapse component is used to create regions of content
 * that can expand/collapse with a simple animation. It helps to hide
 * content that's not immediately relevant to the user.
 *
 * @see Docs     https://vue.chakra-ui.com/collapse
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CCollapse/CCollapse.js
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * CCollapse component
 *
 * Create regions of content that can expand/collapse
 * with a simple animation.
 *
 * @extends CAnimateHeight
 * @see Docs https://vue.chakra-ui.com/collpse
 */


var CCollapse = {
  name: 'CCollapse',
  functional: true,
  props: {
    isOpen: Boolean,
    duration: {
      type: Number,
      default: 250
    },
    easing: {
      type: String,
      default: 'easeInOutSine'
    },
    startingHeight: Number,
    endingHeight: Number,
    animateOpacity: {
      type: Boolean,
      default: true
    }
  },
  render: function render(h, ref) {
    var slots = ref.slots;
    var props = ref.props;
    var data = ref.data;
    var listeners = ref.listeners;
    var rest$1 = objectWithoutProperties(ref, ["slots", "props", "data", "listeners"]);
    var rest = rest$1; // Get children

    var children = slots().default; // Handle events

    var nonNativeEvents = {
      start: function start(e) {
        var emitStart = listeners.start;

        if (emitStart) {
          emitStart('start', e);
        }
      },
      finish: function finish(e) {
        var emitFinish = listeners.finish;

        if (emitFinish) {
          emitFinish('finish', e);
        }
      }
    };
    var ref$1 = utils.extractListeners({
      listeners: listeners
    }, nonNativeEvents);
    var native = ref$1.native;
    var nonNative = ref$1.nonNative;
    return h(CTransition.CAnimateHeight, Object.assign({}, rest, {
      props: {
        isOpen: props.isOpen,
        duration: props.duration,
        enterEasing: props.easing,
        leaveEasing: props.easing,
        initialHeight: props.startingHeight,
        finalHeight: props.endingHeight,
        animateOpacity: props.animateOpacity
      },
      on: nonNative,
      nativeOn: native,
      attrs: {
        'data-chakra-component': 'CCollapse'
      }
    }), [h(CBox.default, {
      props: {
        as: props.as
      },
      attrs: data.attrs
    }, children)]);
  }
};
exports.default = CCollapse;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var props_types = __webpack_require__(6);
/**
 * Hey! Welcome to @chakra-ui/vue Link
 *
 * `CLink` is an accessible elements used primarily for navigation.
 *
 * @see Docs     https://vue.chakra-ui.com/link
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CLink/CLink.js
 */

/**
 * CLink component
 *
 * The anchor / router-link / nuxt-link element
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/link
 */


var CLink = {
  name: 'CLink',
  mixins: [utils.createStyledAttrsMixin('CLink')],
  props: {
    as: {
      type: String,
      default: 'a'
    },
    to: props_types.SNA,
    isDisabled: Boolean,
    isExternal: Boolean
  },
  computed: {
    isRouterLink: function isRouterLink() {
      return ['router-link', 'nuxt-link'].includes(utils.kebabify(this.as));
    },
    componentStyles: function componentStyles() {
      return {
        transition: 'all 0.15s ease-out',
        cursor: 'pointer',
        textDecoration: 'none',
        outline: 'none',
        _focus: {
          boxShadow: 'outline'
        },
        _hover: {
          textDecoration: 'underline'
        },
        _disabled: {
          opacity: '0.4',
          cursor: 'not-allowed',
          textDecoration: 'none'
        }
      };
    },
    externalAttrs: function externalAttrs() {
      return this.isExternal ? {
        target: '_blank',
        rel: 'noopener noreferrer'
      } : null;
    }
  },
  render: function render(h) {
    var this$1 = this;
    return h(this.as, {
      class: this.className,
      props: Object.assign({}, this.isRouterLink && {
        to: this.to
      }),
      attrs: Object.assign({}, {
        tabindex: this.isDisabled ? -1 : undefined,
        'aria-disabled': this.isDisabled
      }, this.externalAttrs, this.computedAttrs),
      on: Object.assign({}, {
        click: function click(e) {
          return this$1.$emit('click', e);
        }
      }, this.computedListeners)
    }, this.$slots.default);
  }
};
exports.default = CLink;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);
/**
 * Hey! Welcome to @chakra-ui/vue Divider
 *
 * Dividers are used to display a thin horizontal or vertical line.
 *
 * @see Docs     https://vue.chakra-ui.com/divider
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CDivider/CDivider.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CDivider/accessibility.md
 */

/**
 * CDivider component
 *
 * Creates a horizontal or vertical dividing rule between sibling
 * elements
 *
 * @see Docs https://vue.chakra-ui.com/divider
 */


var CDivider = {
  name: 'CDivider',
  mixins: [utils.createStyledAttrsMixin('CDivider')],
  props: {
    orientation: {
      type: String,
      default: 'horizontal'
    }
  },
  computed: {
    borderProps: function borderProps() {
      return this.orientation === 'vertical' ? {
        borderLeft: '0.0625rem solid',
        height: 'auto',
        mx: 2
      } : {
        borderBottom: '0.0625rem solid',
        width: 'auto',
        my: 2
      };
    },
    componentStyles: function componentStyles() {
      return Object.assign({}, {
        border: 0
      }, this.borderProps, {
        opacity: 0.6,
        borderColor: 'inherit'
      });
    }
  },
  render: function render(h) {
    return h('hr', {
      class: this.className,
      attrs: Object.assign({}, {
        'aria-orientation': this.orientation
      }, this.computedAttrs)
    });
  }
};
exports.default = CDivider;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var props_types = __webpack_require__(6);
/**
 * Hey! Welcome to @chakra-ui/vue Grid
 *
 * A primitive useful for grid layouts. CGrid is CBox with
 * display: grid and comes with helpful style shorthand.
 * It renders a div element by default
 *
 * @see Docs     https://vue.chakra-ui.com/grid
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CGrid/CGrid.js
 */

/**
 * @description Map "span" values to accommodate breakpoint values
 * @param {Array} value
 * @returns {(String|Array)} String or Array of breakpoint values
 */


var spanFn = function spanFn(value) {
  if (Array.isArray(value)) {
    return value.map(function (v) {
      return v === 'auto' ? 'auto' : "span " + v + "/span " + v;
    });
  } else {
    return value === 'auto' ? 'auto' : "span " + value + "/span " + value;
  }
};
/**
 * CGridItem component
 *
 * A primitive component useful for grid layouts.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/grid
 */


var CGridItem = {
  name: 'CGridItem',
  mixins: [utils.createStyledAttrsMixin('CGridItem')],
  props: {
    colSpan: {
      type: props_types.StringArray
    },
    rowSpan: {
      type: props_types.StringArray
    },
    colStart: {
      type: props_types.StringArray
    },
    colEnd: {
      type: props_types.StringArray
    },
    rowStart: {
      type: props_types.StringArray
    },
    rowEnd: {
      type: props_types.StringArray
    }
  },
  computed: {
    componentStyles: function componentStyles() {
      return {
        gridColumn: this.colSpan ? spanFn(this.colSpan) : null,
        gridRow: this.rowSpan ? spanFn(this.rowSpan) : null,
        gridColumnStart: this.colStart,
        gridColumnEnd: this.colEnd,
        gridRowStart: this.rowStart,
        gridRowEnd: this.rowEnd
      };
    }
  },
  render: function render(h) {
    return h('div', {
      class: this.className,
      attrs: this.computedAttrs
    }, this.$slots.default);
  }
};
/**
 * CGrid component
 *
 * A primitive component useful for grid layouts.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/grid
 */

var CGrid = {
  name: 'CGrid',
  mixins: [utils.createStyledAttrsMixin('CGrid')],
  props: {
    as: {
      type: String,
      default: 'div'
    },
    gap: props_types.SNA,
    rowGap: props_types.SNA,
    columnGap: props_types.SNA,
    autoFlow: props_types.SNA,
    autoRows: props_types.SNA,
    autoColumns: props_types.SNA,
    templateRows: props_types.SNA,
    templateColumns: props_types.SNA,
    templateAreas: props_types.SNA,
    area: props_types.SNA,
    column: props_types.SNA,
    row: props_types.SNA
  },
  computed: {
    componentStyles: function componentStyles() {
      return {
        d: 'grid',
        gridArea: this.area,
        gridTemplateAreas: this.templateAreas,
        gridGap: this.gap,
        gridRowGap: this.rowGap,
        gridColumnGap: this.columnGap,
        gridAutoColumns: this.autoColumns,
        gridColumn: this.column,
        gridRow: this.row,
        gridAutoFlow: this.autoFlow,
        gridAutoRows: this.autoRows,
        gridTemplateRows: this.templateRows,
        gridTemplateColumns: this.templateColumns
      };
    }
  },
  render: function render(h) {
    return h(this.as, {
      class: this.className,
      attrs: this.computedAttrs
    }, this.$slots.default);
  }
};
exports.CGrid = CGrid;
exports.CGridItem = CGridItem;

/***/ }),
/* 90 */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 91 */
/***/ (function(module, exports) {

module.exports = require("node-fetch");

/***/ }),
/* 92 */
/***/ (function(module, exports) {

module.exports = require("vue-meta");

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _theme = _interopRequireDefault(__webpack_require__(148));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var _default = _theme.default;
exports.default = _default;

/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/* harmony default export */ __webpack_exports__["a"] = (stubFalse);

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(96);
module.exports = __webpack_require__(163);


/***/ }),
/* 96 */
/***/ (function(module, exports) {

global.installComponents = function (component, components) {
  var options = typeof component.exports === 'function'
    ? component.exports.extendOptions
    : component.options

  if (typeof component.exports === 'function') {
    options.components = component.exports.options.components
  }

  options.components = options.components || {}

  for (var i in components) {
    options.components[i] = options.components[i] || components[i]
  }


  if (options.functional) {
    provideFunctionalComponents(component, options.components)
  }
}

var functionalPatchKey = '_functionalComponents'

function provideFunctionalComponents(component, components) {
  if (component.exports[functionalPatchKey]) {
    return
  }
  component.exports[functionalPatchKey] = true

  var render = component.exports.render
  component.exports.render = function (h, vm) {
    return render(h, Object.assign({}, vm, {
      _c: function (n, a, b) {
        return vm._c(components[n] || n, a, b)
      }
    }))
  }
}


/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_id_608a1420_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77);
/* harmony import */ var _vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_id_608a1420_prod_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_id_608a1420_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_id_608a1420_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_id_608a1420_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(75);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(false);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".__nuxt-error-page{padding:1rem;background:#f7f8fb;color:#47494e;text-align:center;display:flex;justify-content:center;align-items:center;flex-direction:column;font-family:sans-serif;font-weight:100!important;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-webkit-font-smoothing:antialiased;position:absolute;top:0;left:0;right:0;bottom:0}.__nuxt-error-page .error{max-width:450px}.__nuxt-error-page .title{font-size:1.5rem;margin-top:15px;color:#47494e;margin-bottom:8px}.__nuxt-error-page .description{color:#7f828b;line-height:21px;margin-bottom:10px}.__nuxt-error-page a{color:#7f828b!important;text-decoration:none}.__nuxt-error-page .logo{position:fixed;left:12px;bottom:12px}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_id_d4ff419a_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78);
/* harmony import */ var _vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_id_d4ff419a_prod_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_id_d4ff419a_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_id_d4ff419a_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_id_d4ff419a_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(75);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(false);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".nuxt-progress{position:fixed;top:0;left:0;right:0;height:2px;width:0;opacity:1;transition:width .1s,opacity .4s;background-color:#000;z-index:999999}.nuxt-progress.nuxt-progress-notransition{transition:none}.nuxt-progress-failed{background-color:red}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


var utils = __webpack_require__(2);

var chakraUiStyledSystem_esm = __webpack_require__(4);

var internalIcons = __webpack_require__(8);

var colorModeObserver = __webpack_require__(3);

var directives = __webpack_require__(80);

var CToast = __webpack_require__(82);

function e(e) {
  return function (e) {
    if (Array.isArray(e)) {
      for (var t = 0, n = new Array(e.length); t < e.length; t++) {
        n[t] = e[t];
      }

      return n;
    }
  }(e) || function (e) {
    if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) {
      return Array.from(e);
    }
  }(e) || function () {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }();
}

var t = !1;

if ("undefined" != typeof window) {
  var n = {
    get passive() {
      t = !0;
    }

  };
  window.addEventListener("testPassive", null, n), window.removeEventListener("testPassive", null, n);
}

var o,
    i,
    r = "undefined" != typeof window && window.navigator && window.navigator.platform && /iP(ad|hone|od)/.test(window.navigator.platform),
    l = [],
    d = !1,
    c = -1,
    a = function (e) {
  return l.some(function (t) {
    return !(!t.options.allowTouchMove || !t.options.allowTouchMove(e));
  });
},
    u = function (e) {
  var t = e || window.event;
  return !!a(t.target) || t.touches.length > 1 || (t.preventDefault && t.preventDefault(), !1);
},
    s = {
  enableBodyScroll: function (e) {
    if (r) {
      if (!e) {
        return void console.error("enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.");
      }

      e.ontouchstart = null, e.ontouchmove = null, l = l.filter(function (t) {
        return t.targetElement !== e;
      }), d && 0 === l.length && (document.removeEventListener("touchmove", u, t ? {
        passive: !1
      } : void 0), d = !1);
    } else {
      (l = l.filter(function (t) {
        return t.targetElement !== e;
      })).length || setTimeout(function () {
        void 0 !== i && (document.body.style.paddingRight = i, i = void 0), void 0 !== o && (document.body.style.overflow = o, o = void 0);
      });
    }
  },
  disableBodyScroll: function (n, s) {
    if (r) {
      if (!n) {
        return void console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.");
      }

      if (n && !l.some(function (e) {
        return e.targetElement === n;
      })) {
        var v = {
          targetElement: n,
          options: s || {}
        };
        l = [].concat(e(l), [v]), n.ontouchstart = function (e) {
          1 === e.targetTouches.length && (c = e.targetTouches[0].clientY);
        }, n.ontouchmove = function (e) {
          1 === e.targetTouches.length && function (e, t) {
            var n = e.targetTouches[0].clientY - c;
            !a(e.target) && (t && 0 === t.scrollTop && n > 0 ? u(e) : function (e) {
              return !!e && e.scrollHeight - e.scrollTop <= e.clientHeight;
            }(t) && n < 0 ? u(e) : e.stopPropagation());
          }(e, n);
        }, d || (document.addEventListener("touchmove", u, t ? {
          passive: !1
        } : void 0), d = !0);
      }
    } else {
      !function (e) {
        setTimeout(function () {
          if (void 0 === i) {
            var t = !!e && !0 === e.reserveScrollBarGap,
                n = window.innerWidth - document.documentElement.clientWidth;
            t && n > 0 && (i = document.body.style.paddingRight, document.body.style.paddingRight = "".concat(n, "px"));
          }

          void 0 === o && (o = document.body.style.overflow, document.body.style.overflow = "hidden");
        });
      }(s);
      var f = {
        targetElement: n,
        options: s || {}
      };
      l = [].concat(e(l), [f]);
    }
  },
  install: function (e, t) {
    if (t) {
      var n = t.enableBodyScroll,
          o = t.disableBodyScroll;
      n && (this.enableBodyScroll = n), o && (this.disableBodyScroll = o);
    }

    e.directive("scroll-lock", {
      inserted: this.inserted.bind(this),
      componentUpdated: this.componentUpdated.bind(this),
      unbind: this.unbind.bind(this)
    });
  },
  inserted: function (e, t) {
    t.value && this.disableBodyScroll(e);
  },
  componentUpdated: function (e, t) {
    t.value ? this.disableBodyScroll(e) : this.enableBodyScroll(e);
  },
  unbind: function (e) {
    this.enableBodyScroll(e);
  }
};

"undefined" != typeof window && window.Vue && window.Vue.use(s);
var colors = {
  transparent: 'transparent',
  current: 'currentColor',
  black: '#000',
  white: '#fff',
  primary: '#1a72ff',
  secondary: '#7425f3',
  tertiary: '#fe9e4d',
  success: '#3ea76a',
  warning: '#ffc61a',
  error: '#dd3b4b',
  whiteAlpha: {
    50: 'rgba(255, 255, 255, 0.04)',
    100: 'rgba(255, 255, 255, 0.06)',
    200: 'rgba(255, 255, 255, 0.08)',
    300: 'rgba(255, 255, 255, 0.16)',
    400: 'rgba(255, 255, 255, 0.24)',
    500: 'rgba(255, 255, 255, 0.36)',
    600: 'rgba(255, 255, 255, 0.48)',
    700: 'rgba(255, 255, 255, 0.64)',
    800: 'rgba(255, 255, 255, 0.80)',
    900: 'rgba(255, 255, 255, 0.92)'
  },
  blackAlpha: {
    50: 'rgba(0, 0, 0, 0.04)',
    100: 'rgba(0, 0, 0, 0.06)',
    200: 'rgba(0, 0, 0, 0.08)',
    300: 'rgba(0, 0, 0, 0.16)',
    400: 'rgba(0, 0, 0, 0.24)',
    500: 'rgba(0, 0, 0, 0.36)',
    600: 'rgba(0, 0, 0, 0.48)',
    700: 'rgba(0, 0, 0, 0.64)',
    800: 'rgba(0, 0, 0, 0.80)',
    900: 'rgba(0, 0, 0, 0.92)'
  },
  gray: {
    50: '#F7FAFC',
    100: '#EDF2F7',
    200: '#E2E8F0',
    300: '#CBD5E0',
    400: '#A0AEC0',
    500: '#718096',
    600: '#4A5568',
    700: '#2D3748',
    800: '#1A202C',
    900: '#171923'
  },
  cyan: {
    50: '#EDFDFD',
    100: '#C4F1F9',
    200: '#9DECF9',
    300: '#76E4F7',
    400: '#0BC5EA',
    500: '#00B5D8',
    600: '#00A3C4',
    700: '#0987A0',
    800: '#086F83',
    900: '#065666'
  },
  vue: {
    50: '#e1fbf0',
    100: '#c0ecda',
    200: '#9edfc2',
    300: '#79d0aa',
    400: '#55c392',
    500: '#3caa79',
    600: '#2d845e',
    700: '#1d5e42',
    800: '#0c3a26',
    900: '#001508'
  },
  green: {
    50: '#e2fbed',
    100: '#c2ebd4',
    200: '#9fddb9',
    300: '#7ccf9e',
    400: '#58c184',
    500: '#3ea76a',
    600: '#2e8251',
    700: '#1f5d3a',
    800: '#0f3921',
    900: '#001506'
  },
  orange: {
    50: '#ffefdc',
    100: '#ffd4ae',
    200: '#ffba7f',
    300: '#fe9e4d',
    400: '#fd821b',
    500: '#e46902',
    600: '#b25100',
    700: '#7f3900',
    800: '#4e2200',
    900: '#1f0900'
  },
  red: {
    50: '#ffe5e9',
    100: '#f9bcc2',
    200: '#ee919a',
    300: '#e66673',
    400: '#dd3b4b',
    500: '#c42231',
    600: '#991826',
    700: '#6e101a',
    800: '#44070e',
    900: '#1e0001'
  },
  yellow: {
    50: '#fff9da',
    100: '#ffecad',
    200: '#ffdf7d',
    300: '#ffd24b',
    400: '#ffc61a',
    500: '#e6ac00',
    600: '#b38600',
    700: '#806000',
    800: '#4e3900',
    900: '#1d1300'
  },
  indigo: {
    50: '#f2e5ff',
    100: '#d2b5ff',
    200: '#b285fa',
    300: '#9356f7',
    400: '#7425f3',
    500: '#5a0cda',
    600: '#4608aa',
    700: '#32057b',
    800: '#1e024c',
    900: '#0c001e'
  },
  pink: {
    50: '#fff5f7',
    100: '#fed7e2',
    200: '#fbb6ce',
    300: '#f687b3',
    400: '#ed64a6',
    500: '#d53f8c',
    600: '#b83280',
    700: '#97266d',
    800: '#702459',
    900: '#521B41'
  },
  blue: {
    50: '#def0ff',
    100: '#afd0ff',
    200: '#7db1ff',
    300: '#4b91ff',
    400: '#1a72ff',
    500: '#0058e6',
    600: '#0045b4',
    700: '#003182',
    800: '#001d51',
    900: '#000a21'
  }
};
/**
 * @description This typography style was adapted from [@chakra-ui](https://chakra-ui.com/)
 */

var typography = {
  letterSpacings: {
    tighter: '-0.05em',
    tight: '-0.025em',
    normal: '0',
    wide: '0.025em',
    wider: '0.05em',
    widest: '0.1em'
  },
  lineHeights: {
    normal: 'normal',
    none: '1',
    shorter: '1.25',
    short: '1.375',
    base: '1.5',
    tall: '1.625',
    taller: '2'
  },
  fontWeights: {
    hairline: 100,
    thin: 200,
    light: 300,
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
    extrabold: 800,
    black: 900
  },
  fonts: {
    heading: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    mono: 'SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'
  },
  fontSizes: {
    xs: '0.75rem',
    sm: '0.875rem',
    md: '1rem',
    lg: '1.125rem',
    xl: '1.25rem',
    '2xl': '1.5rem',
    '3xl': '1.875rem',
    '4xl': '2.25rem',
    '5xl': '3rem',
    '6xl': '4rem'
  }
};
/**
 * @description These border styles were adapted from [@chakra-ui](https://chakra-ui.com/)
 */

var borders = {
  none: 0,
  '1px': '1px solid',
  '2px': '2px solid',
  '4px': '4px solid'
};
var borderWidths = {
  sm: '1px',
  md: '2px',
  lg: '4px'
};
/**
 * @description These opacity styles was adapted from [@chakra-ui](https://chakra-ui.com/)
 */

var opacity = {
  0: '0',
  '20%': '0.2',
  '40%': '0.4',
  '60%': '0.6',
  '80%': '0.8',
  '100%': '1'
};
/**
 * @description These radii styles was adapted from [@chakra-ui](https://chakra-ui.com/)
 */

var radii = {
  none: '0',
  sm: '0.125rem',
  md: '0.25rem',
  lg: '0.5rem',
  full: '9999px'
};
/**
 * @description These shadow styles was adapted from [@chakra-ui](https://chakra-ui.com/)
 */

var shadows = {
  sm: '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)',
  md: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
  lg: '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',
  xl: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
  '2xl': '0 25px 50px -12px rgba(0, 0, 0, 0.25)',
  outline: '0 0 0 3px rgba(66, 153, 225, 0.6)',
  inner: 'inset 0 2px 4px 0 rgba( 0, 0, 0, 0.06)',
  none: 'none'
};
/**
 * @description These sizes styles was adapted from [@chakra-ui](https://chakra-ui.com/)
 */

var baseSizes = {
  px: '1px',
  0: '0',
  1: '0.25rem',
  2: '0.5rem',
  3: '0.75rem',
  4: '1rem',
  5: '1.25rem',
  6: '1.5rem',
  8: '2rem',
  10: '2.5rem',
  12: '3rem',
  16: '4rem',
  20: '5rem',
  24: '6rem',
  32: '8rem',
  40: '10rem',
  48: '12rem',
  56: '14rem',
  64: '16rem'
};
var largeSizes = {
  full: '100%',
  '3xs': '14rem',
  '2xs': '16rem',
  xs: '20rem',
  sm: '24rem',
  md: '28rem',
  lg: '32rem',
  xl: '36rem',
  '2xl': '42rem',
  '3xl': '48rem',
  '4xl': '56rem',
  '5xl': '64rem',
  '6xl': '72rem'
};
var containers = {
  sm: '640px',
  md: '768px',
  lg: '1024px',
  xl: '1280px'
};
var sizes = Object.assign({}, baseSizes, largeSizes, {
  containers: containers
});
/**
 * @description This typography style was adapted from [@chakra-ui](https://chakra-ui.com/)
 */

var zIndices = {
  hide: -1,
  auto: 'auto',
  base: 0,
  docked: 10,
  dropdown: 1000,
  sticky: 1100,
  banner: 1200,
  overlay: 1300,
  modal: 1400,
  popover: 1500,
  skipLink: 1600,
  toast: 1700,
  tooltip: 1800
};
/**
 * @description These breakpoint styles were adapted from [@chakra-ui](https://chakra-ui.com/)
 */

var _breakpoints = {
  sm: '30em',
  md: '48em',
  lg: '62em',
  xl: '80em',
  '2xl': '96em'
};

var createBreakpoints = function createBreakpoints(config) {
  if (config === void 0) config = {};
  return Object.assign({}, {
    base: '0em'
  }, config);
};

var breakpoints = createBreakpoints(_breakpoints);
var space = baseSizes;
var config = {
  useSystemColorMode: false,
  initialColorMode: 'light',
  cssVarPrefix: 'chakra'
};
var theme = Object.assign({}, {
  breakpoints: breakpoints,
  zIndices: zIndices,
  radii: radii,
  opacity: opacity,
  borders: borders,
  colors: colors
}, typography, {
  borderWidths: borderWidths,
  sizes: sizes,
  shadows: shadows,
  space: space,
  config: config
});
/**
 * Chakra-ui Component library plugin
 * @type {import("../../types").ChakraPlugin}
 */

var Chakra = {
  /**
   *
   * @param {Vue} Vue
   * @param {import("../../types").Options} options
   */
  install: function install(Vue, options) {
    if (options === void 0) options = {};
    var packIcons = {};
    var extendedIcons = options.icons ? options.icons.extend || {} : {};

    if (options.icons) {
      packIcons = utils.parsePackIcons(options.icons.iconSet);
    }

    var icons = Object.assign({}, internalIcons.internalIcons, packIcons, extendedIcons); // Recursively merge extended theme variables

    var mergedTheme = chakraUiStyledSystem_esm.toCSSVar(utils.merge(theme, options.extendTheme));
    Vue.directive('chakra', directives.createClientDirective(mergedTheme)); // Bind theme and icons to prototype

    Vue.prototype.$chakra = {
      theme: mergedTheme,
      icons: icons
    };
    var toast = CToast.default();
    Vue.prototype.$toast = toast;
    /** Install dependent plugins */

    Vue.use(s);
    Vue.mixin({
      computed: {
        chakraColorMode: function chakraColorMode() {
          return colorModeObserver.colorModeObserver.colorMode;
        },
        chakraTheme: function chakraTheme() {
          return colorModeObserver.colorModeObserver.theme;
        },
        chakraToggleColorMode: function chakraToggleColorMode() {
          return colorModeObserver.colorModeObserver.toggleColorMode;
        },
        $mode: function $mode(vm) {
          return function (lightValue, darkValue) {
            return colorModeObserver.mode(lightValue, darkValue, colorModeObserver.colorModeObserver);
          };
        }
      }
    });
  }
};
exports.mode = colorModeObserver.mode;
exports.Chakra = Chakra;
exports.defaultTheme = theme;

/***/ }),
/* 102 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/es.typed-array.set.js");

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(8);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

__webpack_require__(14);

__webpack_require__(5);

var CIcon = __webpack_require__(9);

var CPseudoBox = __webpack_require__(12);

__webpack_require__(20);

var CCollapse = __webpack_require__(86);
/**
 * Hey! Welcome to @chakra-ui/vue Accordion
 *
 * Accordions display a list of high-level
 * options that can expand/collapse to reveal
 * more information.
 *
 * An accordion is a vertically stacked set
 * of interactive headings that each contain
 * a title, content snippet, or thumbnail
 * representing a section of content.
 * The headings function as controls that enable
 * users to reveal or hide their associated sections
 * of content. Accordions are commonly used to
 * reduce the need to scroll when presenting
 * multiple sections of content on a single page.
 *
 * @see Docs     https://vue.chakra-ui.com/accordion
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CAccordion/CAccordion.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CAccordion/accessibility.md
 * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#accordion
 */

/**
 * CAccordion component
 *
 * The wrapper that clones it's children
 * to pass it's prop to the `CAccordionItem`.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/accordion
 */


var CAccordion = {
  name: 'CAccordion',
  mixins: [utils.createStyledAttrsMixin('CAccordion')],
  props: {
    allowMultiple: Boolean,
    allowToggle: Boolean,
    index: {
      type: Number,
      default: null
    },
    defaultIndex: {
      type: [Array, Number],
      default: 0
    }
  },
  data: function data() {
    var this$1 = this;

    var initializeState = function initializeState() {
      if (this$1.allowMultiple) {
        return this$1.defaultIndex || [];
      } else {
        return this$1.defaultIndex || 0;
      }
    };

    return {
      expandedIndex: initializeState()
    };
  },
  computed: {
    isControlled: function isControlled() {
      return this.index != null;
    },
    _index: {
      get: function get() {
        return this.isControlled ? this.index : this.expandedIndex;
      },
      set: function set(val) {
        this.expandedIndex = val;
      }
    }
  },
  methods: {
    getExpandCondition: function getExpandCondition(index, itemIndex) {
      if (Array.isArray(index)) {
        return index.includes(itemIndex);
      }

      return index === itemIndex;
    }
  },
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default.filter(function (e) {
      return e.tag;
    });
    var cloned = utils.cloneVNodes(children, h);
    var clones = cloned.map(function (vnode, index) {
      var clone = h(vnode.componentOptions.Ctor, Object.assign({}, vnode.data, vnode.componentOptions.listeners || {}, {
        props: Object.assign({}, vnode.data.props || {}, vnode.componentOptions.propsData, {
          isOpen: this$1.getExpandCondition(this$1._index, index)
        }),
        attrs: vnode.data.attrs || {},
        on: {
          change: function change(isExpanded) {
            if (this$1.allowMultiple) {
              if (isExpanded) {
                var newIndices = this$1._index.concat([index]);

                if (!this$1.isControlled) {
                  this$1.expandedIndex = newIndices;
                }

                this$1.$emit('change', newIndices);
              } else {
                var newIndices$1 = this$1._index.filter(function (itemIndex) {
                  return itemIndex !== index;
                });

                if (!this$1.isControlled) {
                  this$1.expandedIndex = newIndices$1;
                }

                this$1.$emit('change', newIndices$1);
              }
            } else if (isExpanded) {
              if (!this$1.isControlled) {
                this$1.expandedIndex = index;
              }

              this$1.$emit('change', index);
            } else if (this$1.allowToggle) {
              if (!this$1.isControlled) {
                this$1.expandedIndex = null;
              }

              this$1.$emit('change', null);
            }
          }
        }
      }), vnode.componentOptions.children);
      return clone;
    });
    return h('div', {
      class: this.className,
      attrs: this.computedAttrs,
      on: this.computedListeners
    }, clones);
  }
};
/**
 * CAccordionItem component
 *
 * A single accordion item
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/accordion
 */

var CAccordionItem = {
  name: 'CAccordionItem',
  mixins: [utils.createStyledAttrsMixin('CAccordionItem')],
  props: {
    isOpen: {
      type: Boolean,
      default: null
    },
    defaultIsOpen: {
      type: Boolean,
      default: false
    },
    id: String,
    isDisabled: {
      type: Boolean,
      default: false
    }
  },
  provide: function provide() {
    var this$1 = this;
    return {
      $AccordionContext: function $AccordionContext() {
        return this$1.AccordionContext;
      }
    };
  },
  data: function data() {
    return {
      isExpanded: this.defaultIsOpen || false
    };
  },
  computed: {
    AccordionContext: function AccordionContext() {
      return {
        isExpanded: this._isExpanded,
        isDisabled: this.isDisabled,
        headerId: this.headerId,
        panelId: this.panelId,
        onToggle: this.onToggle
      };
    },
    isControlled: function isControlled() {
      return utils.isDef(this.isOpen);
    },
    _isExpanded: {
      get: function get() {
        return this.isControlled ? this.isOpen : this.isExpanded;
      },
      set: function set(value) {
        this.isExpanded = value;
      }
    },
    _id: function _id() {
      return this.id || utils.useId();
    },
    headerId: function headerId() {
      return "accordion-header-" + this._id;
    },
    panelId: function panelId() {
      return "accordion-panel-" + this._id;
    },
    componentStyles: function componentStyles() {
      return {
        borderTopWidth: '1px',
        _last: {
          borderBottomWidth: '1px'
        }
      };
    }
  },
  methods: {
    onToggle: function onToggle() {
      this.$emit('change', !this._isExpanded);

      if (!this.isControlled) {
        this._isExpanded = !this._isExpanded;
      }
    }
  },
  render: function render(h) {
    return h(CPseudoBox.default, {
      class: this.className,
      props: Object.assign({}, utils.pickProperty(this.$props), {
        borderTopWidth: '1px',
        _last: {
          borderBottomWidth: '1px'
        }
      }),
      attrs: this.computedAttrs
    }, [this.$scopedSlots.default({
      isExpanded: this._isExpanded,
      isDisabled: this.isDisabled
    })]);
  }
};
/**
 * CAccordionHeader component
 *
 * The button that toggles the expand/collapse
 * state of the accordion item.
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/accordion
 */

var CAccordionHeader = {
  name: 'CAccordionHeader',
  inheritAttrs: false,
  inject: ['$AccordionContext'],
  computed: {
    context: function context() {
      return this.$AccordionContext();
    },
    computedAttrs: function computedAttrs() {
      return this.$data.attrs$;
    }
  },
  data: function data() {
    return {
      attrs$: {}
    };
  },
  watch: {
    $attrs: utils.createWatcher('attrs$')
  },
  render: function render(h) {
    var this$1 = this;
    var ref = this.context;
    var isExpanded = ref.isExpanded;
    var panelId = ref.panelId;
    var headerId = ref.headerId;
    var isDisabled = ref.isDisabled;
    var onToggle = ref.onToggle;
    return h(CPseudoBox.default, {
      attrs: Object.assign({}, {
        as: 'button',
        display: 'flex',
        alignItems: 'center',
        width: '100%',
        outline: 0,
        transition: 'all 0.2s',
        px: 4,
        py: 2,
        _focus: {
          boxShadow: 'outline'
        },
        _hover: {
          bg: 'blackAlpha.50'
        },
        _disabled: {
          opacity: '0.4',
          cursor: 'not-allowed'
        },
        id: headerId,
        type: 'button',
        disabled: isDisabled,
        'aria-disabled': isDisabled,
        'aria-expanded': isExpanded ? 'true' : 'false',
        'aria-controls': panelId
      }, this.computedAttrs, {
        'data-chakra-component': 'CAccordionHeader'
      }),
      on: this.computedListeners,
      nativeOn: {
        click: function click(e) {
          onToggle();
          this$1.$emit('click', e);
        }
      }
    }, this.$slots.default);
  }
};
/**
 * CAccordionPanel component
 *
 * The container for the accordion item
 * details to be revealed.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/accordion
 */

var CAccordionPanel = {
  name: 'CAccordionPanel',
  inheritAttrs: false,
  inject: ['$AccordionContext'],
  computed: {
    context: function context() {
      return this.$AccordionContext();
    },
    computedAttrs: function computedAttrs() {
      return this.$attrs;
    }
  },
  render: function render(h) {
    var ref = this.context;
    var isExpanded = ref.isExpanded;
    var panelId = ref.panelId;
    var headerId = ref.headerId;
    return h(CCollapse.default, {
      props: {
        isOpen: isExpanded
      },
      on: this.computedListeners,
      attrs: Object.assign({}, {
        pt: 2,
        px: 4,
        pb: 5
      }, this.computedAttrs, {
        id: panelId,
        'aria-labelledby': headerId,
        'aria-hidden': !isExpanded,
        role: 'region',
        'data-chakra-component': 'CAccordionPanel'
      })
    }, this.$slots.default);
  }
};
/**
 * CAccordionIcon component
 *
 * A chevron-down icon that rotates based on the
 * expanded/collapsed state.
 *
 * @extends CIcon
 * @see Docs https://vue.chakra-ui.com/accordion
 */

var CAccordionIcon = {
  name: 'CAccordionIcon',
  mixins: [utils.createStyledAttrsMixin('CAccordionIcon')],
  inject: ['$AccordionContext'],
  props: CIcon.iconProps,
  computed: {
    context: function context() {
      return this.$AccordionContext();
    },
    componentStyles: function componentStyles() {
      var ref = this.context;
      var isExpanded = ref.isExpanded;
      var isDisabled = ref.isDisabled;
      return {
        opacity: isDisabled ? 0.4 : 1,
        transform: isExpanded ? 'rotate(-180deg)' : null,
        transition: 'transform 0.2s',
        transformOrigin: 'center'
      };
    }
  },
  render: function render(h) {
    return h(CIcon.CIcon, {
      class: this.className,
      props: {
        size: this.size || '1.25em',
        name: this.name || 'chevron-down'
      },
      attrs: this.computedAttrs,
      on: this.computedListeners
    });
  }
};
exports.CAccordion = CAccordion;
exports.CAccordionHeader = CAccordionHeader;
exports.CAccordionIcon = CAccordionIcon;
exports.CAccordionItem = CAccordionItem;
exports.CAccordionPanel = CAccordionPanel;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(8);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

__webpack_require__(14);

__webpack_require__(5);

__webpack_require__(9);

__webpack_require__(16);

__webpack_require__(20);

var CModal = __webpack_require__(66);

__webpack_require__(17);

__webpack_require__(13);

__webpack_require__(6);
/**
 * Hey! Welcome to @chakra-ui/vue AlertDialog
 *
 * AlertDialog component is used interrupt the user with
 * a mandatory confirmation or action.
 *
 * An alert dialog is a modal dialog that interrupts the user's
 * workflow to communicate an important message and acquire a response.
 * Examples include action confirmation prompts and error message confirmations.
 * The `alertdialog` role enables assistive technologies and browsers to
 * distinguish alert dialogs from other dialogs so they have the option
 * of giving alert dialogs special treatment, such as playing a system alert sound.
 *
 * @see Docs     https://vue.chakra-ui.com/alertdialog
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CAlertDialog/CAlertDialog.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CAlertDialog/accessibility.md
 * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#alertdialog
 */


var formatIds = function formatIds(id) {
  return {
    content: "alert-dialog-" + id,
    header: "alert-dialog-" + id + "-label",
    body: "alert-dialog-" + id + "-desc"
  };
};
/**
 * CAlertDialog component
 *
 * The wrapper for alertdialog components. It provides context and state for the dialog.
 *
 * @extends CModal
 * @see Docs https://vue.chakra-ui.com/alertdialog
 */


var CAlertDialog = {
  name: 'CAlertDialog',
  functional: true,
  props: {
    isOpen: {
      type: Boolean,
      default: false
    },
    onClose: {
      type: Function,
      default: function _default() {
        return null;
      }
    },
    leastDestructiveRef: [utils.HTMLElement, Object]
  },
  render: function render(h, ref) {
    var slots = ref.slots;
    var props = ref.props;
    var data = ref.data;
    return h(CModal.CModal, {
      props: {
        isOpen: props.isOpen,
        onClose: props.onClose,
        initialFocusRef: props.leastDestructiveRef,
        formatIds: formatIds
      },
      attrs: Object.assign({}, data.attrs, {
        'data-chakra-component': 'CAlertDialog'
      })
    }, slots().default);
  }
};
/**
 * CAlertDialogContent component
 *
 * The wrapper for the alert dialog's content.
 *
 * @extends CModalContent
 * @see Docs https://vue.chakra-ui.com/alertdialog
 */

var CAlertDialogContent = {
  name: 'CAlertDialogContent',
  functional: true,
  render: function render(h, ref) {
    var data = ref.data;
    var slots = ref.slots;
    return h(CModal.CModalContent, {
      attrs: Object.assign({}, {
        role: 'alertdialog'
      }, data.attrs, {
        'data-chakra-component': 'CAlertDialogContent'
      })
    }, slots().default);
  }
};
/**
 * CAlertDialogOverlay component
 *
 * The dimmed overlay behind the dialog.
 *
 * @extends CModalOverlay
 * @see Docs https://vue.chakra-ui.com/alertdialog
 */

var CAlertDialogOverlay = Object.assign({}, CModal.CModalOverlay, {
  name: 'CAlertDialogOverlay'
});
/**
 * CAlertDialogBody component
 *
 * Should contain the description announced by screen readers
 *
 * @extends CModalBody
 * @see Docs https://vue.chakra-ui.com/alertdialog
 */

var CAlertDialogBody = Object.assign({}, CModal.CModalBody, {
  name: 'CAlertDialogBody'
});
/**
 * CAlertDialogHeader component
 *
 * Should contain the title announced by screen readers
 *
 * @extends CModalHeader
 * @see Docs https://vue.chakra-ui.com/alertdialog
 */

var CAlertDialogHeader = Object.assign({}, CModal.CModalHeader, {
  name: 'CAlertDialogHeader'
});
/**
 * CAlertDialogFooter component
 *
 * Should contain the actions of the dialog
 *
 * @extends CModalFooter
 * @see Docs https://vue.chakra-ui.com/alertdialog
 */

var CAlertDialogFooter = Object.assign({}, CModal.CModalFooter, {
  name: 'CAlertDialogFooter'
});
/**
 * CAlertDialogCloseButton component
 *
 * The button that closes the dialog.
 *
 * @extends CModalCloseButton
 * @see Docs https://vue.chakra-ui.com/alertdialog
 */

var CAlertDialogCloseButton = Object.assign({}, CModal.CModalCloseButton, {
  name: 'CAlertDialogCloseButton'
});
exports.CAlertDialog = CAlertDialog;
exports.CAlertDialogBody = CAlertDialogBody;
exports.CAlertDialogCloseButton = CAlertDialogCloseButton;
exports.CAlertDialogContent = CAlertDialogContent;
exports.CAlertDialogFooter = CAlertDialogFooter;
exports.CAlertDialogHeader = CAlertDialogHeader;
exports.CAlertDialogOverlay = CAlertDialogOverlay;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);
/**
 * Hey! Welcome to @chakra-ui/vue AspectRatioBox
 *
 * AspectRatioBox component is used to embed responsive
 * videos and maps, etc. It uses a very common [padding hack](https://css-tricks.com/aspect-ratio-boxes/) to achieve this.
 *
 * There are times when it comes in handy to build a box
 * with a specific aspect ratio, given a certain width.
 * This utility component applies CSS to ::before pseudo-element
 * in order to achieve set aspect ratio.
 *
 * @see Docs     https://vue.chakra-ui.com/aspectratiobox
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CAspectRatioBox/CAspectRatioBox.js
 */

/**
 * CAspectRatioBox component
 *
 * The wrapper that clones it's children
 * to achieve the set aspect ratio.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/aspectratiobox
 */


var CAspectRatioBox = {
  name: 'CAspectRatioBox',
  mixins: [utils.createStyledAttrsMixin('CAspectRatioBox')],
  props: {
    ratio: {
      type: Number,
      default: 4 / 3
    }
  },
  computed: {
    componentStyles: function componentStyles() {
      return {
        position: 'relative',
        _before: {
          h: '0px',
          content: '""',
          d: 'block',
          pb: 1 / this.ratio * 100 + "%"
        }
      };
    }
  },
  render: function render(h) {
    var child = this.$slots.default[0];

    if (!child) {
      return;
    }

    var vnode = utils.cloneVNode(child, h);
    var clone = h(vnode.componentOptions.Ctor, Object.assign({}, vnode.data, vnode.componentOptions.listeners || {}, {
      props: Object.assign({}, vnode.data.props || {}, vnode.componentOptions.propsData),
      attrs: Object.assign({}, {
        position: 'absolute',
        w: 'full',
        h: 'full',
        top: 0,
        left: 0
      }, vnode.data.attrs)
    }), vnode.componentOptions.children || []);
    return h('div', {
      class: this.className,
      attrs: this.computedAttrs,
      on: this.computedListeners
    }, [clone]);
  }
};
exports.default = CAspectRatioBox;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

var avatar_styles = __webpack_require__(67);
/**
 * Hey! Welcome to @chakra-ui/vue Avatar
 *
 * The Avatar component is used to represent user, and displays the profile picture,
 * initials or fallback icon.
 *
 * @see Docs     https://vue.chakra-ui.com/avatar
 * @ally Avatar  The CAvatar component by default applies the `alt` attribute from the `src` prop. It also can be overwritten by passing the `alt` attribute
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CAvatar/CAvatar.js
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * @description Generate Avatar initials from name string
 * @param {String} name
 * @returns {String} Avatar Initials
 */


var getInitials = function getInitials(name) {
  var ref = name.split(' ');
  var firstName = ref[0];
  var lastName = ref[1];

  if (firstName && lastName) {
    return "" + firstName.charAt(0) + lastName.charAt(0);
  } else {
    return firstName.charAt(0);
  }
};
/**
 * CAvatarBadge component
 *
 * Avatar badge used to indicate the avatar status
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/avatar
 */


var CAvatarBadge = {
  name: 'CAvatarBadge',
  mixins: [utils.createStyledAttrsMixin('CAvatarBadge')],
  props: {
    size: [String, Number, Array]
  },
  computed: {
    componentStyles: function componentStyles() {
      var borderColorStyle = {
        light: 'white',
        dark: 'gray.800'
      };
      return {
        w: this.size,
        h: this.size,
        position: 'absolute',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        transform: 'translate(25%, 25%)',
        bottom: '0',
        right: '0',
        border: '0.2em solid',
        borderColor: borderColorStyle[this.colorMode],
        rounded: 'full'
      };
    }
  },
  render: function render(h) {
    return h('div', {
      class: this.className,
      on: this.computedListeners,
      attrs: this.computedAttrs
    });
  }
};
/**
 * CAvatarName component
 *
 * Avatar name component displays the fallback initials fallback
 * for the Avatar in case the image fails to load, and before the
 * image loads.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/avatar
 */

var CAvatarName = {
  name: 'CAvatarName',
  mixins: [utils.createStyledAttrsMixin('CAvatarName')],
  props: {
    name: [String, Array],
    size: [String, Array]
  },
  computed: {
    componentStyles: function componentStyles() {
      return {
        w: this.size,
        h: this.size,
        textAlign: 'center',
        textTransform: 'uppercase',
        fontWeight: 'medium'
      };
    }
  },
  render: function render(h) {
    return h('div', {
      class: this.className,
      attrs: Object.assign({}, {
        'aria-label': this.name
      }, this.computedAttrs),
      on: this.computedListeners
    }, [this.name && getInitials(this.name)]);
  }
};
/**
 * CDefaultAvatar component
 *
 * Default Avatar component shows fallback image of headshots.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/avatar
 */

var CDefaultAvatar = {
  name: 'CDefaultAvatar',
  functional: true,
  props: {
    size: [String, Number, Array]
  },
  render: function render(h, context) {
    var props = context.props;
    var data = context.data;
    var attrs = data.attrs;
    var domProps = data.domProps;
    return h(CBox.default, {
      attrs: Object.assign({}, {
        h: props.size,
        w: props.size,
        lineHeight: '1rem'
      }, data && attrs || {}, {
        'data-chakra-component': 'CDefaultAvatar'
      }),
      domProps: Object.assign({}, domProps, {
        innerHTML: "\n        <svg fill=\"#fff\" viewBox=\"0 0 128 128\" role=\"img\">\n          <g>\n            <path d=\"M103,102.1388 C93.094,111.92 79.3504,118 64.1638,118 C48.8056,118 34.9294,111.768 25,101.7892 L25,95.2 C25,86.8096 31.981,80 40.6,80 L87.4,80 C96.019,80 103,86.8096 103,95.2 L103,102.1388 Z\" />\n            <path d=\"M63.9961647,24 C51.2938136,24 41,34.2938136 41,46.9961647 C41,59.7061864 51.2938136,70 63.9961647,70 C76.6985159,70 87,59.7061864 87,46.9961647 C87,34.2938136 76.6985159,24 63.9961647,24\" />\n          </g>\n        </svg>\n      "
      })
    });
  }
};
/**
 * CAvatar component
 *
 * Avatar component shows images of headshots
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/avatar
 */

var CAvatar = {
  name: 'CAvatar',
  mixins: [utils.createStyledAttrsMixin('CAvatar')],
  props: {
    size: {
      type: String,
      default: 'md'
    },
    showBorder: {
      type: Boolean,
      default: true
    },
    name: [String, Array],
    src: [String, Array],
    borderColor: [String]
  },
  data: function data() {
    return {
      image: undefined,
      hasLoaded: false
    };
  },
  computed: {
    componentStyles: function componentStyles() {
      var styles = avatar_styles.useAvatarStyles({
        size: this.size,
        name: this.name,
        showBorder: this.showBorder,
        borderColor: this.borderColor,
        theme: this.theme,
        colorMode: this.colorMode
      });
      var size = styles.size;
      var rest = objectWithoutProperties(styles, ["size"]);
      var _avatarStyles = rest;
      return Object.assign({}, {
        w: size,
        h: size,
        fontSize: this.fontSize,
        lineHeight: this.lineHeight,
        verticalAlign: 'top'
      }, _avatarStyles);
    },
    lineHeight: function lineHeight() {
      var sizeKey = avatar_styles.avatarSizes[this.size];
      var lineHeight = this.theme.sizes[sizeKey];
      return lineHeight;
    },
    fontSize: function fontSize() {
      return "calc(" + this.lineHeight + " / 2.5)";
    }
  },
  created: function created() {
    // Should only invoke window.Image in the browser.
    if (false) {}
  },
  methods: {
    loadImage: function loadImage(src) {
      var this$1 = this;

      if (!utils.canUseDOM) {
        return;
      }

      var image = new window.Image();
      image.src = src;

      image.onload = function (event) {
        this$1.hasLoaded = true;
        this$1.$emit('load', event);
      };

      image.onerror = function (event) {
        this$1.hasLoaded = false;
        this$1.$emit('error', event);
      };
    }
  },
  render: function render(h) {
    var this$1 = this;
    /**
     * @description Render child nodes for avatar
     * @returns {Vue.VNode}
     */

    var renderChildren = function renderChildren() {
      if (this$1.src && this$1.hasLoaded) {
        return h(CBox.default, {
          props: {
            as: 'img'
          },
          attrs: {
            w: '100%',
            h: '100%',
            rounded: 'full',
            objectFit: 'cover',
            alt: this$1.name,
            src: this$1.src
          }
        });
      }

      if (!this$1.src || this$1.src && !this$1.hasLoaded) {
        if (this$1.name) {
          return h(CAvatarName, {
            props: {
              name: this$1.name
            },
            attrs: {
              w: this$1.lineHeight,
              h: this$1.lineHeight
            }
          });
        } else {
          return h(CDefaultAvatar, {
            attrs: {
              'aria-label': this$1.name,
              w: '100%',
              h: '100%'
            }
          });
        }
      }
    };

    return h('div', {
      class: this.className,
      attrs: Object.assign({}, this.computedAttrs, {
        'data-chakra-component': 'CAvatar'
      }),
      on: this.computedListeners
    }, [renderChildren(), this.$slots.default]);
  }
};
exports.CAvatar = CAvatar;
exports.CAvatarBadge = CAvatarBadge;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

__webpack_require__(6);

var avatar_styles = __webpack_require__(67);

var CFlex = __webpack_require__(21);
/**
 * Hey! Welcome to @chakra-ui/vue AvatarGroup
 *
 * The AvatarGroup component serves a wrapper that stacks multiple Avatars together.
 *
 * @see Docs     https://vue.chakra-ui.com/avatar
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CAvatarGroup/CAvatarGroup.js
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * CMoreAvatarLabel component
 *
 * For excess avatars, the CMoreAvatarLabel displays an indicator of the surplus avatars
 *
 * @extends CFlex
 * @see Docs https://vue.chakra-ui.com/avatar
 */


var CMoreAvatarLabel = {
  name: 'CMoreAvatarLabel',
  functional: true,
  inject: ['$chakraColorMode', '$chakraTheme'],
  props: Object.assign({}, {
    size: [String, Array],
    label: String
  }, CFlex.flexProps),
  render: function render(h, ref) {
    var injections = ref.injections;
    var props = ref.props;
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["injections", "props", "data"]);
    var rest = rest$1;
    var size = props.size;
    var label = props.label;
    var rest$2 = objectWithoutProperties(props, ["size", "label"]);
    var avatarProps = rest$2;
    var colorMode = injections.$chakraColorMode();
    var theme = injections.$chakraTheme();
    var borderColor = {
      light: '#fff',
      dark: 'gray.800'
    };
    var bg = {
      light: 'gray.200',
      dark: 'whiteAlpha.400'
    };
    var sizeKey = avatar_styles.avatarSizes[size];
    var _size = theme.sizes[sizeKey];
    var fontSize = "calc(" + _size + " / 2.75)";
    return h(CFlex.CFlex, Object.assign({}, rest, {
      props: utils.pickProperty(avatarProps),
      attrs: Object.assign({}, {
        align: 'center',
        justify: 'center',
        h: avatar_styles.avatarSizes[size],
        w: avatar_styles.avatarSizes[size],
        bg: bg[colorMode],
        color: 'inherit',
        rounded: 'full',
        border: '2px',
        borderColor: borderColor[colorMode],
        fontSize: fontSize
      }, data.attrs, {
        'data-chakra-component': 'CMoreAvatarLabel'
      })
    }), label);
  }
};
/**
 * CAvatarGroup component
 *
 * Clones all CAvatar children and stacks them together.
 *
 * @extends CFlex
 * @see Docs https://vue.chakra-ui.com/avatar
 */

var CAvatarGroup = {
  name: 'CAvatarGroup',
  functional: true,
  props: Object.assign({}, {
    groupSize: {
      type: [Number, String, Array],
      default: 'md'
    },
    borderColor: [String, Array],
    max: [Number, String, Array],
    spacing: {
      type: [Number, String, Array],
      default: -3
    }
  }, CFlex.flexProps),
  render: function render(h, ref) {
    var slots = ref.slots;
    var props = ref.props;
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["slots", "props", "data"]);
    var rest = rest$1; // Get the number of slot nodes inside AvatarGroup

    var children = slots().default.filter(function (e) {
      return e.tag;
    });
    var count = children.length;
    var max = parseInt(props.max, 10); // Apply styles to slot VNodes.

    var clones = children.map(function (node, index) {
      var isFirstAvatar = index === 0;

      if (!props.max || max && index < max) {
        // Change VNode component options
        var ref = node.data;
        var attrs = ref.attrs;
        attrs.ml = isFirstAvatar ? 0 : props.spacing;
        attrs.borderColor = props.borderColor || attrs.borderColor;
        attrs.zIndex = count - index;
        var propsData = node.componentOptions;
        propsData.size = props.groupSize;
        propsData.showBorder = true;
        node.componentOptions.propsData = Object.assign({}, node.componentOptions.propsData, propsData);
        node.data.attrs = Object.assign({}, node.data.attrs, attrs);
        return node;
      }

      if (max && index === max) {
        return h(CMoreAvatarLabel, {
          props: {
            size: props.groupSize,
            label: "+" + (count - max)
          },
          attrs: {
            ml: props.spacing
          }
        });
      }
    });
    return h(CFlex.CFlex, Object.assign({}, rest, {
      props: Object.assign({}, {
        alignItems: 'center'
      }, utils.pickProperty(props)),
      attrs: Object.assign({}, {
        zIndex: 0
      }, data.attrs, {
        'data-chakra-component': 'CAvatarGroup'
      })
    }), clones);
  }
};
exports.default = CAvatarGroup;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var badge_styles = __webpack_require__(57);
/**
 * Hey! Welcome to @chakra-ui/vue Badge
 *
 * The Badge component is used to highlight an item's status for quick recognition.
 *
 * @see Docs     https://vue.chakra-ui.com/badge
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CBadge/CBadge.js
 */

/**
 * CBadge component
 *
 * Used to highlight an item's status for quick recognition.
 *
 * @see Docs https://vue.chakra-ui.com/badge
 */


var CBadge = {
  name: 'CBadge',
  mixins: [utils.createStyledAttrsMixin('CBadge')],
  props: {
    variant: {
      type: String,
      default: 'subtle'
    },
    variantColor: {
      type: String,
      default: 'gray'
    },
    as: {
      type: String,
      default: 'div'
    }
  },
  computed: {
    badgeStyles: function badgeStyles() {
      return badge_styles.useBadgeStyle({
        theme: this.theme,
        colorMode: this.colorMode,
        color: this.variantColor,
        variant: this.variant
      });
    },
    componentStyles: function componentStyles() {
      return Object.assign({}, {
        d: 'inline-block',
        textTransform: 'uppercase',
        fontSize: 'xs',
        fontFamily: 'body',
        px: 1,
        rounded: 'sm',
        fontWeight: 'bold',
        whiteSpace: 'nowrap',
        verticalAlign: 'middle'
      }, this.badgeStyles);
    }
  },
  render: function render(h) {
    return h(this.as, {
      class: this.className,
      attrs: this.computedAttrs
    }, this.$slots.default);
  }
};
exports.default = CBadge;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

__webpack_require__(6);

var CLink = __webpack_require__(87);
/**
 * Hey! Welcome to @chakra-ui/vue Breadcrumb
 *
 * Breadcrumbs, or a breadcrumb navigation, can help to enhance
 * how users navigate to previous page levels of a website,
 * especially if that website has many pages or products.
 *
 * A breadcrumb trail consists of a list of links to the parent pages
 * of the current page in hierarchical order. It helps users find their
 * place within a website or web application. Breadcrumbs are often
 * placed horizontally before a page's main content.
 *
 * @see Docs     https://vue.chakra-ui.com/breadcrumb
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CBreadcrumb/CBreadcrumb.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CBreadcrumb/accessibility.md
 * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#breadcrumb
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
* CBreadcrumbSeparator component
*
* The visual separator between each breadcrumb link
*
* @see Docs https://vue.chakra-ui.com/breadcrumb
*/


var CBreadcrumbSeparator = {
  name: 'CBreadcrumbSeparator',
  mixins: [utils.createStyledAttrsMixin('CBreadcrumbSeparator')],
  props: {
    spacing: [String, Number, Array],
    separator: [String, Object]
  },
  computed: {
    componentStyles: function componentStyles() {
      return {
        mx: this.spacing
      };
    }
  },
  render: function render(h) {
    return h('span', {
      class: this.className,
      attrs: Object.assign({}, {
        role: 'presentation'
      }, this.computedAttrs),
      on: this.computedListeners
    }, [this.separator]);
  }
};
/**
* Span component
*
* Wrapper for text breadcrumbs
*
* @see Docs https://vue.chakra-ui.com/breadcrumb
*/

var Span = {
  name: 'Span',
  functional: true,
  render: function render(h, ref) {
    var data = ref.data;
    var slots = ref.slots;
    var rest$1 = objectWithoutProperties(ref, ["data", "slots"]);
    var rest = rest$1;
    return h(CBox.default, Object.assign({}, rest, {
      props: {
        as: 'span'
      },
      attrs: data.attrs
    }), slots().default);
  }
};
/**
* CBreadcrumbLink component
*
* The breadcrumb link
*
* @see Docs https://vue.chakra-ui.com/breadcrumb
*/

var CBreadcrumbLink = {
  name: 'CBreadcrumbLink',
  mixins: [utils.createStyledAttrsMixin('CBreadcrumbLink')],
  props: {
    isCurrentPage: Boolean,
    as: [String, Object],
    to: String
  },
  computed: {
    component: function component() {
      return this.isCurrentPage ? Span : CLink.default;
    }
  },
  render: function render(h) {
    return h(this.component, {
      class: this.className,
      props: utils.pickProperty(this.$props),
      attrs: Object.assign({}, {
        'aria-current': this.isCurrentPage ? 'page' : null
      }, this.computedAttrs)
    }, this.$slots.default);
  }
};
/**
* CBreadcrumbItem component
*
* Individual breadcrumb element containing a link and a divider.
*
* @see Docs https://vue.chakra-ui.com/breadcrumb
*/

var CBreadcrumbItem = {
  name: 'CBreadcrumbItem',
  mixins: [utils.createStyledAttrsMixin('CBreadcrumbItem')],
  props: {
    isCurrentPage: Boolean,
    isLastChild: Boolean,
    separator: [Object, String],
    addSeparator: Boolean,
    spacing: [String, Number, Array]
  },
  computed: {
    componentStyles: function componentStyles() {
      return {
        display: 'inline-flex',
        alignItems: 'center'
      };
    }
  },
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default.filter(function (e) {
      return e.tag;
    });
    var clones = children.map(function (vnode) {
      // If vnode is breadcrumb separator
      // i.e. (is reactive component)
      if (vnode.componentOptions) {
        // Kebabify to normalize tage name
        var tag = utils.kebabify(vnode.componentOptions.tag);

        if (tag === 'c-breadcrumb-separator') {
          var clone = utils.cloneVNodeElement(vnode, {
            props: {
              spacing: this$1.spacing,
              separator: this$1.separator
            },
            children: vnode.componentOptions.children || this$1.separator
          }, h);
          return clone;
        }

        if (tag === 'c-breadcrumb-link') {
          var clone$1 = utils.cloneVNodeElement(vnode, {
            props: {
              isCurrentPage: this$1.isCurrentPage
            }
          }, h);
          return clone$1;
        }
      }
    });
    return h('li', {
      class: this.className,
      attrs: this.computedAttrs,
      on: this.computedListeners
    }, clones.concat([!this.isLastChild && this.addSeparator && h(CBreadcrumbSeparator, {
      props: {
        spacing: this.spacing,
        separator: this.separator
      }
    })]));
  }
};
/**
* CBreadcrumb component
*
* The wrapper container for all breadcrumbs
*
* @see Docs https://vue.chakra-ui.com/breadcrumb
*/

var CBreadcrumb = {
  name: 'CBreadcrumb',
  mixins: [utils.createStyledAttrsMixin('CBreadcrumb')],
  props: {
    spacing: {
      type: [String, Number, Array],
      default: 2
    },
    addSeparator: {
      type: Boolean,
      default: true
    },
    separator: {
      type: [String, Object],
      default: '/'
    }
  },
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;

    if (!children) {
      console.error('[Chakra-ui:Breadcrumb]: Breadcrumb component should have at least one child');
      return null;
    }

    var cleaned = utils.cleanChildren(children);
    var clones = cleaned.map(function (node, index, array) {
      return utils.cloneVNodeElement(node, {
        props: {
          addSeparator: this$1.addSeparator,
          separator: this$1.separator,
          spacing: this$1.spacing,
          isLastChild: array.length === index + 1
        }
      }, h);
    });
    return h('nav', {
      class: this.className,
      attrs: Object.assign({}, {
        'aria-label': 'breadcrumb'
      }, this.computedAttrs),
      on: this.computedListeners
    }, [h('ol', clones)]);
  }
};
exports.CBreadcrumb = CBreadcrumb;
exports.CBreadcrumbItem = CBreadcrumbItem;
exports.CBreadcrumbLink = CBreadcrumbLink;
exports.CBreadcrumbSeparator = CBreadcrumbSeparator;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

__webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);
/**
 * Hey! Welcome to @chakra-ui/vue ButtonGroup
 *
 * ButtonGroup component allows the user to group a
 * related collection of buttons in one visual region.
 *
 * @see Docs     https://vue.chakra-ui.com/button
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CButtonGroup/CButtonGroup.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CButtonGroup/accessibility.md
 * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#button
 */

/**
 * CButtonGroup component
 *
 * Wrapper for children `CButton` components
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/button
 */


var CButtonGroup = {
  name: 'CButtonGroup',
  functional: true,
  props: {
    size: [String, Array],
    variantColor: [String, Array],
    variant: [String, Array],
    isAttached: Boolean,
    spacing: {
      type: [Number, Array, String],
      default: 2
    }
  },
  render: function render(h, context) {
    var props = context.props;
    var data = context.data;
    var slots = context.slots;
    var listeners = context.listeners;
    var children = slots().default.filter(function (e) {
      return e.tag;
    });
    var count = children.length;
    var clones = children.map(function (node, index) {
      var isFirst = index === 0;
      var isLast = index === count - 1;
      var ref = node.data;
      var attrs = ref.attrs;
      var ref$1 = node.componentOptions;
      var propsData = ref$1.propsData;
      propsData.size = props.size || propsData.size;
      propsData.variantColor = propsData.variantColor || props.variantColor;
      propsData.variant = propsData.variant || props.variant;
      propsData.rounded = propsData.rounded || props.rounded;
      propsData._focus = {
        boxShadow: 'outline',
        zIndex: 1
      }; // Radius adjustment

      node.data.attrs = Object.assign({}, attrs, !isLast && !props.isAttached && {
        mr: props.spacing
      }, isFirst && props.isAttached && {
        'rounded-right': 0
      }, isLast && props.isAttached && {
        'rounded-left': 0
      }, !isLast && props.isAttached && {
        'border-right': 0
      }, !isFirst && !isLast && props.isAttached && {
        rounded: 0
      }, {
        _focus: {
          boxShadow: 'outline',
          zIndex: 1
        }
      });
      node.componentOptions.propsData = Object.assign({}, node.componentOptions.propsData, propsData);
      return node;
    });
    return h(CBox.default, Object.assign({}, data, {
      attrs: Object.assign({}, {
        d: 'inline-block'
      }, data.attrs, {
        role: 'group',
        'data-chakra-component': 'CButtonGroup'
      }),
      on: listeners
    }), clones);
  }
};
exports.default = CButtonGroup;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(8);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

var CIcon = __webpack_require__(9);

var props_types = __webpack_require__(6);

var CVisuallyHidden = __webpack_require__(18);

var CControlBox = __webpack_require__(58);

var checkbox_styles = __webpack_require__(70);
/**
 * Hey! Welcome to @chakra-ui/vue Checkbox
 *
 * CCheckbox component is used in forms when a user needs to select multiple values from several options.
 *
 * @see Docs     https://vue.chakra-ui.com/checkbox
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CCheckbox/CCheckbox.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CCheckbox/accessibility.md
 * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#button
 */

/**
 * CCheckbox component
 *
 * Checkbox component is used in forms when a user needs to select multiple values from several options.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/checkbox
 */


var CCheckbox = {
  name: 'CCheckbox',
  mixins: [utils.createStyledAttrsMixin('CCheckbox')],
  model: {
    prop: 'isChecked',
    event: 'change'
  },
  props: {
    id: String,
    name: String,
    value: [String, Boolean],
    ariaLabel: String,
    ariaLabelledBy: String,
    variantColor: {
      type: String,
      default: 'blue'
    },
    defaultIsChecked: Boolean,
    isChecked: {
      type: Boolean,
      default: false
    },
    isFullWidth: Boolean,
    size: {
      type: String,
      default: 'md'
    },
    isDisabled: Boolean,
    isInvalid: Boolean,
    isReadOnly: Boolean,
    isIndeterminate: Boolean,
    iconColor: props_types.StringArray,
    iconSize: {
      type: props_types.StringNumber,
      default: '10px'
    }
  },
  computed: {
    checkBoxStyles: function checkBoxStyles() {
      return checkbox_styles.useCheckboxStyle({
        color: this.variantColor,
        size: this.size,
        colorMode: this.colorMode
      });
    },
    componentStyles: function componentStyles() {
      return {
        display: 'inline-flex',
        verticalAlign: 'top',
        alignItems: 'center',
        width: this.isFullWidth ? 'full' : undefined,
        cursor: this.isDisabled ? 'not-allowed' : 'pointer'
      };
    },
    _id: function _id() {
      return this.id || "checkbox-" + utils.useId(4);
    }
  },
  created: function created() {
    // Ensure that the use of the variantColor props is consistent with theme.
    utils.useVariantColorWarning(this.theme, 'Checkbox', this.variantColor);
  },
  methods: {
    handleChange: function handleChange(e) {
      this.$emit('change', !this.isChecked, e);
    }
  },
  render: function render(h) {
    var children = this.$slots.default;
    return h('label', {
      class: this.className,
      attrs: Object.assign({}, {
        for: this._id
      }, this.computedAttrs)
    }, [h(CVisuallyHidden.default, {
      props: {
        as: 'input'
      },
      domProps: {
        value: this.value,
        defaultChecked: this.isReadOnly ? undefined : this.defaultIsChecked,
        checked: this.isReadOnly ? this.isChecked : this.defaultIsChecked ? undefined : this.isChecked
      },
      attrs: {
        name: this.name,
        type: 'checkbox',
        id: this._id,
        'aria-label': this.ariaLabel,
        'aria-labelledby': this.ariaLabelledBy,
        disabled: this.isDisabled,
        readOnly: this.isReadOnly,
        'aria-readonly': this.isReadOnly,
        'aria-invalid': this.isInvalid,
        'aria-checked': this.isIndeterminate ? 'mixed' : this.isChecked
      },
      on: {
        change: this.isReadOnly ? undefined : this.handleChange
      }
    }), h(CControlBox.default, {
      attrs: Object.assign({}, {
        opacity: this.isReadOnly ? 0.8 : 1
      }, this.checkBoxStyles)
    }, [h(CIcon.CIcon, {
      props: {
        name: this.isIndeterminate ? 'minus' : 'check',
        size: this.iconSize,
        color: this.iconColor,
        transition: 'transform 240ms, opacity 240ms'
      }
    })]), children && h(CBox.default, {
      attrs: {
        ml: 2,
        fontSize: this.size,
        fontFamily: 'body',
        userSelect: 'none',
        opacity: this.isDisabled ? 0.4 : 1
      }
    }, children)]);
  }
};
exports.default = CCheckbox;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

var props_types = __webpack_require__(6);
/**
 * Hey! Welcome to @chakra-ui/vue CCheckboxGroup
 *
 * CCheckboxGroup component allows the user to group a
 * related collection of checkboxes in one visual region.
 *
 * @see Docs     https://vue.chakra-ui.com/checkbox
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CCheckboxGroup/CCheckboxGroup.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CCheckbox/accessibility.md
 * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#button
 */

/**
 * CButtonGroup component
 *
 * Wrapper for children `CCheckbox` components
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/button
 */


var CCheckboxGroup = {
  name: 'CCheckboxGroup',
  mixins: [utils.createStyledAttrsMixin('CCheckboxGroup')],
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    name: String,
    variantColor: String,
    size: String,
    defaultValue: Array,
    isInline: Boolean,
    value: Array,
    spacing: {
      type: props_types.SNA,
      default: 2
    }
  },
  data: function data() {
    return {
      values: this.defaultValue || []
    };
  },
  computed: {
    isControlled: function isControlled() {
      return utils.isDef(this.value);
    },
    _values: function _values() {
      return this.isControlled ? this.value : this.values;
    },
    checkboxName: function checkboxName() {
      return this.name || "checkbox-group-" + utils.useId();
    }
  },
  methods: {
    /**
     * Handles change event for checkbox group
     * @param {Event} event Event object
     */
    onChange: function onChange(val, event) {
      var ref = event.target;
      var checked = ref.checked;
      var value = ref.value;
      var newValues;

      if (checked) {
        newValues = this._values.concat([value]);
      } else {
        newValues = this._values.filter(function (val) {
          return val !== value;
        });
      }

      if (!this.isControlled) {
        this.values = newValues;
      }

      this.$emit('change', newValues);
    }
  },
  render: function render(h) {
    var this$1 = this;
    var children = utils.cleanChildren(this.$slots.default);
    var clones = children.map(function (vnode, index) {
      var isLastCheckbox = children.length === index + 1;
      var spacingProps = this$1.isInline ? {
        mr: this$1.spacing
      } : {
        mb: this$1.spacing
      };
      var el = utils.cloneVNodeElement(vnode, {
        props: {
          size: this$1.size,
          variantColor: this$1.variantColor,
          name: this$1.checkboxName + "-" + index,
          isChecked: this$1._values.includes(vnode.componentOptions.propsData.value)
        },
        on: {
          change: this$1.onChange
        }
      }, h);
      return h(CBox.default, {
        attrs: Object.assign({}, {
          display: this$1.isInline ? 'inline-block' : 'block'
        }, !isLastCheckbox && spacingProps)
      }, [el]);
    });
    return h('div', {
      class: [this.className],
      attrs: Object.assign({}, this.computedAttrs, {
        role: 'group'
      })
    }, clones);
  }
};
exports.default = CCheckboxGroup;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

var css = __webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

var templateObject$1 = Object.freeze(["\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n"]);
var templateObject = Object.freeze(["\n  0% {\n    stroke-dasharray: 1, 400;\n    stroke-dashoffset: 0;\n  }\n\n  50% {\n    stroke-dasharray: 400, 400;\n    stroke-dashoffset: -100;\n  }\n\n  100% {\n    stroke-dasharray: 400, 400;\n    stroke-dashoffset: -300;\n  }\n"]);
var circularProgressCircle = css.keyframes(templateObject);
var spin = css.keyframes(templateObject$1);
/**
 * Computes styles for circular progress component. These styles were adapted from React's Chakra UI implementation by @thesegunadebayo
 * @param {{min: Number, max: Number, size: String|Number, value: Number, angle: Number, thickness: Number, trackColor: String, color: String, capIsRound: Boolean, isIndeterminate: Boolean}} param0
 * @returns {Object} CircularProgress styles object
 */

function getComputedProps(ref) {
  var min = ref.min;
  var max = ref.max;
  var size = ref.size;
  var value = ref.value;
  var angle = ref.angle;
  var thickness = ref.thickness;
  var trackColor = ref.trackColor;
  var color = ref.color;
  var capIsRound = ref.capIsRound;
  var isIndeterminate = ref.isIndeterminate;
  var isTransitioned = ref.isTransitioned;
  var radius = 50;
  var diameter = radius * 2;
  var circumference = diameter * Math.PI;
  var strokeDasharray = Math.round(circumference * 1000) / 1000;
  var viewBox = diameter / (1 - thickness / 2);
  var viewBoxAttr = viewBox / 2 + " " + viewBox / 2 + " " + viewBox + " " + viewBox;
  var strokeWidth = thickness / 2 * viewBox;
  var progress = 1 - (value - min) / (max - min);
  var strokeDashoffset = progress * circumference;

  function getCircleProps(ref) {
    var thickness = ref.thickness;
    var offset = ref.offset;
    var color = ref.color;
    return Object.assign({}, {
      color: color,
      fill: 'transparent',
      stroke: 'currentColor'
    }, isTransitioned && {
      transition: 'all 250ms'
    }, {
      'stroke-width': thickness,
      'stroke-dasharray': strokeDasharray,
      'stroke-dashoffset': offset,
      cx: viewBox,
      cy: viewBox,
      r: radius
    });
  }

  return {
    rootData: {
      width: '1em',
      height: '1em',
      fontSize: size,
      display: 'inline-block',
      position: 'relative',
      verticalAlign: 'middle',
      role: 'progressbar',
      'aria-valuemin': min,
      'aria-valuemax': max,
      'aria-valuenow': isIndeterminate ? null : value
    },
    svgData: Object.assign({}, {
      viewBox: viewBoxAttr,
      verticalAlign: 'top',
      transform: "rotate3d(0, 0, 1, " + (angle - 90) + "deg)",
      width: '100%',
      height: '100%'
    }, isIndeterminate && {
      transformOrigin: '50% 50%',
      animation: spin + " 2s linear infinite"
    }),
    trackCircleData: getCircleProps({
      thickness: strokeWidth,
      offset: 0,
      color: trackColor
    }),
    indicatorCircleData: Object.assign({}, capIsRound && {
      strokeLinecap: 'round'
    }, isIndeterminate && {
      transition: 'stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease',
      animation: circularProgressCircle + " 1.5s ease-in-out infinite",
      strokeDasharray: '1 400',
      strokeDashoffset: '0'
    }, getCircleProps({
      thickness: strokeWidth,
      offset: strokeDashoffset,
      color: color
    }), isTransitioned && {
      transition: 'all 250ms'
    }, {
      stroke: 'currentColor'
    }, getCircleProps({
      thickness: strokeWidth,
      offset: strokeDashoffset,
      color: color
    }))
  };
}
/**
 * Hey! Welcome to @chakra-ui/vue CircularProgress
 *
 * The Circular Progress component is used to indicates the progress for both determinate and indeterminate processes.
 *
 * @see Docs     https://vue.chakra-ui.com/circularprogress
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CCircularProgress/CCircularProgress.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CCircularProgress/accessibility.md
 */

/**
 * CCircularProgress component
 *
 * The test label that displays the progress percentage in the `CCircularProgress`
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/circularprogress
 */


var CCircularProgressLabel = {
  name: 'CCircularProgressLabel',
  mixins: [utils.createStyledAttrsMixin('CCircularProgressLabel')],
  computed: {
    componentStyles: function componentStyles() {
      return {
        position: 'absolute',
        left: '50%',
        top: '50%',
        lineHeight: '1',
        transform: 'translate(-50%, -50%)',
        fontSize: '0.25em'
      };
    }
  },
  render: function render(h) {
    return h(this.as, {
      class: [this.className],
      style: {
        fontVariantNumeric: 'tabular-nums'
      },
      attrs: this.computedAttrs
    }, this.$slots.default);
  }
};
/**
 * CCircularProgressLabel component
 *
 * Indicates the progress for both determinate and indeterminate processes.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/circularprogress
 */

var CCircularProgress = {
  name: 'CCircularProgress',
  functional: true,
  inject: ['$chakraColorMode'],
  props: {
    size: {
      type: String,
      default: '48px'
    },
    max: {
      type: Number,
      default: 100
    },
    min: {
      typs: Number,
      default: 0
    },
    isIndeterminate: Boolean,
    isTransitioned: {
      type: Boolean,
      default: true
    },
    thickness: {
      type: Number,
      default: 0.2
    },
    value: Number,
    angle: {
      type: Number,
      default: 0
    },
    capIsRound: Boolean,
    trackColor: {
      type: String,
      default: 'gray'
    },
    color: {
      type: String,
      default: 'blue'
    }
  },
  render: function render(h, context) {
    var data = context.data;
    var injections = context.injections;
    var props = context.props;
    var slots = context.slots;
    var colorMode = injections.$chakraColorMode();
    var _trackColor = {
      light: props.trackColor + ".100",
      dark: 'whiteAlpha.300'
    };
    var _color = {
      light: props.color + ".500",
      dark: props.color + ".200"
    };
    var ref = getComputedProps({
      min: props.min,
      max: props.max,
      value: props.value,
      size: props.size,
      angle: props.angle,
      thickness: props.thickness,
      capIsRound: props.capIsRound,
      isIndeterminate: props.isIndeterminate,
      color: _color[colorMode],
      trackColor: _trackColor[colorMode],
      isTransitioned: props.isTransitioned
    });
    var rootData = ref.rootData;
    var indicatorCircleData = ref.indicatorCircleData;
    var svgData = ref.svgData;
    var trackCircleData = ref.trackCircleData;
    return h(CBox.default, Object.assign({}, data, {
      props: props,
      attrs: Object.assign({}, rootData, data.attrs, {
        'data-chakra-component': 'CCircularProgress'
      })
    }), [h(CBox.default, {
      props: {
        as: 'svg'
      },
      attrs: svgData
    }, [h(CBox.default, {
      props: {
        as: 'circle'
      },
      attrs: trackCircleData
    }), h(CBox.default, {
      props: {
        as: 'circle'
      },
      attrs: indicatorCircleData
    })]), slots().default]);
  }
};
exports.CCircularProgress = CCircularProgress;
exports.CCircularProgressLabel = CCircularProgressLabel;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var props_types = __webpack_require__(6);

var badge_styles = __webpack_require__(57);
/**
 * Hey! Welcome to @chakra-ui/vue Code
 *
 * Code is a component used to display inline code.
 *
 * @see Docs     https://vue.chakra-ui.com/code
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CCode/CCode.js
 */

/**
 * CCode component
 *
 * Inline code component
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/code
 */


var CCode = {
  name: 'CCode',
  mixins: [utils.createStyledAttrsMixin('CCode')],
  props: {
    variantColor: {
      type: String,
      default: 'gray'
    },
    fontFamily: {
      type: props_types.SNA,
      default: 'mono'
    }
  },
  computed: {
    badgeStyle: function badgeStyle() {
      utils.useVariantColorWarning(this.theme, 'CCode', this.variantColor);
      return badge_styles.useBadgeStyle({
        variant: 'subtle',
        color: this.variantColor,
        colorMode: this.colorMode,
        theme: this.theme
      });
    },
    componentStyles: function componentStyles() {
      return Object.assign({}, {
        display: 'inline-block',
        fontSize: 'sm',
        px: '0.2em',
        fontFamily: 'mono',
        rounded: 'sm'
      }, this.badgeStyle);
    }
  },
  render: function render(h) {
    return h('code', {
      class: this.className,
      attrs: this.computedAttrs
    }, this.$slots.default);
  }
};
exports.default = CCode;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var css = __webpack_require__(1);

var templateObject = Object.freeze(["\n    html {\n      line-height: 1.15;\n      -webkit-text-size-adjust: 100%;\n    }\n\n    body {\n      margin: 0;\n    }\n\n    main {\n      display: block;\n    }\n\n    h1 {\n      font-size: 2em;\n      margin: 0.67em 0;\n    }\n\n    hr {\n      box-sizing: content-box;\n      height: 0;\n      overflow: visible;\n    }\n\n    pre {\n      font-family: monospace, monospace;\n      font-size: 1em;\n    }\n\n    a {\n      background-color: transparent;\n    }\n\n    abbr[title] {\n      border-bottom: none;\n      text-decoration: underline;\n      -webkit-text-decoration: underline dotted;\n      text-decoration: underline dotted;\n    }\n\n    b,\n    strong {\n      font-weight: bolder;\n    }\n\n    code,\n    kbd,\n    samp {\n      font-family: monospace, monospace;\n      font-size: 1em;\n    }\n\n    small {\n      font-size: 80%;\n    }\n\n    sub,\n    sup {\n      font-size: 75%;\n      line-height: 0;\n      position: relative;\n      vertical-align: baseline;\n    }\n\n    sub {\n      bottom: -0.25em;\n    }\n\n    sup {\n      top: -0.5em;\n    }\n\n    img {\n      border-style: none;\n    }\n\n    button,\n    input,\n    optgroup,\n    select,\n    textarea {\n      font-family: inherit;\n      font-size: 100%;\n      line-height: 1.15;\n      margin: 0;\n    }\n\n    button,\n    input {\n      overflow: visible;\n    }\n\n    button,\n    select {\n      text-transform: none;\n    }\n\n    button::-moz-focus-inner,\n    [type=\"button\"]::-moz-focus-inner,\n    [type=\"reset\"]::-moz-focus-inner,\n    [type=\"submit\"]::-moz-focus-inner {\n      border-style: none;\n      padding: 0;\n    }\n\n    fieldset {\n      padding: 0.35em 0.75em 0.625em;\n    }\n\n    legend {\n      box-sizing: border-box;\n      color: inherit;\n      display: table;\n      max-width: 100%;\n      padding: 0;\n      white-space: normal;\n    }\n\n    progress {\n      vertical-align: baseline;\n    }\n\n    textarea {\n      overflow: auto;\n    }\n\n    [type=\"checkbox\"],\n    [type=\"radio\"] {\n      box-sizing: border-box;\n      padding: 0;\n    }\n\n    [type=\"number\"]::-webkit-inner-spin-button,\n    [type=\"number\"]::-webkit-outer-spin-button {\n      -webkit-appearance: none !important;\n    }\n\n    input[type=\"number\"] {\n      -moz-appearance: textfield;\n    }\n\n    [type=\"search\"] {\n      -webkit-appearance: textfield;\n      outline-offset: -2px;\n    }\n\n    [type=\"search\"]::-webkit-search-decoration {\n      -webkit-appearance: none !important;\n    }\n\n    ::-webkit-file-upload-button {\n      -webkit-appearance: button;\n      font: inherit;\n    }\n\n    details {\n      display: block;\n    }\n\n    summary {\n      display: list-item;\n    }\n\n    template {\n      display: none;\n    }\n\n    [hidden] {\n      display: none !important;\n    }\n\n    html {\n      box-sizing: border-box;\n      font-family: sans-serif;\n    }\n\n    *,\n    *::before,\n    *::after {\n      box-sizing: border-box;\n    }\n\n    blockquote,\n    dl,\n    dd,\n    h1,\n    h2,\n    h3,\n    h4,\n    h5,\n    h6,\n    hr,\n    figure,\n    p,\n    pre {\n      margin: 0;\n    }\n\n    button {\n      background: transparent;\n      padding: 0;\n    }\n\n    fieldset {\n      margin: 0;\n      padding: 0;\n    }\n\n    ol,\n    ul {\n      margin: 0;\n      padding: 0;\n    }\n\n    html {\n      font-family: ", ";\n      line-height: 1.5;\n      -webkit-font-smoothing: antialiased;\n      -webkit-text-size-adjust: 100%;\n      text-rendering: optimizelegibility;\n    }\n\n    hr {\n      border-top-width: 1px;\n    }\n\n    img {\n      border-style: solid;\n    }\n\n    textarea {\n      resize: vertical;\n    }\n\n    button,\n    [role=\"button\"] {\n      cursor: pointer;\n    }\n\n    button::-moz-focus-inner {\n      border: 0 !important;\n    }\n\n    table {\n      border-collapse: collapse;\n    }\n\n    h1,\n    h2,\n    h3,\n    h4,\n    h5,\n    h6 {\n      font-size: inherit;\n      font-weight: inherit;\n    }\n\n    a {\n      color: inherit;\n      text-decoration: inherit;\n    }\n\n    button,\n    input,\n    optgroup,\n    select,\n    textarea {\n      padding: 0;\n      line-height: inherit;\n      color: inherit;\n    }\n\n    pre,\n    code,\n    kbd,\n    samp {\n      font-family: ", ";\n    }\n\n    img,\n    svg,\n    video,\n    canvas,\n    audio,\n    iframe,\n    embed,\n    object {\n      vertical-align: middle;\n      display: block;\n    }\n\n    img,\n    video {\n      max-width: 100%;\n      height: auto;\n    }\n  "]);

function useTailwindPreflight(theme) {
  css.injectGlobal(templateObject, theme.fonts.body, theme.fonts.mono);
}
/**
 * Hey! Welcome to @chakra-ui/vue CReset
 *
 * CReset component injects global styles.
 *
 * @see Docs     https://vue.chakra-ui.com/radio
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CReset/CReset.js
 */


var defaultConfig = function defaultConfig(theme) {
  return {
    light: {
      color: theme.colors.gray[800],
      bg: undefined,
      borderColor: theme.colors.gray[200],
      placeholderColor: theme.colors.gray[400],
      fontFamily: theme.fonts.body
    },
    dark: {
      color: theme.colors.whiteAlpha[900],
      bg: theme.colors.gray[800],
      borderColor: theme.colors.whiteAlpha[300],
      placeholderColor: theme.colors.whiteAlpha[400],
      fontFamily: theme.fonts.body
    }
  };
};
/**
 * CReset component
 *
 * The CSS Reset component to reset browser styles
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/getting-started
 */


var CReset = {
  name: 'CReset',
  inject: ['$chakraTheme', '$chakraColorMode'],
  computed: {
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    },
    theme: function theme() {
      return this.$chakraTheme();
    },
    styleConfig: function styleConfig() {
      var _defaultConfig = defaultConfig(this.theme);

      return this.config ? this.config(this.theme, _defaultConfig) : defaultConfig(this.theme);
    }
  },
  props: {
    config: {
      type: Function,
      validator: function validator(value) {
        return typeof value === 'function';
      }
    }
  },
  created: function created() {
    var ref = this.styleConfig[this.colorMode];
    var color = ref.color;
    var bg = ref.bg;
    var borderColor = ref.borderColor;
    var placeholderColor = ref.placeholderColor;
    var fontFamily = ref.fontFamily;
    useTailwindPreflight(this.theme);
    css.injectGlobal({
      html: {
        lineHeight: 1.5,
        color: color,
        backgroundColor: bg,
        fontFamily: fontFamily
      },
      '*, *::before, *::after': {
        borderWidth: 0,
        borderStyle: 'solid',
        borderColor: borderColor
      },
      'input:-ms-input-placeholder, textarea:-ms-input-placeholder': {
        color: placeholderColor
      },
      'input::-ms-input-placeholder, textarea::-ms-input-placeholder': {
        color: placeholderColor
      },
      'input::placeholder, textarea::placeholder': {
        color: placeholderColor
      }
    });
  },
  render: function render() {
    return null;
  }
};
exports.default = CReset;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(8);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

__webpack_require__(14);

__webpack_require__(5);

__webpack_require__(9);

__webpack_require__(16);

__webpack_require__(20);

var CModal = __webpack_require__(66);

__webpack_require__(17);

__webpack_require__(13);

__webpack_require__(6);
/**
 * Hey! Welcome to @chakra-ui/vue Drawer
 *
 * The Drawer component is a panel that slides out from the edge
 * of the screen. It can be useful when you need users to complete
 * a task or view some details without leaving the current page.
 *
 * @see Docs     https://vue.chakra-ui.com/drawer
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CDrawer/CDrawer.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CDrawer/accessibility.md
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * CDrawer component
 *
 * The wrapper for `CDrawer` components. It provides context and state for the drawer.
 *
 * @extends CModal
 * @see Docs https://vue.chakra-ui.com/drawer
 */


var CDrawer = {
  name: 'CDrawer',
  mixins: [utils.createStyledAttrsMixin('CDrawer')],
  props: {
    isOpen: {
      type: Boolean,
      default: false
    },
    onClose: {
      type: Function,
      default: function _default() {
        return null;
      }
    },
    closeOnEsc: {
      type: Boolean,
      default: true
    },
    isFullHeight: {
      type: Boolean,
      default: true
    },
    placement: {
      type: String,
      default: 'right'
    },
    initialFocusRef: {
      type: [utils.HTMLElement, Object, String, Function],
      default: function _default() {
        return null;
      }
    },
    finalFocusRef: {
      type: [utils.HTMLElement, Object, String, Function],
      default: function _default() {
        return null;
      }
    },
    size: {
      type: String,
      default: 'xs'
    }
  },
  provide: function provide() {
    var this$1 = this;
    return {
      $DrawerContext: function $DrawerContext() {
        return this$1.DrawerContext;
      }
    };
  },
  computed: {
    DrawerContext: function DrawerContext() {
      return {
        size: this.size,
        isOpen: this.isOpen,
        placement: this.placement,
        isFullHeight: this.isFullHeight
      };
    }
  },
  render: function render(h) {
    return h(CModal.CModal, {
      class: [this.className],
      props: {
        isOpen: this.isOpen,
        onClose: this.onClose,
        closeOnEsc: this.closeOnEsc,
        initialFocusRef: this.initialFocusRef,
        finalFocusRef: this.finalFocusRef,
        formatIds: function formatIds(id) {
          return {
            content: "drawer-" + id,
            header: "drawer-" + id + "-header",
            body: "drawer-" + id + "-body"
          };
        }
      },
      on: this.computedListeners,
      attrs: this.computedAttrs
    }, this.$slots.default);
  }
};

var getPlacementStyles = function getPlacementStyles(position, ref) {
  var finalWidth = ref.finalWidth;
  var finalHeight = ref.finalHeight;
  var placements = {
    bottom: {
      maxWidth: '100vw',
      height: 'auto',
      bottom: 0,
      left: 0,
      right: 0
    },
    top: {
      maxWidth: '100vw',
      height: 'auto',
      top: 0,
      left: 0,
      right: 0
    },
    left: Object.assign({}, finalWidth && {
      maxWidth: finalWidth
    }, {
      height: '100vh',
      left: 0,
      top: 0
    }),
    right: Object.assign({}, finalWidth && {
      maxWidth: finalWidth
    }, {
      right: 0,
      top: 0,
      height: '100vh'
    })
  };
  return placements[position] || placements.right;
};
/**
 * CDrawerContent component
 *
 * The wrapper for the drawers's content.
 *
 * @extends CModalContent
 * @see Docs https://vue.chakra-ui.com/drawer
 */


var CDrawerContent = {
  name: 'CDrawerContent',
  inheritAttrs: false,
  inject: ['$DrawerContext'],
  computed: {
    context: function context() {
      return this.$DrawerContext();
    },
    placementStyles: function placementStyles() {
      var ref = this.context;
      var placement = ref.placement;
      var isFullHeight = ref.isFullHeight;
      var placementStyles = getPlacementStyles(placement, {
        finalHeight: isFullHeight ? '100vh' : 'auto'
      });
      return Object.assign({}, {
        position: 'fixed'
      }, placementStyles);
    }
  },
  render: function render(h) {
    return h(CModal.CModalContent, {
      props: {
        noStyles: true
      },
      attrs: Object.assign({}, this.placementStyles, this.$attrs, {
        'data-chakra-component': 'CDrawerContent'
      })
    }, this.$slots.default);
  }
};
/**
 * CDrawerOverlay component
 *
 * The dimmed overlay behind the drawer.
 *
 * @extends CModalOverlay
 * @see Docs https://vue.chakra-ui.com/drawer
 */

var CDrawerOverlay = {
  name: 'CDrawerOverlay',
  functional: true,
  render: function render(h, ref) {
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["data"]);
    var rest = rest$1;
    return h(CModal.CModalOverlay, Object.assign({}, rest, {
      attrs: Object.assign({}, data.attrs, {
        'data-chakra-component': 'CDrawerOverlay'
      })
    }));
  }
};
/**
 * CDrawerCloseButton component
 *
 * The button that closes the drawer.
 *
 * @extends CModalCloseButton
 * @see Docs https://vue.chakra-ui.com/drawer
 */

var CDrawerCloseButton = {
  name: 'CDrawerCloseButton',
  functional: true,
  render: function render(h, ref) {
    var data = ref.data;
    var listeners = ref.listeners;
    return h(CModal.CModalCloseButton, {
      nativeOn: Object.assign({}, listeners, {
        click: function click(e) {
          var emitClick = listeners.click;

          if (emitClick) {
            emitClick('click', e);
          }
        }
      }),
      attrs: Object.assign({}, {
        position: 'fixed',
        zIndex: '1'
      }, data.attrs, {
        'data-chakra-component': 'CDrawerCloseButton'
      })
    });
  }
};
/**
 * CDrawerBody component
 *
 * Should contain the description announced by screen readers
 *
 * @extends CModalBody
 * @see Docs https://vue.chakra-ui.com/drawer
 */

var CDrawerBody = Object.assign({}, CModal.CModalBody, {
  name: 'CDrawerBody'
});
/**
 * CDrawerHeader component
 *
 * Should contain the title announced by screen readers
 *
 * @extends CModalHeader
 * @see Docs https://vue.chakra-ui.com/drawer
 */

var CDrawerHeader = Object.assign({}, CModal.CModalHeader, {
  name: 'CDrawerHeader'
});
/**
 * CDrawerFooter component
 *
 * Should contain the actions of the drawer
 *
 * @extends CModalFooter
 * @see Docs https://vue.chakra-ui.com/drawer
 */

var CDrawerFooter = Object.assign({}, CModal.CModalFooter, {
  name: 'CDrawerFooter'
});
exports.CDrawer = CDrawer;
exports.CDrawerBody = CDrawerBody;
exports.CDrawerCloseButton = CDrawerCloseButton;
exports.CDrawerContent = CDrawerContent;
exports.CDrawerFooter = CDrawerFooter;
exports.CDrawerHeader = CDrawerHeader;
exports.CDrawerOverlay = CDrawerOverlay;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);
/**
 * Hey! Welcome to @chakra-ui/vue Editable
 *
 * EditableText is used for inline renaming of some text.
 *
 * It appears as normal UI text but transforms into a text
 * input field when the user clicks or focuses on it.
 *
 * The text input inherits all font styling from its parent,
 * to make the edit and read view transition seamless.
 *
 * @see Docs     https://vue.chakra-ui.com/editable
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CEditable/CEditable.js
 */


var sharedEditableProps = {
  fontSize: 'inherit',
  fontWeight: 'inherit',
  textAlign: 'inherit',
  bg: 'transparent',
  transition: 'all 0.2s',
  borderRadius: 'md',
  px: '3px',
  mx: '-3px'
};
/**
 * CEditable component
 *
 * The wrapper for `CEditable` components. It provides context and state for the Editable components.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/editable
 */

var CEditable = {
  name: 'CEditable',
  mixins: [utils.createStyledAttrsMixin('CEditable')],
  props: {
    value: String,
    defaultValue: String,
    isDisabled: Boolean,
    startWithEditView: Boolean,
    selectAllOnFocus: {
      type: Boolean,
      default: true
    },
    submitOnBlur: {
      type: Boolean,
      default: true
    },
    isPreviewFocusable: {
      type: Boolean,
      default: true
    },
    placeholder: {
      type: String,
      default: 'Click to edit...'
    }
  },
  provide: function provide() {
    var this$1 = this;
    return {
      $EditableContext: function $EditableContext() {
        return this$1.EditableContext;
      }
    };
  },
  data: function data() {
    return {
      isEditing: this.startWithEditView && !this.isDisabled,
      innerValue: this.defaultValue || '',
      previousValue: this._value,
      inputNode: null
    };
  },
  computed: {
    isControlled: function isControlled() {
      return utils.isDef(this.value);
    },
    _value: function _value() {
      return this.isControlled ? this.value : this.innerValue;
    },
    editableId: function editableId() {
      return "editable-" + utils.useId();
    },
    EditableContext: function EditableContext() {
      return {
        editableId: this.editableId,
        isEditing: this.isEditing,
        isDisabled: this.isDisabled,
        placeholder: this.placeholder,
        onRequestEdit: this.onRequestEdit,
        submitOnBlur: this.submitOnBlur,
        isPreviewFocusable: this.isPreviewFocusable,
        value: this._value,
        onKeyDown: this.handleKeyDown,
        onChange: this.handleChange,
        onSubmit: this.handleSubmit,
        onCancel: this.handleCancel,
        onFocus: this.handleFocus
      };
    }
  },
  created: function created() {
    // Initialize previousValue to computed _value
    this.previousValue = this._value;
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$watch('isEditing', function (newVal) {
      if (newVal) {
        this$1.$emit('edit');
      }
    });
    this.$watch(function (vm) {
      return [vm.isEditing, vm.selectAllOnFocus];
    }, function () {
      this$1.$nextTick(function () {
        this$1.inputNode = utils.getElement("#" + this$1.editableId, this$1.$el);

        if (this$1.isEditing && this$1.inputNode) {
          this$1.inputNode.focus();
          this$1.selectAllOnFocus && this$1.inputNode.select();
        }
      });
    });
  },
  methods: {
    /**
     * Handle cancel event
     */
    handleCancel: function handleCancel() {
      this.isEditing = false;
      this.innerValue = this.previousValue;

      if (this.innerValue !== this.previousValue) {
        this.$emit('change', this.previousValue);
      }

      this.$emit('cancel', this.previousValue);
    },

    /**
     * Handle submit event
     */
    handleSubmit: function handleSubmit() {
      this.isEditing = false;
      this.previousValue = this.innerValue;
      this.$emit('submit', this.innerValue);
    },

    /**
     * Handle change event
     */
    handleChange: function handleChange(event) {
      var ref = event.target;
      var value = ref.value;

      if (!this.isControlled) {
        this.innerValue = value;
      }

      this.$emit('change', this.innerValue);
    },

    /**
     * Handle keydown event
     */
    handleKeyDown: function handleKeyDown(event) {
      var key = event.key;

      if (key === 'Escape') {
        this.handleCancel();
        return;
      }

      if (key === 'Enter') {
        this.handleSubmit();
      }
    },

    /**
     * Handle focus event
     */
    handleFocus: function handleFocus(event) {
      if (this.selectAllOnFocus) {
        this.inputNode.select();
      }
    },

    /**
     * Handle request editing
     */
    onRequestEdit: function onRequestEdit() {
      if (!this.isDisabled) {
        this.isEditing = true;
      }
    }
  },
  render: function render(h) {
    return h('div', {
      class: this.className,
      attrs: this.computedAttrs,
      on: this.computedListeners
    }, [this.$scopedSlots.default({
      isEditing: this.isEditing,
      onSubmit: this.handleSubmit,
      onCancel: this.handleCancel,
      onRequestEdit: this.onRequestEdit
    })]);
  }
};
/**
 * CEditablePreview component
 *
 * The read-only view of the component.
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/editable
 */

var CEditablePreview = {
  name: 'CEditablePreview',
  mixins: [utils.createStyledAttrsMixin('CEditablePreview')],
  inject: ['$EditableContext'],
  computed: {
    context: function context() {
      return this.$EditableContext();
    },
    hasValue: function hasValue() {
      return utils.isDef(this.context.value) && this.context.value !== '';
    },
    componentStyles: function componentStyles() {
      return Object.assign({}, sharedEditableProps, {
        cursor: 'text',
        display: 'inline-block',
        opacity: !this.hasValue ? 0.6 : undefined
      });
    },
    tabindex: function tabindex() {
      var ref = this.context;
      var isEditing = ref.isEditing;
      var isDisabled = ref.isDisabled;
      var isPreviewFocusable = ref.isPreviewFocusable;

      if ((!isEditing || !isDisabled) && isPreviewFocusable) {
        return 0;
      }

      return null;
    }
  },
  render: function render(h) {
    var ref = this.context;
    var isEditing = ref.isEditing;
    var isDisabled = ref.isDisabled;
    var onRequestEdit = ref.onRequestEdit;
    var value = ref.value;
    var placeholder = ref.placeholder;

    if (isEditing) {
      return null;
    }

    return h('span', {
      class: [this.className],
      attrs: Object.assign({}, {
        'aria-disabled': isDisabled,
        tabindex: this.tabindex
      }, this.computedAttrs),
      on: Object.assign({}, this.computedListeners, {
        focus: onRequestEdit
      })
    }, this.hasValue ? value : placeholder);
  }
};
/**
 * CEditableInput component
 *
 * The edit view of the component. It shows when you click or focus on the text.
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/editable
 */

var CEditableInput = {
  name: 'CEditableInput',
  mixins: [utils.createStyledAttrsMixin('CEditableInput')],
  inject: ['$EditableContext'],
  computed: {
    context: function context() {
      return this.$EditableContext();
    },
    componentStyles: function componentStyles() {
      return Object.assign({}, {
        outline: 'none',
        _focus: {
          shadow: 'outline'
        }
      }, sharedEditableProps, {
        width: 'full',
        _placeholder: {
          opacity: '0.6'
        }
      });
    }
  },
  render: function render(h) {
    var this$1 = this;
    var ref = this.context;
    var isEditing = ref.isEditing;
    var editableId = ref.editableId;
    var onChange = ref.onChange;
    var onKeyDown = ref.onKeyDown;
    var value = ref.value;
    var onSubmit = ref.onSubmit;
    var submitOnBlur = ref.submitOnBlur;
    var placeholder = ref.placeholder;
    var isDisabled = ref.isDisabled;

    if (!isEditing) {
      return null;
    }

    return h('input', {
      class: [this.className],
      on: Object.assign({}, this.computedListeners, {
        blur: function blur(event) {
          submitOnBlur && onSubmit();
          this$1.$emit('blur', event);
        },
        input: onChange,
        keydown: onKeyDown
      }),
      attrs: Object.assign({}, this.computedAttrs, {
        id: editableId,
        disabled: isDisabled,
        'aria-disabled': isDisabled,
        value: value,
        placeholder: placeholder
      })
    }, this.$slots.default);
  }
};
exports.CEditableInput = CEditableInput;
exports.CEditablePreview = CEditablePreview;
exports.default = CEditable;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var formcontrol_props = __webpack_require__(59);
/**
 * Hey! Welcome to @chakra-ui/vue FormControl
 *
 * `CFormControl` provides context such as isInvalid,
 * isDisabled, and isRequired to form elements.
 * This context is used by the following components:
 *
 * - `CFormControl` - Provides context such as `isInvalid`, `isDisabled`, and `isRequired` to form elements.
 * - `CFormLabel` - Label for the Form input
 * - `CFormErrorMessage` - Displays validation message content if it received `isInvalid` from context
 * - `CFormHelperText` - Used to display helpful hints to the use on how to use an input.
 *
 * @see Docs     https://vue.chakra-ui.com/formcontrol
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CFormControl/CFormControl.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CFormControl/accessibility.md
 * @see WAI      https://www.w3.org/WAI/tutorials/forms/
 */

/**
 * CFormControl component
 *
 * Provides context such as `isInvalid`, `isDisabled`, and `isRequired` to form elements.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/formcontrol
 */


var CFormControl = {
  name: 'CFormControl',
  mixins: [utils.createStyledAttrsMixin('CFormControl')],
  props: Object.assign({}, formcontrol_props.formControlProps, {
    as: {
      type: String,
      default: 'div'
    }
  }),
  inject: {
    $FormControlContext: {
      default: null
    }
  },
  computed: {
    formControlContext: function formControlContext() {
      if (!this.$FormControlContext) {
        return this.props;
      }

      return this.$FormControlContext();
    },
    props: function props() {
      return {
        isInvalid: this.isInvalid,
        isRequired: this.isRequired,
        isDisabled: this.isDisabled,
        isReadOnly: this.isReadOnly,
        id: "fc-" + (this.computedAttrs.id || utils.useId(3))
      };
    }
  },
  provide: function provide() {
    var this$1 = this;
    return {
      $FormControlContext: function $FormControlContext() {
        return this$1.props;
      },
      $useFormControl: this.useFormControl
    };
  },
  methods: {
    useFormControl: function useFormControl() {
      var this$1 = this;
      /**
       * If a <FormControl /> component is in the ancestor tree,
       * we provide it's values to this components' decendants.
       * However, we give a higher precendence to prop values
       * over context values.
       */

      var context = this.formControlContext;

      if (!context) {
        return this.props;
      }

      var keys = Object.keys(context);
      return keys.reduce(function (acc, prop) {
        // We give precedence to `props` over `context` values
        acc[prop] = this$1.props[prop];

        if (context) {
          if (this$1.props[prop] == null) {
            acc[prop] = context[prop];
          }
        }

        return acc;
      }, {});
    }
  },
  render: function render(h) {
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, {
        role: 'group'
      }, this.computedAttrs),
      on: this.computedListeners
    }, this.$scopedSlots.default({
      isInvalid: this.isInvalid,
      isRequired: this.isRequired,
      isDisabled: this.isDisabled,
      isReadOnly: this.isReadOnly
    }));
  }
};
exports.default = CFormControl;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

var formcontrol_props = __webpack_require__(59);
/**
 * Hey! Welcome to @chakra-ui/vue CFormLabel
 *
 * Label for the Form input
 *
 * @see Docs     https://vue.chakra-ui.com/formcontrol
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CFormLabel/CFormLabel.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CFormLabel/accessibility.md
 * @see WAI      https://www.w3.org/WAI/tutorials/forms/
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * CRequiredIndicator component
 *
 * Indicator shown if `isRequired` is received from context.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/formcontrol
 */


var CRequiredIndicator = {
  name: 'CRequiredIndicator',
  functional: true,
  inject: ['$chakraColorMode'],
  render: function render(h, ref) {
    var data = ref.data;
    var injections = ref.injections;
    var rest$1 = objectWithoutProperties(ref, ["data", "injections"]);
    var rest = rest$1;
    var colorMode = injections.$chakraColorMode();
    var colors = {
      light: 'red.500',
      dark: 'red.300'
    };
    var color = colors[colorMode];
    return h(CBox.default, Object.assign({}, rest, {
      attrs: Object.assign({}, {
        as: 'span',
        ml: 1,
        color: color,
        'aria-hidden': true
      }, data.attrs, {
        'data-chakra-component': 'CRequiredIndicator'
      })
    }), '*');
  }
};
/**
 * CFormLabel component
 *
 * Label for the form input.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/formcontrol
 */

var CFormLabel = {
  name: 'CFormLabel',
  mixins: [utils.createStyledAttrsMixin('CFormLabel')],
  inject: {
    $useFormControl: {
      default: null
    }
  },
  props: formcontrol_props.formControlProps,
  computed: {
    formControl: function formControl() {
      return utils.runIfFn(this.$useFormControl, this.$props);
    },
    componentStyles: function componentStyles() {
      return {
        fontSize: 'md',
        pr: '12px',
        pb: '4px',
        opacity: this.formControl.isDisabled ? '0.4' : '1',
        fontWeight: 'medium',
        fontFamily: 'body',
        textAlign: 'left',
        verticalAlign: 'middle',
        display: 'inline-block'
      };
    }
  },
  render: function render(h) {
    return h('label', {
      class: [this.className],
      attrs: this.computedAttrs,
      on: this.computedListeners
    }, this.$slots.default.concat([this.formControl.isRequired && h(CRequiredIndicator)]));
  }
};
exports.default = CFormLabel;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

__webpack_require__(2);

__webpack_require__(4);

__webpack_require__(8);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CIcon = __webpack_require__(9);

__webpack_require__(6);

var CFlex = __webpack_require__(21);

var formcontrol_props = __webpack_require__(59);

__webpack_require__(22);

var CText = __webpack_require__(26);
/**
 * Hey! Welcome to @chakra-ui/vue CFormErrorMessage
 *
 * Receives validation information from the `CFormControl`
 * component and displays the validation message
 *
 * @see Docs     https://vue.chakra-ui.com/formcontrol
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CFormErrorMessage/CFormErrorMessage.js
 * @see WAI      https://www.w3.org/WAI/tutorials/forms/
 */

/**
 * CFormControl component
 *
 * Displays validation message content if it received
 * `isInvalid` from context
 *
 * @extends CFlex
 * @see Docs https://vue.chakra-ui.com/formcontrol
 */


var CFormErrorMessage = {
  name: 'CFormErrorMessage',
  inject: ['$chakraColorMode', '$useFormControl'],
  props: Object.assign({}, {
    icon: {
      type: String,
      default: 'warning'
    },
    as: String
  }, formcontrol_props.formControlProps),
  computed: {
    formControl: function formControl() {
      return this.$useFormControl(this.$props);
    },
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    }
  },
  render: function render(h) {
    if (!this.formControl.isInvalid) {
      return null;
    }

    var color = {
      light: 'red.500',
      dark: 'red.300'
    };
    return h(CFlex.CFlex, {
      props: {
        as: this.as
      },
      attrs: Object.assign({}, {
        color: color[this.colorMode],
        mt: 2,
        fontSize: 'sm',
        align: 'center',
        id: this.formControl.id ? this.formControl.id + "-error-message" : null
      }, this.$attrs, {
        'data-chakra-component': 'CFormErrorMessage'
      })
    }, [h(CIcon.CIcon, {
      props: {
        name: this.icon
      },
      attrs: {
        mr: '0.5em',
        'aria-hidden': true
      }
    }), h(CText.default, {
      attrs: {
        lineHeight: 'normal'
      }
    }, this.$slots.default)]);
  }
};
exports.default = CFormErrorMessage;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);
/**
 * Hey! Welcome to @chakra-ui/vue CFormHelperText
 *
 * Used to display helpful hints to the use on how to
 * use an input.
 *
 * @see Docs     https://vue.chakra-ui.com/formcontrol
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CFormHelperText/CFormHelperText.js
 * @see WAI      https://www.w3.org/WAI/tutorials/forms/
 */

/**
 * CFormHelperText component
 *
 * Used to display helpful hints to the use on how to
 * use an input.
 *
 * @extends CText
 * @see Docs https://vue.chakra-ui.com/formcontrol
 */


var CFormHelperText = {
  name: 'CFormHelperText',
  mixins: [utils.createStyledAttrsMixin('CFormHelperText')],
  inject: ['$useFormControl'],
  computed: {
    formControl: function formControl() {
      return this.$useFormControl(this.$props);
    },
    componentStyles: function componentStyles() {
      var color = {
        light: 'gray.500',
        dark: 'whiteAlpha.600'
      };
      return {
        mt: 2,
        color: color[this.colorMode],
        lineHeight: 'normal',
        fontSize: 'sm'
      };
    }
  },
  render: function render(h) {
    return h('p', {
      class: [this.className],
      attrs: Object.assign({}, {
        id: this.formControl.id ? this.formControl.id + "-help-text" : null
      }, this.computedAttrs),
      on: this.computedListeners
    }, this.$slots.default);
  }
};
exports.default = CFormHelperText;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var text_utils = __webpack_require__(22);
/**
 * Hey! Welcome to @chakra-ui/vue Heading
 *
 * Headings are used for rendering headlines.
 *
 * Heading composes CBox so you can use all the style props
 * and add responsive styles as well. It renders an <h2> tag by default.
 *
 * @see Docs     https://vue.chakra-ui.com/heading
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CHeading/CHeading.js
 */


var sizes = {
  '2xl': ['4xl', null, '5xl'],
  xl: ['3xl', null, '4xl'],
  lg: ['xl', null, '2xl'],
  md: 'xl',
  sm: 'md',
  xs: 'sm'
};
/**
 * CHeading component
 *
 * The CHeading is used for rendering headlines.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/heading
 */

var CHeading = {
  name: 'CHeading',
  mixins: [utils.createStyledAttrsMixin('CHeading')],
  props: {
    size: {
      type: [String, Array, Object],
      default: 'xl'
    },
    as: {
      type: String,
      default: 'h2'
    },
    isTruncated: Boolean
  },
  computed: {
    componentStyles: function componentStyles() {
      return Object.assign({}, {
        fontSize: sizes[this.size],
        lineHeight: 'shorter',
        fontWeight: 'bold',
        fontFamily: 'heading'
      }, this.isTruncated && text_utils.useTruncated());
    }
  },
  render: function render(h) {
    return h(this.as, {
      class: this.className,
      attrs: this.computedAttrs
    }, this.$slots.default);
  }
};
exports.default = CHeading;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(8);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

var CIcon = __webpack_require__(9);

__webpack_require__(18);

__webpack_require__(68);

var CButton = __webpack_require__(69);
/**
 * Hey! Welcome to @chakra-ui/vue IconButton
 *
 * CIconButton is used to render icons that support
 * click interactions.
 *
 * CIconButton composes the CButton component, except that it renders only an icon.
 *
 * @see Docs     https://vue.chakra-ui.com/iconbutton
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CIconButton/CIconButton.js
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}

var baseStyles = {
  display: 'inline-flex',
  appearance: 'none',
  alignItems: 'center',
  justifyContent: 'center',
  transition: 'all 250ms',
  userSelect: 'none',
  position: 'relative',
  whiteSpace: 'nowrap',
  verticalAlign: 'middle',
  lineHeight: '1.2',
  outline: 'none'
};
/**
 * CIconButton component
 *
 * CIconButton is used to render icons that support
 * click interactions
 *
 * @extends CButton
 * @see Docs https://vue.chakra-ui.com/iconbutton
 */

var CIconButton = {
  name: 'CIconButton',
  functional: true,
  props: Object.assign({}, {
    icon: {
      type: [String]
    },
    isRound: {
      type: [Boolean]
    },
    ariaLabel: {
      type: [String],
      required: true
    }
  }, CButton.buttonProps),
  render: function render(h, context) {
    var ref = context.props;
    var isFullWidth = ref.isFullWidth;
    var leftIcon = ref.leftIcon;
    var rightIcon = ref.rightIcon;
    var loadingText = ref.loadingText;
    var rest = objectWithoutProperties(ref, ["isFullWidth", "leftIcon", "rightIcon", "loadingText"]);
    var props = rest;
    var ariaLabel = props.ariaLabel;
    var isRound = props.isRound;
    var icon = props.icon;
    var nonNativeEvents = {
      click: function click(e) {
        var emitClick = context.listeners.click;

        if (emitClick) {
          emitClick(e);
        }
      }
    };
    var ref$1 = utils.extractListeners(context, nonNativeEvents);
    var native = ref$1.native;
    var nonNative = ref$1.nonNative;
    return h(CButton.CButton, {
      props: props,
      attrs: Object.assign({}, {
        'aria-label': ariaLabel,
        rounded: isRound ? 'full' : 'md'
      }, context.data.attrs, {
        'data-chakra-component': 'CIconButton',
        p: 0
      }),
      on: nonNative,
      nativeOn: native
    }, [typeof icon === 'string' ? h(CIcon.CIcon, {
      props: {
        name: icon
      },
      attrs: Object.assign({}, baseStyles, {
        color: 'currentColor',
        mb: '2px',
        size: '1em',
        focusable: false,
        'aria-hidden': true
      })
    }) : h(CBox.default, {
      props: {
        as: icon
      },
      attrs: {
        focusable: true,
        color: 'currentColor'
      }
    })]);
  }
};
exports.default = CIconButton;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CNoSsr = __webpack_require__(13);
/**
 * Hey! Welcome to @chakra-ui/vue Image
 *
 * The CImage component is used to display images.
 *
 * CImage composes CBox so you can use all the style props and add responsive styles as well.
 *
 * @see Docs     https://vue.chakra-ui.com/image
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CImage/CImage.js
 */

/**
 * CImage component
 *
 * The CImage component is used to display images.
 *
 * @extends CButton
 * @see Docs https://vue.chakra-ui.com/image
 */


var CImage = {
  name: 'CImage',
  mixins: [utils.createStyledAttrsMixin('CImage')],
  props: {
    src: String,
    srcset: String,
    fallbackSrc: String,
    ignoreFalback: Boolean,
    htmlWidth: String,
    htmlHeight: String,
    size: [String, Number]
  },
  data: function data() {
    return {
      image: undefined,
      hasLoaded: false
    };
  },
  computed: {
    componentStyles: function componentStyles() {
      return {
        w: this.size,
        h: this.size
      };
    }
  },
  created: function created() {
    // Should only invoke window.Image in the browser.
    if (false) {}
  },
  methods: {
    loadImage: function loadImage(src, srcset) {
      var this$1 = this;
      var image = new window.Image();

      if (srcset) {
        image.srcset = srcset;
      }

      if (src) {
        image.src = src;
      }

      image.onload = function (event) {
        this$1.hasLoaded = true;
        this$1.$emit('load', event);
      };

      image.onerror = function (event) {
        this$1.hasLoaded = false;
        this$1.$emit('error', event);
      };
    }
  },
  render: function render(h) {
    var imageProps;

    if (this.ignoreFallback) {
      imageProps = {
        src: this.src,
        srcset: this.srcset
      };
    } else {
      imageProps = {
        src: this.hasLoaded ? this.src : this.fallbackSrc,
        srcset: this.srcset
      };
    }

    return h(CNoSsr.default, [h('img', {
      class: this.className,
      attrs: Object.assign({}, imageProps, this.computedAttrs, {
        width: this.htmlWidth,
        height: this.htmlHeight
      })
    })]);
  }
};
exports.default = CImage;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var input_styles = __webpack_require__(15);
/**
 * Hey! Welcome to @chakra-ui/vue InputAddon
 *
 * InputAddon allows addition of addons to the left and right of the CInput component
 *
 * @see Docs     https://vue.chakra-ui.com/input
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CInputAddon/CInputAddon.js
 */


var addonProps = {
  placement: {
    type: String,
    default: 'left'
  },
  size: {
    type: String,
    default: 'md'
  }
};
/**
 * CInputAddon component
 *
 * allows addition of addons to the left and right of the CInput component
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/input
 */

var CInputAddon = {
  name: 'CInputAddon',
  mixins: [utils.createStyledAttrsMixin('CInputAddon')],
  props: addonProps,
  computed: {
    componentStyles: function componentStyles() {
      var bg = {
        dark: 'whiteAlpha.300',
        light: 'gray.100'
      };
      var _placement = {
        left: {
          mr: '-1px',
          roundedRight: 0,
          borderRightColor: 'transparent'
        },
        right: {
          order: 1,
          roundedLeft: 0,
          borderLeftColor: 'transparent'
        }
      };
      return Object.assign({}, input_styles.useInputStyle({
        size: this.size,
        variant: 'outline',
        colorMode: this.colorMode,
        theme: this.theme
      }), {
        flex: '0 0 auto',
        whiteSpace: 'nowrap',
        bg: bg[this.colorMode]
      }, _placement[this.placement]);
    }
  },
  render: function render(h) {
    return h(this.as, {
      class: [this.className],
      attrs: this.computedAttrs,
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CInputLeftAddon component
 *
 * allows addition of addons to the left of CInput component
 *
 * @extends CInputAddon
 * @see Docs https://vue.chakra-ui.com/input
 */

var CInputLeftAddon = {
  name: 'CInputLeftAddon',
  functional: true,
  props: addonProps,
  render: function render(h, ref) {
    var props = ref.props;
    var slots = ref.slots;
    var data = ref.data;
    return h(CInputAddon, {
      props: Object.assign({}, utils.pickProperty(props), {
        placement: 'left'
      }),
      attrs: Object.assign({}, data.attrs, {
        'data-chakra-component': 'CInputLeftAddon'
      })
    }, slots().default);
  }
};
/**
 * CInputRightAddon component
 *
 * allows addition of addons to the right of CInput component
 *
 * @extends CInputAddon
 * @see Docs https://vue.chakra-ui.com/input
 */

var CInputRightAddon = {
  name: 'CInputRightAddon',
  functional: true,
  props: addonProps,
  render: function render(h, ref) {
    var props = ref.props;
    var slots = ref.slots;
    var data = ref.data;
    return h(CInputAddon, {
      props: Object.assign({}, utils.pickProperty(props), {
        placement: 'right'
      }),
      attrs: Object.assign({}, data.attrs, {
        'data-chakra-component': 'CInputRightAddon'
      })
    }, slots().default);
  }
};
exports.CInputLeftAddon = CInputLeftAddon;
exports.CInputRightAddon = CInputRightAddon;
exports.default = CInputAddon;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

var input_styles = __webpack_require__(15);
/**
 * Hey! Welcome to @chakra-ui/vue CInputElement
 *
 * InputElement allows addition of add an icon or button inside the input component
 *
 * @see Docs     https://vue.chakra-ui.com/input
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CInputElement/CInputElement.js
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}

var props = {
  size: String,
  placement: {
    type: String,
    default: 'left'
  },
  disablePointerEvents: Boolean,
  fine: Boolean
};
/**
 * CInputElement component
 *
 * allows addition of an icon or button inside the input component
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/input
 */

var CInputElement = {
  name: 'CInputElement',
  functional: true,
  props: props,
  render: function render(h, ref) {
    var props = ref.props;
    var slots = ref.slots;
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["props", "slots", "data"]);
    var rest = rest$1;
    var height = input_styles.inputSizes[props.size] && input_styles.inputSizes[props.size].height;
    var fontSize = input_styles.inputSizes[props.size] && input_styles.inputSizes[props.size].fontSize;
    var placementProp = {};
    placementProp[props.placement] = '0';
    return h(CBox.default, Object.assign({}, rest, {
      attrs: Object.assign({}, {
        'data-chakra-component': 'CInputElement'
      }, data.attrs, {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        position: 'absolute',
        width: height,
        height: height,
        fontSize: fontSize,
        top: 0,
        zIndex: 2
      }, props.disablePointerEvents && {
        pointerEvents: 'none'
      }, placementProp)
    }), slots().default);
  }
};
/**
 * CInputLeftElement component
 *
 * allows addition of an icon or button inside left of the input component
 *
 * @extends CInputElement
 * @see Docs https://vue.chakra-ui.com/input
 */

var CInputLeftElement = {
  name: 'CInputLeftElement',
  props: props,
  render: function render(h) {
    return h(CInputElement, {
      props: Object.assign({}, utils.pickProperty(this.$props), {
        placement: 'left'
      }),
      attrs: Object.assign({}, this.$attrs, {
        'data-chakra-component': 'CInputLeftElement'
      })
    }, this.$slots.default);
  }
};
/**
 * CInputRightElement component
 *
 * allows addition of an icon or button inside right of the input component
 *
 * @extends CInputElement
 * @see Docs https://vue.chakra-ui.com/input
 */

var CInputRightElement = {
  name: 'CInputRightElement',
  props: props,
  render: function render(h) {
    return h(CInputElement, {
      props: Object.assign({}, utils.pickProperty(this.$props), {
        placement: 'right'
      }),
      attrs: Object.assign({}, this.$attrs, {
        'data-chakra-component': 'CInputRightElement'
      })
    }, this.$slots.default);
  }
};
exports.CInputLeftElement = CInputLeftElement;
exports.CInputRightElement = CInputRightElement;
exports.default = CInputElement;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

var props_types = __webpack_require__(6);

var input_styles = __webpack_require__(15);
/**
 * Hey! Welcome to @chakra-ui/vue CInputGroup
 *
 * CInputGroup allows grouping of input elements
 *
 * @see Docs     https://vue.chakra-ui.com/input
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CInputGroup/CInputGroup.js
 */

/**
 * CInputElement component
 *
 * allows grouping of input elements
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/input
 */


var CInputGroup = {
  name: 'CInputGroup',
  functional: true,
  inject: ['$chakraTheme'],
  props: {
    size: {
      type: props_types.StringArray,
      default: 'md'
    }
  },
  render: function render(h, ref) {
    var injections = ref.injections;
    var data = ref.data;
    var slots = ref.slots;
    var props = ref.props;
    var theme = injections.$chakraTheme();
    var sizes = theme.sizes;
    var pl = null;
    var pr = null;
    var height = input_styles.inputSizes[props.size] && input_styles.inputSizes[props.size].height;
    var children = slots().default.filter(function (e) {
      return e.tag;
    });
    var clones = children.map(function (vnode) {
      if (vnode.tag.includes('CInputLeftElement')) {
        pl = sizes[height];
      }

      if (vnode.tag.includes('CInputRightElement')) {
        pr = sizes[height];
      }

      if (utils.kebabify(vnode.componentOptions.tag) === 'c-input') {
        var clone$1 = utils.cloneVNode(vnode, h);
        return h(clone$1.componentOptions.Ctor, Object.assign({}, clone$1.data, {
          on: clone$1.componentOptions.listeners || {},
          props: Object.assign({}, clone$1.data.props || {}, clone$1.componentOptions.propsData, {
            size: props.size
          }),
          attrs: Object.assign({}, {
            borderRadius: clone$1.data.attrs.rounded,
            paddingLeft: clone$1.data.attrs.pl || pl,
            paddingRight: clone$1.data.attrs.pr || pr
          }, clone$1.data.attrs)
        }), vnode.componentOptions.children);
      }

      var clone = utils.cloneVNode(vnode, h);
      return h(clone.componentOptions.Ctor, Object.assign({}, clone.data, clone.componentOptions.listeners || {}, {
        props: Object.assign({}, clone.data.props || {}, clone.componentOptions.propsData, {
          size: props.size
        })
      }), vnode.componentOptions.children);
    });
    return h(CBox.default, {
      props: {
        as: props.as
      },
      attrs: Object.assign({}, {
        display: 'flex',
        position: 'relative',
        zIndex: 0
      }, data.attrs, {
        'data-chakra-component': 'CInputGroup'
      })
    }, clones);
  }
};
exports.default = CInputGroup;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(8);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CIcon = __webpack_require__(9);

var props_types = __webpack_require__(6);
/**
 * Hey! Welcome to @chakra-ui/vue List
 *
 * `CList` is used to display list items
 *
 * @see Docs     https://vue.chakra-ui.com/list
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CList/CList.js
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * CList component
 *
 * The list container element
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/list
 */


var CList = {
  name: 'CList',
  mixins: [utils.createStyledAttrsMixin('CList')],
  props: {
    styleType: {
      type: String,
      default: 'none'
    },
    stylePos: {
      type: String,
      default: 'inside'
    },
    spacing: props_types.SNA
  },
  computed: {
    componentStyles: function componentStyles() {
      return {
        listStyleType: this.styleType,
        listStylePosition: this.stylePos
      };
    }
  },
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;

    if (!utils.isDef(children)) {
      console.error('[Chakra-ui: List]: List component expects at east one child');
      return null;
    }

    var validChildren = utils.cleanChildren(children);
    var clones = validChildren.map(function (vnode, index) {
      var isLast = index + 1 === validChildren.length;

      if (isLast) {
        return vnode;
      }

      var clone = utils.cloneVNodeElement(vnode, {
        attrs: {
          mb: this$1.spacing
        }
      }, h);
      return clone;
    });
    return h('ul', {
      class: [this.className],
      attrs: this.computedAttrs,
      on: this.computedListeners
    }, clones);
  }
};
/**
 * CListItem component
 *
 * The list item element
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/list
 */

var CListItem = {
  name: 'CListItem',
  mixins: [utils.createStyledAttrsMixin('CListItem')],
  props: {
    spacing: props_types.SNA
  },
  computed: {
    componentStyles: function componentStyles() {
      return {
        mb: this.spacing
      };
    }
  },
  render: function render(h) {
    return h('li', {
      class: [this.className],
      attrs: this.computedAttrs
    }, this.$slots.default);
  }
};
/**
 * CListIcon component
 *
 * The list item icon element
 *
 * @extends CIcon
 * @see Docs https://vue.chakra-ui.com/list
 */

var CListIcon = {
  name: 'CListIcon',
  functional: true,
  props: {
    icon: String
  },
  render: function render(h, ref) {
    var props = ref.props;
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["props", "data"]);
    var rest = rest$1;
    return h(CIcon.CIcon, Object.assign({}, rest, {
      props: {
        name: props.icon
      },
      attrs: Object.assign({}, {
        mr: 2
      }, data.attrs, {
        'data-chakra-component': 'CListIcon'
      })
    }));
  }
};
exports.CListIcon = CListIcon;
exports.CListItem = CListItem;
exports.default = CList;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


var utils = __webpack_require__(2);

var CPseudoBox = __webpack_require__(12);

var CButton = __webpack_require__(69);

var CDivider = __webpack_require__(88);

var CText = __webpack_require__(26);

var CFragment = __webpack_require__(60);

var CPopper = __webpack_require__(62);
/**
 * Base style props for menu list items
 */


var baseProps = {
  width: 'full',
  flex: ' 0 0 auto',
  userSelect: 'none',
  transition: 'background-color 220ms, color 220ms'
};
/**
 * Gets menu components list styles object
 * @param {String} colorMode Color mode
 * @returns {Object} Styles object
 */

var useMenuListStyle = function useMenuListStyle(colorMode) {
  var elevation = {
    light: {
      bg: '#fff',
      shadow: 'sm'
    },
    dark: {
      bg: 'gray.700',
      shadow: 'rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px'
    }
  };
  return Object.assign({}, {
    color: 'inherit',
    borderColor: 'gray.200',
    borderWidth: '1px'
  }, elevation[colorMode]);
};
/**
 * Gets interaction style props
 * @param {Object} param0 props
 */


var interactionProps = function interactionProps(ref) {
  var colorMode = ref.colorMode;
  var _focusColor = {
    light: 'gray.100',
    dark: 'whiteAlpha.100'
  };
  var _activeColor = {
    light: 'gray.200',
    dark: 'whiteAlpha.200'
  };
  return {
    _active: {
      bg: _activeColor[colorMode]
    },
    _focus: {
      bg: _focusColor[colorMode],
      outline: 0
    },
    _disabled: {
      opacity: 0.4,
      cursor: 'not-allowed'
    }
  };
};
/**
 * Gets menu list item styles
 * @param {{theme: Object, colorMode: String }} props Options
 */


var useMenuItemStyle = function useMenuItemStyle(ref) {
  var theme = ref.theme;
  var colorMode = ref.colorMode;
  var props = {
    theme: theme,
    colorMode: colorMode
  };
  return Object.assign({}, baseProps, interactionProps(props));
};
/**
 * Hey! Welcome to @chakra-ui/vue Menu
 *
 * `CMenu` is An accessible dropdown menu for the common dropdown menu button design pattern.
 *
 * @see Docs     https://vue.chakra-ui.com/menu
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CMenu/CMenu.js
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}

var menuProps = {
  controlledIsOpen: Boolean,
  isControlled: Boolean,
  defaultIsOpen: Boolean,
  onOpen: Function,
  onClose: Function,
  autoSelect: {
    type: Boolean,
    default: true
  },
  closeOnBlur: {
    type: Boolean,
    default: true
  },
  closeOnSelect: {
    type: Boolean,
    default: true
  },
  defaultActiveIndex: Number,
  placement: String
};
/**
 * CMenu component
 *
 * The menu container element
 *
 * @see Docs https://vue.chakra-ui.com/menu
 */

var CMenu = {
  name: 'CMenu',
  inject: ['$chakraColorMode', '$chakraTheme'],
  provide: function provide() {
    var this$1 = this;
    return {
      $MenuContext: function $MenuContext() {
        return this$1.MenuContext;
      }
    };
  },
  props: menuProps,
  data: function data() {
    return {
      isOpen: this.isControlled ? this.controlledIsOpen : this.defaultIsOpen || false,
      activeIndex: this.defaultActiveIndex || -1,
      focusableItems: null,
      menuNode: undefined,
      buttonNode: undefined,
      prevIsOpen: undefined
    };
  },
  computed: {
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    },
    theme: function theme() {
      return this.$chakraTheme();
    },
    menuId: function menuId() {
      return "menu-" + utils.useId();
    },
    buttonId: function buttonId() {
      return "menubutton-" + utils.useId();
    },
    MenuContext: function MenuContext() {
      return {
        activeIndex: this.activeIndex,
        isOpen: this.isOpen,
        menuNode: this.menuNode,
        buttonNode: this.buttonNode,
        focusableItems: this.focusableItems,
        placement: this.placement,
        menuId: this.menuId,
        buttonId: this.buttonId,
        colorMode: this.colorMode,
        focusAtIndex: this.focusAtIndex,
        focusOnLastItem: this.focusOnLastItem,
        focusOnFirstItem: this.focusOnFirstItem,
        closeMenu: this.closeMenu,
        autoSelect: this.autoSelect,
        closeOnSelect: this.closeOnSelect,
        closeOnBlur: this.closeOnBlur
      };
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    var menuNode;
    var buttonNode;
    this.$nextTick(function () {
      // In child components bind menuId to menuNode and bind it
      menuNode = utils.canUseDOM && document.querySelector("#" + this$1.menuId);
      this$1.menuNode = menuNode;
      buttonNode = utils.canUseDOM && document.querySelector("#" + this$1.buttonId);
      this$1.buttonNode = buttonNode;
    });
    this.$watch('isOpen', function (_newVal, oldVal) {
      this$1.prevIsOpen = oldVal;
    }, {
      immediate: true
    });
    this.$watch('isOpen', function (isOpen) {
      if (isOpen && menuNode) {
        var focusables = utils.getFocusables(menuNode).filter(function (node) {
          return ['menuitem', 'menuitemradio', 'menuitemcheckbox'].includes(node.getAttribute('role'));
        });
        this$1.focusableItems = menuNode ? focusables : [];
        this$1.initTabIndex();
      }
    });
    this.$watch(function (vm) {
      return [vm.activeIndex, vm.isOpen, vm.menuNode, vm.buttonNode];
    }, function () {
      if (this$1.activeIndex !== -1) {
        this$1.focusableItems[this$1.activeIndex] && this$1.focusableItems[this$1.activeIndex].focus();
        this$1.updateTabIndex(this$1.activeIndex);
      }

      if (this$1.activeIndex === -1 && !this$1.isOpen && this$1.prevIsOpen) {
        this$1.buttonNode && this$1.buttonNode.focus();
      }

      if (this$1.activeIndex === -1 && this$1.isOpen) {
        this$1.menuNode && this$1.menuNode.focus();
      }
    });
  },
  methods: {
    /**
     * Initializes tab indexing on menu list items
     */
    initTabIndex: function initTabIndex() {
      this.focusableItems.forEach(function (node, index) {
        return index === 0 && node.setAttribute('tabindex', 0);
      });
    },

    /**
     * Updates tab index for menulist items
     * @param {Number} index Position index of menu list item
     */
    updateTabIndex: function updateTabIndex(index) {
      if (this.focusableItems.length > 0) {
        var nodeAtIndex = this.focusableItems[index];
        this.focusableItems.forEach(function (node) {
          if (node !== nodeAtIndex) {
            node.setAttribute('tabindex', -1);
          }
        });
        nodeAtIndex.setAttribute('tabindex', 0);
      }
    },

    /**
     * Resets tab index of menu list items
     */
    resetTabIndex: function resetTabIndex() {
      if (this.focusableItems) {
        this.focusableItems.forEach(function (node) {
          return node.setAttribute('tabindex', -1);
        });
      }
    },

    /**
     * Opens Menu component
     */
    openMenu: function openMenu() {
      if (!this.isControlled) {
        this.isOpen = true;
      }

      if (this.onOpen) {
        this.onOpen();
      }
    },

    /**
     * Focuses first menulist element.
     */
    focusOnFirstItem: function focusOnFirstItem() {
      this.openMenu();
      this.activeIndex = 0;
    },

    /**
     * Focuses an element at a particular index
     * @param {Number} index Menulist items index
     */
    focusAtIndex: function focusAtIndex(index) {
      this.activeIndex = index;
    },

    /**
     * Focuses last menulist item
     */
    focusOnLastItem: function focusOnLastItem() {
      this.openMenu();
      this.activeIndex = this.focusableItems.length - 1;
    },

    /**
     * Closes Menu
     */
    closeMenu: function closeMenu() {
      if (!this.isControlled) {
        this.isOpen = false;
      }

      if (this.onClose) {
        this.onClose();
      }

      this.activeIndex = -1;
      this.resetTabIndex();
    }
  },
  render: function render(h) {
    return h(CFragment.default, {
      attrs: {
        'data-chakra-component': 'CMenu'
      }
    }, [this.$scopedSlots.default({
      isOpen: this.isOpen
    })]);
  }
};
/**
 * CMenuButton component
 *
 * The menu button element
 *
 * @see Docs https://vue.chakra-ui.com/menu
 */

var CMenuButton = {
  name: 'CMenuButton',
  inheritAttrs: false,
  inject: ['$MenuContext'],
  props: CButton.buttonProps,
  computed: {
    context: function context() {
      return this.$MenuContext();
    }
  },
  render: function render(h) {
    var this$1 = this;
    var ref = this.context;
    var isOpen = ref.isOpen;
    var buttonId = ref.buttonId;
    var menuId = ref.menuId;
    var closeMenu = ref.closeMenu;
    var autoSelect = ref.autoSelect;
    var focusOnFirstItem = ref.focusOnFirstItem;
    var focusOnLastItem = ref.focusOnLastItem;
    var openMenu = ref.openMenu;
    return h(CButton.CButton, {
      props: Object.assign({}, utils.pickProperty(this.$props), {
        isLoading: false
      }),
      attrs: Object.assign({}, {
        id: buttonId,
        role: 'button',
        'aria-haspopup': 'menu',
        'aria-expanded': isOpen,
        'aria-controls': menuId,
        'data-chakra-component': 'CMenuButton'
      }, this.$attrs),
      nativeOn: {
        click: function click(event) {
          this$1.$emit('click', event);

          if (isOpen) {
            closeMenu();
          } else if (autoSelect) {
            focusOnFirstItem();
          } else {
            openMenu();
          }
        },
        keydown: function keydown(event) {
          if (event.key === 'ArrowDown') {
            event.preventDefault();
            focusOnFirstItem();
          }

          if (event.key === 'ArrowUp') {
            event.preventDefault();
            focusOnLastItem();
          }
        }
      }
    }, this.$slots.default);
  }
};
/**
 * CMenuList component
 *
 * The menu list element
 *
 * @extends CPopper
 * @see Docs https://vue.chakra-ui.com/menu
 */

var CMenuList = {
  name: 'CMenuList',
  inheritAttrs: false,
  inject: ['$MenuContext', '$chakraColorMode'],
  computed: {
    context: function context() {
      return this.$MenuContext();
    },
    menuListStyles: function menuListStyles() {
      return function (colorMode) {
        return useMenuListStyle(colorMode);
      };
    },
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    }
  },
  props: {
    placement: {
      type: String,
      validator: function validator(value) {
        return value.match(/^(top|top-start|top-end|right|right-start|right-end|bottom|bottom-start|bottom-end|left|left-start|left-end)$/);
      }
    }
  },
  methods: {
    handleKeyDown: function handleKeyDown(event) {
      var ref = this.context;
      var index = ref.activeIndex;
      var focusAtIndex = ref.focusAtIndex;
      var focusOnFirstItem = ref.focusOnFirstItem;
      var focusOnLastItem = ref.focusOnLastItem;
      var closeMenu = ref.closeMenu;
      var focusableItems = ref.focusableItems;
      var count = focusableItems.length;
      var nextIndex;

      if (event.key === 'ArrowDown') {
        event.preventDefault();
        nextIndex = (index + 1) % count;
        focusAtIndex(nextIndex);
      } else if (event.key === 'ArrowUp') {
        event.preventDefault();
        nextIndex = (index - 1 + count) % count;
        focusAtIndex(nextIndex);
      } else if (event.key === 'Home') {
        focusOnFirstItem();
      } else if (event.key === 'End') {
        focusOnLastItem();
      } else if (event.key === 'Tab') {
        event.preventDefault();
      } else if (event.key === 'Escape') {
        closeMenu();
      } // Set focus based on first character


      if (/^[a-z0-9_-]$/i.test(event.key)) {
        event.stopPropagation();
        event.preventDefault();
        var foundNode = focusableItems.find(function (item) {
          return item.textContent.toLowerCase().startsWith(event.key);
        });

        if (foundNode) {
          nextIndex = focusableItems.indexOf(foundNode);
          focusAtIndex(nextIndex);
        }
      }

      this.$emit('keydown', event);
    },
    handleBlur: function handleBlur(event) {
      var ref = this.context;
      var menuNode = ref.menuNode;
      var buttonNode = ref.buttonNode;
      var isOpen = ref.isOpen;
      var closeOnBlur = ref.closeOnBlur;
      var closeMenu = ref.closeMenu;

      if (closeOnBlur && isOpen && menuNode && buttonNode && !menuNode.contains(event.relatedTarget) && !buttonNode.contains(event.relatedTarget)) {
        closeMenu();
      }

      this.$emit('blur', event);
    }
  },
  render: function render(h) {
    var ref = this.context;
    var isOpen = ref.isOpen;
    var buttonNode = ref.buttonNode;
    var menuId = ref.menuId;
    var buttonId = ref.buttonId;
    var placement = ref.placement;
    var closeMenu = ref.closeMenu;
    var closeOnBlur = ref.closeOnBlur;
    return h(CPopper.CPopper, {
      props: {
        usePortal: false,
        isOpen: isOpen,
        anchorEl: buttonNode,
        placement: this.placement || placement,
        modifiers: [{
          name: 'preventOverflow',
          options: {
            rootBoundary: 'viewport'
          }
        }],
        closeOnClickAway: closeOnBlur,
        hasArrow: false
      },
      attrs: Object.assign({}, {
        minW: '3xs',
        rounded: 'md',
        py: 2,
        'z-index': 1,
        _focus: {
          outline: 0
        }
      }, this.menuListStyles(this.colorMode), this.$attrs, {
        id: menuId,
        role: 'menu',
        'aria-labelledby': buttonId,
        tabindex: -1,
        'data-chakra-component': 'CMenuButton'
      }),
      on: {
        close: closeMenu
      },
      nativeOn: {
        keydown: this.handleKeyDown,
        blur: this.handleBlur
      }
    }, this.$slots.default);
  }
};
/**
 * CMenuItem component
 *
 * The menu list item element
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/menu
 */

var CMenuItem = {
  name: 'CMenuItem',
  inheritAttrs: false,
  inject: ['$MenuContext', '$chakraTheme', '$chakraColorMode'],
  props: {
    isDisabled: Boolean,
    role: {
      type: String,
      default: 'menuitem'
    },
    as: {
      type: [String, Object],
      default: 'button'
    }
  },
  computed: {
    context: function context() {
      return this.$MenuContext();
    },
    menuItemStyles: function menuItemStyles() {
      return function (props) {
        return useMenuItemStyle(props);
      };
    },
    theme: function theme() {
      return this.$chakraTheme();
    },
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    }
  },
  render: function render(h) {
    var this$1 = this;
    var ref = this.context;
    var focusableItems = ref.focusableItems;
    var focusAtIndex = ref.focusAtIndex;
    var closeOnSelect = ref.closeOnSelect;
    var closeMenu = ref.closeMenu;
    return h(CPseudoBox.default, {
      props: {
        as: this.as
      },
      attrs: Object.assign({}, {
        display: 'flex',
        textDecoration: 'none',
        color: 'inherit',
        minHeight: '32px',
        alignItems: 'center',
        textAlign: 'left',
        outline: 'none',
        px: 4
      }, this.menuItemStyles({
        theme: this.theme,
        colorMode: this.colorMode
      }), this.$attrs, {
        role: this.role,
        tabindex: -1,
        disabled: this.isDisabled,
        'aria-disabled': this.isDisabled,
        'data-chakra-component': 'CMenuItem'
      }),
      nativeOn: {
        click: function click(event) {
          this$1.$emit('click', event);

          if (this$1.isDisabled) {
            event.stopPropagation();
            event.preventDefault();
            return;
          }

          if (closeOnSelect) {
            closeMenu();
          }
        },
        mouseenter: function mouseenter(event) {
          this$1.$emit('mouseenter', event);

          if (this$1.isDisabled) {
            event.stopPropagation();
            event.preventDefault();
            return;
          }

          if (focusableItems && focusableItems.length > 0) {
            var nextIndex = focusableItems.indexOf(event.currentTarget);
            focusAtIndex(nextIndex);
          }
        },
        mouseleave: function mouseleave() {
          focusAtIndex(-1);
        },
        keydown: function keydown(event) {
          this$1.$emit('keydown', event);

          if (this$1.isDisabled) {
            return;
          }

          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault(); // We also emit click event to simulate click event for keyboard "Enter" keydown event

            this$1.$emit('click');

            if (closeOnSelect) {
              closeMenu();
            }
          }
        }
      }
    }, this.$slots.default);
  }
};
/**
 * CMenuDivider component
 *
 * The menu list divider element
 *
 * @see Docs https://vue.chakra-ui.com/menu
 */

var CMenuDivider = {
  name: 'CMenuDivider',
  functional: true,
  render: function render(h, ref) {
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["data"]);
    var rest = rest$1;
    return h(CDivider.default, Object.assign({}, rest, {
      attrs: Object.assign({}, {
        marginTop: '0.5rem',
        marginBottom: '0.5rem'
      }, data.attrs, {
        'data-chakra-component': 'CMenuDivider'
      })
    }));
  }
};
/**
 * CMenuGroup component
 *
 * The menu list item group.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/menu
 */

var CMenuGroup = {
  name: 'CMenuGroup',
  functional: true,
  props: {
    title: String
  },
  render: function render(h, ref) {
    var props = ref.props;
    var slots = ref.slots;
    var data = ref.data;
    return h('div', {
      attrs: {
        role: 'group',
        'data-chakra-component': 'CMenuGroup'
      }
    }, [props.title && h(CText.default, {
      attrs: Object.assign({}, {
        mx: 4,
        my: 2,
        fontWeight: 'semibold',
        fontSize: 'sm'
      }, data.attrs)
    }, props.title), slots().default]);
  }
};
exports.CMenu = CMenu;
exports.CMenuButton = CMenuButton;
exports.CMenuDivider = CMenuDivider;
exports.CMenuGroup = CMenuGroup;
exports.CMenuItem = CMenuItem;
exports.CMenuList = CMenuList;
exports.useMenuItemStyle = useMenuItemStyle;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(8);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CIcon = __webpack_require__(9);

var CPseudoBox = __webpack_require__(12);

__webpack_require__(6);

var CFlex = __webpack_require__(21);

__webpack_require__(15);

var CInput = __webpack_require__(61);

function isNumberKey(event) {
  var charCode = event.which ? event.which : event.keyCode;

  if (event.key === '.') {
    return true;
  }

  if (charCode > 31 && (charCode < 48 || charCode > 57) && (charCode < 96 || charCode > 105) && charCode !== 110) {
    return false;
  }

  return true;
}

function preventNonNumberKey(event) {
  if (!isNumberKey(event)) {
    event.preventDefault();
  }
}

function roundToPrecision(value, precision) {
  return value === '' ? parseFloat(0).toFixed(precision) : parseFloat(value).toFixed(precision);
}
/**
 * Calculates the precision of a value
 * @param {Number} value Value
 */


function calculatePrecision(value) {
  var groups = /[1-9]([0]+$)|\.([0-9]*)/.exec(String(value));

  if (!groups) {
    return 0;
  }

  if (groups[1]) {
    return -groups[1].length;
  }

  if (groups[2]) {
    return groups[2].length;
  }

  return 0;
}

var themedProps = {
  light: {
    borderColor: 'inherit',
    _active: {
      bg: 'gray.200'
    }
  },
  dark: {
    color: 'whiteAlpha.800',
    borderColor: 'whiteAlpha.300',
    _active: {
      bg: 'whiteAlpha.300'
    }
  }
};

var styleProps = function styleProps(ref) {
  var colorMode = ref.colorMode;
  var size = ref.size;
  return Object.assign({}, {
    borderLeft: '1px',
    _first: {
      roundedTopRight: size === 'sm' ? 1 : 3
    },
    _last: {
      roundedBottomRight: size === 'sm' ? 1 : 3,
      mt: '-1px',
      borderTopWidth: 1
    },
    _disabled: {
      opacity: 0.4,
      cursor: 'not-allowed'
    }
  }, themedProps[colorMode]);
};
/**
 * Hey! Welcome to @chakra-ui/vue Number Input
 *
 * The `CNumberInput` component is similar to the `CInput` component,
 * but it has controls for incrementing or decrementing numeric values.
 *
 * @see Docs     https://vue.chakra-ui.com/numberinput
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CNumberInput/CNumberInput.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CNumberInput/accessibility.md
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * CNumberInput component
 *
 * The wrapper that provides context and logic to the components
 *
 * @extends CFlex
 * @see Docs https://vue.chakra-ui.com/numberinput
 */


var CNumberInput = {
  name: 'CNumberInput',
  inheritAttrs: false,
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    value: [Number, String],
    defaultValue: Number,
    focusInputOnChange: {
      type: Boolean,
      default: true
    },
    clampValueOnBlur: {
      type: Boolean,
      default: true
    },
    keepWithinRange: {
      type: Boolean,
      default: true
    },
    min: {
      type: Number,
      default: -Infinity
    },
    max: {
      type: Number,
      default: Infinity
    },
    step: {
      type: Number,
      default: 1
    },
    precision: Number,
    getAriaValueText: Function,
    isReadOnly: Boolean,
    isInvalid: Boolean,
    isDisabled: Boolean,
    isFullWidth: Boolean,
    size: {
      type: String,
      default: 'md'
    },
    inputId: {
      type: String
    }
  },
  provide: function provide() {
    var this$1 = this;
    return {
      $NumberInputContext: function $NumberInputContext() {
        return this$1.NumberInputContext;
      }
    };
  },
  data: function data() {
    return {
      innerValue: this.defaultValue || null,
      isFocused: false,
      prevNexValue: null,
      inputNode: undefined,
      incrementPressed: false,
      decrementPressed: false,
      incrementEvents: {},
      decrementEvents: {},
      clickEvent: utils.canUseDOM && !!document.documentElement.ontouchstart ? 'touchstart' : 'mousedown',
      incrementStepperProps: undefined,
      decrementStepperProps: undefined,
      incrementTimerId: null,
      decrementTimerId: null
    };
  },
  computed: {
    NumberInputContext: function NumberInputContext() {
      var this$1 = this;
      return {
        size: this.size,
        value: this._value,
        isReadOnly: this.isReadOnly,
        isInvalid: this.isInvalid,
        isDisabled: this.isDisabled,
        isFocused: this.isFocused,
        incrementStepper: this.incrementStepperProps,
        decrementStepper: this.decrementStepperProps,
        incrementButton: {
          nativeOn: {
            click: function click() {
              return this$1.handleIncrement();
            }
          },
          attrs: Object.assign({}, {
            'aria-label': 'add'
          }, this.keepWithinRange & {
            disabled: this.value === this.max,
            'aria-disabled': this.value === this.max
          })
        },
        decrementButton: {
          nativeOn: {
            click: function click() {
              return this$1.handleDecrement();
            }
          },
          attrs: Object.assign({}, {
            'aria-label': 'subtract'
          }, this.keepWithinRange & {
            disabled: this.value === this.min,
            'aria-disabled': this.value === this.min
          })
        },
        input: Object.assign({}, {
          value: this._value,
          onChange: this.handleChange,
          onKeydown: this.handleKeydown,
          onFocus: function onFocus() {
            this$1.isFocused = true;
          },
          onBlur: function onBlur() {
            this$1.isFocused = false;

            if (this$1.clampValueOnBlur) {
              this$1.validateAndClamp();
            }
          },
          role: 'spinbutton',
          type: 'text',
          'aria-valuemin': this.min,
          'aria-valuemax': this.max,
          'aria-disabled': this.isDisabled,
          'aria-valuenow': this.value,
          'aria-invalid': this.isInvalid || this.isOutOfRange
        }, this.getAriaValueText && {
          'aria-valuetext': this.ariaValueText
        }, {
          readOnly: this.isReadOnly,
          disabled: this.isDisabled,
          autoComplete: 'off'
        }),
        hiddenLabel: {
          'aria-live': 'polite',
          text: this.getAriaValueText ? this.ariaValueText : this._value,
          style: {
            position: 'absolute',
            clip: 'rect(0px, 0px, 0px, 0px)',
            height: 1,
            width: 1,
            margin: -1,
            whiteSpace: 'nowrap',
            border: 0,
            overflow: 'hidden',
            padding: 0
          }
        },
        inputId: this._inputId
      };
    },
    isControlled: function isControlled() {
      return utils.isDef(this.value);
    },
    _value: {
      get: function get() {
        return this.isControlled ? roundToPrecision(this.value, this._precision) : this.innerValue ? roundToPrecision(this.innerValue, this._precision) : this.innerValue;
      },
      set: function set(val) {
        if (!this.defaultValue) {
          var nextValue = this.defaultValue;

          if (this.keepWithinRange) {
            nextValue = Math.max(Math.min(nextValue, this.max), this.min);
          }

          nextValue = roundToPrecision(nextValue, this._precision);
          this.innerValue = nextValue;
        }

        this.innerValue = val;
      }
    },
    defaultPrecision: function defaultPrecision() {
      return Math.max(calculatePrecision(this.step), 0);
    },
    _precision: function _precision() {
      return this.precision || this.defaultPrecision;
    },
    isInteractive: function isInteractive() {
      return !(this.isReadOnly || this.isDisabled);
    },
    isOutOfRange: function isOutOfRange() {
      return this._value > this.max || this.value < this.min;
    },
    ariaValueText: function ariaValueText() {
      return this.getAriaValueText ? this.getAriaValueText(this._value) : null;
    },
    _inputId: function _inputId() {
      return "number-input-" + (this.inputId || utils.useId());
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    var obj, obj$1;
    this.$nextTick(function () {
      this$1.inputNode = utils.getElement("#" + this$1._inputId, this$1.$el);
    }); // ================================= INCREMENT WATCHER

    this.$watch(function (vm) {
      return [vm.incrementPressed, vm._value];
    }, function () {
      if (this$1.incrementTimerId) {
        clearTimeout(this$1.incrementTimerId);
      }

      if (this$1.incrementPressed) {
        this$1.incrementTimerId = setTimeout(this$1.handleIncrement, 200);
      } else {
        clearTimeout(this$1.incrementTimerId);
      }
    });

    var startIncrement = function startIncrement() {
      this$1.handleIncrement();
      this$1.incrementPressed = true;
    };

    var stopIncrement = function stopIncrement() {
      this$1.incrementPressed = false;
    };

    this.incrementStepperProps = (obj = {}, obj[this.clickEvent] = startIncrement, obj.mouseup = stopIncrement, obj.mouseleave = stopIncrement, obj.touchend = stopIncrement, obj); // ================================= DECREMENT WATCHER

    this.$watch(function (vm) {
      return [vm.decrementPressed, vm._value];
    }, function () {
      if (this$1.decrementTimerId) {
        clearTimeout(this$1.decrementTimerId);
      }

      if (this$1.decrementPressed) {
        this$1.decrementTimerId = setTimeout(this$1.handleDecrement, 200);
      } else {
        clearTimeout(this$1.decrementTimerId);
      }
    });

    var startDecrement = function startDecrement() {
      this$1.handleDecrement();
      this$1.decrementPressed = true;
    };

    var stopDecrement = function stopDecrement() {
      this$1.decrementPressed = false;
    };

    this.decrementStepperProps = (obj$1 = {}, obj$1[this.clickEvent] = startDecrement, obj$1.mouseup = stopDecrement, obj$1.mouseleave = stopDecrement, obj$1.touchend = stopDecrement, obj$1);
  },
  methods: {
    /**
     * Validates and clamps input values
     */
    validateAndClamp: function validateAndClamp() {
      var maxExists = utils.isDef(this.max);
      var minExists = utils.isDef(this.min);

      if (maxExists && this._value > this.max) {
        this.updateValue(this.max);
      }

      if (minExists && this._value < this.min) {
        this.updateValue(this.min);
      }
    },

    /**
     * Get increment factor
     */
    getIncrementFactor: function getIncrementFactor(event) {
      var ratio = 1;

      if (event.metaKey || event.ctrlKey) {
        ratio = 0.1;
      }

      if (event.shiftKey) {
        ratio = 10;
      }

      return ratio;
    },

    /**
     * Determines whether a value should be converted to number
     * @param {String} value
     */
    shouldConvertToNumber: function shouldConvertToNumber(value) {
      var _value = typeof value !== 'string' ? String(value) : value;

      var hasDot = _value.includes('.');

      var hasTrailingZero = _value.substr(_value.length - 1) === '0';
      var hasTrailingDot = _value.substr(_value.length - 1) === '.';

      if (hasDot && hasTrailingZero) {
        return false;
      }

      if (hasDot && hasTrailingDot) {
        return false;
      }

      return true;
    },

    /**
     * Updates the current input value
     * @param {Number|String} nextValue value
     */
    updateValue: function updateValue(nextValue) {
      if (this.prevNextValue === nextValue) {
        return;
      }

      var shouldConvert = this.shouldConvertToNumber(nextValue);
      var converted = shouldConvert ? +nextValue : nextValue;

      if (!this.isControlled) {
        this._value = converted;
      }

      this.$emit('change', converted);
      this.prevNextValue = nextValue;
    },

    /**
     * Handles value increment
     * @param {Number} step Value to be incremented
     */
    handleIncrement: function handleIncrement(step) {
      if (step === void 0) step = this.step;

      if (!this.isInteractive) {
        return;
      }

      var nextValue = Number(this._value) + Number(step);

      if (this.keepWithinRange) {
        nextValue = Math.min(nextValue, this.max);
      }

      nextValue = roundToPrecision(nextValue, this._precision);
      this.updateValue(nextValue);
      this.$emit('increment', nextValue);
      this.focusInput();
    },

    /**
     * Handles value decrement
     * @param {Number} step Value to be decremented
     */
    handleDecrement: function handleDecrement(step) {
      if (step === void 0) step = this.step;

      if (!this.isInteractive) {
        return;
      }

      var nextValue = Number(this._value) - Number(step);

      if (this.keepWithinRange) {
        nextValue = Math.max(nextValue, this.min);
      }

      nextValue = roundToPrecision(nextValue, this._precision);
      this.updateValue(nextValue);
      this.$emit('decrement', nextValue);
      this.focusInput();
    },

    /**
     * Focus NumberInput element
     */
    focusInput: function focusInput() {
      var _this = this;

      requestAnimationFrame(function () {
        _this.inputNode && _this.inputNode.focus();
      });
    },

    /**
     * Handles "blur" event
     * @param {Event} event Event object
     */
    handleBlur: function handleBlur(event) {
      this.$emit('blur', event);
    },

    /**
     * Handles "focus" event
     * @param {Event} event Event object
     */
    handleFocus: function handleFocus(event) {
      this.$emit('focus', event);
    },

    /**
     * Handles "keydown" event
     * @param {Event} event Event object
     */
    handleKeydown: function handleKeydown(event) {
      this.$emit('keydown', event);
      preventNonNumberKey(event);

      if (!this.isInteractive) {
        return;
      }

      if (event.key === 'ArrowUp') {
        event.preventDefault();
        var ratio = this.getIncrementFactor(event);
        this.handleIncrement(ratio * this.step);
      }

      if (event.key === 'ArrowDown') {
        event.preventDefault();
        var ratio$1 = this.getIncrementFactor(event);
        this.handleDecrement(ratio$1 * this.step);
      }

      if (event.key === 'Home') {
        event.preventDefault();

        if (utils.isDef(this.min)) {
          this.updateValue(this.max);
        }
      }

      if (event.key === 'End') {
        event.preventDefault();

        if (utils.isDef(this.max)) {
          this.updateValue(this.min);
        }
      }
    },

    /**
     *
     * @param {Event} event Event object
     * @param {Any} event Value
     */
    handleChange: function handleChange(event, _value) {
      var finalValue;
      var ref = event.target;
      var value = ref.value;

      if (['', undefined].includes(value)) {
        finalValue = 0;
      }

      finalValue = value;
      this.updateValue(finalValue);
      this.$emit('change', finalValue, event);
    }
  },
  render: function render(h) {
    var ref = this.$props;
    var size = ref.size;
    var rest = objectWithoutProperties(ref, ["size"]);
    var styles = rest;
    return h(CFlex.CFlex, {
      props: {
        align: 'stretch'
      },
      attrs: Object.assign({}, styles, {
        w: this.isFullWidth ? 'full' : null,
        pos: 'relative',
        'data-chakra-component': 'CNumberInput'
      })
    }, this.$slots.default);
  }
};
/**
 * CNumberInputField component
 *
 * The `input` field itself
 *
 * @extends CInput
 * @see Docs https://vue.chakra-ui.com/numberinput
 */

var CNumberInputField = {
  name: 'CNumberInputField',
  inheritAttrs: false,
  inject: ['$NumberInputContext'],
  computed: {
    context: function context() {
      return this.$NumberInputContext();
    }
  },
  props: CInput.inputProps,
  render: function render(h) {
    var this$1 = this;
    var ref = this.context;
    var size = ref.size;
    var inputId = ref.inputId;
    var ref_input = ref.input;
    var value = ref_input.value;
    var _onBlur = ref_input.onBlur;
    var _onFocus = ref_input.onFocus;
    var _onChange = ref_input.onChange;
    var _onKeydown = ref_input.onKeydown;
    var isDisabled = ref_input.disabled;
    var isReadOnly = ref_input.readOnly;
    var rest = objectWithoutProperties(ref_input, ["value", "onBlur", "onFocus", "onChange", "onKeydown", "disabled", "readOnly"]);
    var otherInputAttrs = rest;
    return h(CInput.CInput, {
      props: Object.assign({}, this.$props, {
        isReadOnly: isReadOnly,
        isDisabled: isDisabled,
        size: size,
        value: value
      }),
      attrs: Object.assign({}, this.$attrs, {
        id: inputId
      }, otherInputAttrs, {
        'data-chakra-component': 'CNumberInputField'
      }),
      on: {
        change: utils.wrapEvent(function (e) {
          return this$1.$emit('change', e);
        }, _onChange)
      },
      nativeOn: {
        input: utils.wrapEvent(function (e) {
          return this$1.$emit('change', e);
        }, _onChange),
        blur: utils.wrapEvent(function (e) {
          return this$1.$emit('blur', e);
        }, _onBlur),
        focus: utils.wrapEvent(function (e) {
          return this$1.$emit('focus', e);
        }, _onFocus),
        keydown: utils.wrapEvent(function (e) {
          return this$1.$emit('keydown', e);
        }, _onKeydown)
      }
    });
  }
};
/**
 * CNumberInputStepper component
 *
 * The wrapper for the input's stepper buttons.
 *
 * @extends CFlex
 * @see Docs https://vue.chakra-ui.com/numberinput
 */

var CNumberInputStepper = {
  name: 'CNumberInputStepper',
  functional: true,
  render: function render(h, ref) {
    var data = ref.data;
    var slots = ref.slots;
    var rest$1 = objectWithoutProperties(ref, ["data", "slots"]);
    var rest = rest$1;
    return h(CFlex.CFlex, Object.assign({}, rest, {
      props: {
        direction: 'column'
      },
      attrs: {
        width: '24px',
        margin: '1px',
        position: 'absolute',
        right: '0px',
        height: 'calc(100% - 2px)',
        zIndex: 1,
        'data-chakra-component': 'CNumberInputStepper'
      }
    }), slots().default);
  }
};
/**
 * CStepperButton component
 *
 * The composable element for the stepper buttons.
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/numberinput
 */

var CStepperButton = {
  name: 'CStepperButton',
  inheritAttrs: false,
  inject: ['$NumberInputContext', '$chakraColorMode'],
  computed: {
    context: function context() {
      return this.$NumberInputContext();
    },
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    }
  },
  render: function render(h) {
    var ref = this.context;
    var isDisabled = ref.isDisabled;
    var size = ref.size;
    return h(CPseudoBox.default, {
      attrs: Object.assign({}, this.$attrs, {
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        flex: 1,
        transition: 'all 0.3s',
        userSelect: 'none',
        pointerEvents: isDisabled ? 'none' : undefined,
        lineHeight: 'normal'
      }, styleProps({
        colorMode: this.colorMode,
        size: size
      }), {
        'data-chakra-component': 'CStepperButton'
      })
    }, this.$slots.default);
  }
};
/**
 * CNumberIncrementStepper component
 *
 * The button to increment the value of the input.
 *
 * @extends CStepperButton
 * @see Docs https://vue.chakra-ui.com/numberinput
 */

var CNumberIncrementStepper = {
  name: 'CNumberIncrementStepper',
  inheritAttrs: false,
  inject: ['$NumberInputContext'],
  computed: {
    context: function context() {
      return this.$NumberInputContext();
    }
  },
  render: function render(h) {
    var children = this.$slots.default || [h(CIcon.CIcon, {
      props: {
        name: 'triangle-up'
      },
      attrs: {
        height: '0.6em',
        width: '0.6em'
      }
    })];
    var ref = this.context;
    var size = ref.size;
    var incrementStepper = ref.incrementStepper;
    var iconSize = size === 'sm' ? '11px' : '15px';
    return h(CStepperButton, {
      attrs: Object.assign({}, this.$attrs, {
        fontSize: iconSize,
        'data-chakra-component': 'CNumberIncrementStepper'
      }),
      nativeOn: incrementStepper
    }, children);
  }
};
/**
 * CNumberIncrementStepper component
 *
 * The button to decrement the value of the input.
 *
 * @extends CStepperButton
 * @see Docs https://vue.chakra-ui.com/numberinput
 */

var CNumberDecrementStepper = {
  name: 'CNumberDecrementStepper',
  inheritAttrs: false,
  inject: ['$NumberInputContext'],
  computed: {
    context: function context() {
      return this.$NumberInputContext();
    }
  },
  render: function render(h) {
    var children = this.$slots.default || [h(CIcon.CIcon, {
      props: {
        name: 'triangle-down'
      },
      attrs: {
        height: '0.6em',
        width: '0.6em'
      }
    })];
    var ref = this.context;
    var size = ref.size;
    var decrementStepper = ref.decrementStepper;
    var iconSize = size === 'sm' ? '11px' : '15px';
    return h(CStepperButton, {
      attrs: Object.assign({}, this.$attrs, {
        fontSize: iconSize,
        'data-chakra-component': 'CNumberDecrementStepper'
      }),
      nativeOn: decrementStepper
    }, children);
  }
};
exports.CNumberDecrementStepper = CNumberDecrementStepper;
exports.CNumberIncrementStepper = CNumberIncrementStepper;
exports.CNumberInput = CNumberInput;
exports.CNumberInputField = CNumberInputField;
exports.CNumberInputStepper = CNumberInputStepper;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(8);

__webpack_require__(25);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

__webpack_require__(9);

__webpack_require__(12);

__webpack_require__(16);

var CCloseButton = __webpack_require__(65);

__webpack_require__(17);

__webpack_require__(13);

var CFragment = __webpack_require__(60);

var CPopper = __webpack_require__(62);
/**
 * Hey! Welcome to @chakra-ui/vue Popover
 *
 * Popover is a non-modal dialog that floats around a trigger. It's used to display contextual information to the user.
 *
 * @see Docs     https://vue.chakra-ui.com/popover
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CPopover/CPopover.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CPopover/accessibility.md
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * CPopover component
 *
 * The wrapper that provides props, state, and context to it's children
 *
 * @extends CFlex
 * @see Docs https://vue.chakra-ui.com/popover
 */


var CPopover = {
  name: 'CPopover',
  provide: function provide() {
    var this$1 = this;
    return {
      $PopoverContext: function $PopoverContext() {
        return this$1.PopoverContext;
      }
    };
  },
  props: {
    id: String,
    defaultIsOpen: Boolean,
    isOpen: Boolean,
    returnFocusOnClose: {
      type: Boolean,
      default: true
    },
    initialFocusRef: [Object, String, Function],
    trigger: {
      type: String,
      default: 'click'
    },
    closeOnBlur: {
      type: Boolean,
      default: true
    },
    closeOnEscape: {
      type: Boolean,
      default: true
    },
    usePortal: Boolean,
    placement: {
      type: String,
      default: 'auto'
    }
  },
  computed: {
    PopoverContext: function PopoverContext() {
      return {
        set: this.set,
        isOpen: this._isOpen,
        closePopover: this.closePopover,
        openPopover: this.openPopover,
        toggleOpen: this.toggleOpen,
        triggerNode: this.triggerNode,
        contentNode: this.contentNode,
        setTriggerNode: this.setTriggerNode,
        popoverId: this.computedId,
        trigger: this.trigger,
        isHovering: this.isHovering,
        handleBlur: this.handleBlur,
        closeOnEscape: this.closeOnEscape,
        headerId: this.headerId,
        bodyId: this.bodyId,
        usePortal: this.usePortal,
        placement: this.placement
      };
    },
    isControlled: function isControlled() {
      return this.isOpen !== false;
    },
    _isOpen: {
      get: function get() {
        return this.isControlled ? this.isOpen : this.isOpenValue;
      },
      set: function set(value) {
        this.isOpenValue = value;
      }
    },
    _initialFocusRef: function _initialFocusRef() {
      return utils.isFunction(this.initialFocusRef) ? this.getNode(this.initialFocusRef()) : this.getNode(this.initialFocusRef);
    },
    headerId: function headerId() {
      return this.computedId + "-header";
    },
    bodyId: function bodyId() {
      return this.computedId + "-body";
    },
    computedId: function computedId() {
      return this.id || "popover-id-" + utils.useId();
    }
  },
  data: function data() {
    return {
      isOpenValue: this.defaultIsOpen || false,
      triggerNode: undefined,
      contentNode: undefined,
      prevIsOpen: false,
      isHovering: false
    };
  },
  mounted: function mounted() {
    var this$1 = this;
    /**
     * The purpose of this watcher is to keep record of the previous
     * isOpen value.
     */

    this.$watch('_isOpen', function (_newVal, oldVal) {
      this$1.prevIsOpen = oldVal;
    }, {
      immediate: true
    });
    this.$watch(function (vm) {
      return [vm._isOpen, vm._initialFocusRef, vm.trigger, vm.contentNode, vm.triggerNode, vm.prevIsOpen, vm.returnFocusOnClose];
    }, function () {
      if (this$1._isOpen && this$1.trigger === 'click') {
        /**
         * Caveat here:
         * Until Vue 3 is release, using it's $refs as props may not always return a value
         * in the props unless the consumer component updates it's context. This is because
         * Vue asynchronously updtaes the DOM and is also not reactive.
         *
         * Where this doesnt' work, we fallback to using an element selector to query
         * the element from the DOM. And use it as the initial focus ref.
         *
         * Work-around could be to use plain old JS selectors
         */
        setTimeout(function () {
          if (this$1._initialFocusRef) {
            this$1._initialFocusRef.focus();
          } else if (this$1.contentNode) {
            this$1.contentNode.focus();
          }
        });
      }

      if (!this$1._isOpen && this$1.prevIsOpen && this$1.trigger === 'click' && this$1.returnFocusOnClose) {
        if (this$1.triggerNode) {
          this$1.triggerNode.focus();
        }
      }
    });
  },
  methods: {
    /**
     * Closes popover
     */
    closePopover: function closePopover() {
      if (!this.isControlled) {
        this._isOpen = false;
      }

      this.$emit('close');
    },

    /**
     * Opens popover
     */
    openPopover: function openPopover() {
      if (!this.isControlled) {
        this._isOpen = true;
      }

      this.$emit('open');
    },

    /**
     * Toggles disclosure state of popover
     */
    toggleOpen: function toggleOpen() {
      if (!this.isControlled) {
        this._isOpen = !this._isOpen;
      }

      if (this._isOpen !== true) {
        this.$emit('open');
      } else {
        this.$emit('close');
      }
    },

    /**
     * Handles blur event
     * @param {Event} e `blur` event object
     */
    handleBlur: function handleBlur(event) {
      if (this._isOpen && this.closeOnBlur && this.contentNode && this.triggerNode && !this.contentNode.contains(event.relatedTarget) && !this.triggerNode.contains(event.relatedTarget)) {
        this.closePopover();
      }
    },

    /**
     * Returns the HTML element of a Vue component or native element
     * @param {Vue.Component|HTMLElement|String} element HTMLElement or Vue Component
     */
    getNode: function getNode(element) {
      if (utils._typeof(element) === 'object') {
        var isVue = utils.isVueComponent(element);
        return isVue ? element.$el : element;
      } else if (typeof element === 'string') {
        return utils.getElement(element);
      }

      return null;
    },

    /**
     * Sets the value of any component instance property.
     * This function is to be passed down to context so that consumers
     * can mutate context values with out doing it directly.
     * Serves as a temporary fix until Vue 3 comes out
     * @param {String} prop Component instance property
     * @param {Any} value Property value
     */
    set: function set(prop, value) {
      this[prop] = value;
      return this[prop];
    }
  },
  render: function render(h) {
    return h(CFragment.default, {
      attrs: {
        'data-chakra-component': 'CPopover'
      }
    }, [this.$scopedSlots.default({
      isOpen: this._isOpen,
      onClose: this.closePopover
    })]);
  }
};
/**
 * CPopoverTrigger component
 *
 * Used to wrap the reference (or trigger) element.
 *
 * @extends this.$slots.default
 * @see Docs https://vue.chakra-ui.com/popover
 */

var CPopoverTrigger = {
  name: 'CPopoverTrigger',
  inheritAttrs: false,
  inject: ['$PopoverContext'],
  computed: {
    triggerId: function triggerId() {
      return "popover-trigger-" + utils.useId();
    },
    context: function context() {
      return this.$PopoverContext();
    },
    headerId: function headerId() {
      return this.context.headerId;
    },
    bodyId: function bodyId() {
      return this.context.bodyId;
    },
    eventHandlers: function eventHandlers() {
      var this$1 = this;
      var ref = this.context;
      var trigger = ref.trigger;

      if (trigger === 'click') {
        return {
          click: function click(e) {
            this$1.$emit('click', e);
            this$1.context.toggleOpen();
          }
        };
      }

      if (trigger === 'hover') {
        return {
          focus: function focus(e) {
            this$1.$emit('focus', e);
            this$1.context.openPopover();
          },
          keydown: function keydown(e) {
            this$1.$emit('keydown', e);

            if (e.key === 'Escape') {
              setTimeout(this$1.context.closePopover(), 300);
            }
          },
          blur: function blur(e) {
            this$1.$emit('blur', e);
            this$1.context.closePopover();
          },
          mouseenter: function mouseenter(e) {
            this$1.$emit('mouseenter', e);
            this$1.context.set('isHovering', true);
            setTimeout(this$1.context.openPopover(), 300);
          },
          mouseleave: function mouseleave(e) {
            this$1.$emit('mouseleave', e);
            this$1.context.set('isHovering', false);
            setTimeout(function () {
              if (this$1.context.isHovering === false) {
                this$1.context.closePopover();
              }
            }, 300);
          }
        };
      }
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    var ref = this.context;
    var set = ref.set;
    this.$nextTick(function () {
      var triggerNode = utils.getElement("#" + this$1.triggerId);

      if (!triggerNode) {
        console.warn('[Chakra-ui]: Unable to locate PopoverTrigger node');
      } else {
        set('triggerNode', triggerNode);
      }
    });
  },
  render: function render(h) {
    var children = this.$slots.default.filter(function (e) {
      return e.tag;
    });

    if (!children) {
      return console.error('[Chakra-ui]: Popover Trigger expects at least one child');
    }

    if (children.length && children.length > 1) {
      return console.error('[Chakra-ui]: Popover Trigger can only have a single child element');
    }

    var cloned = utils.cloneVNode(children[0], h);
    var ref = this.context;
    var isOpen = ref.isOpen;
    var popoverId = ref.popoverId;
    var clone = h(cloned.componentOptions.Ctor, Object.assign({}, cloned.data, cloned.componentOptions.listeners || {}, {
      props: Object.assign({}, cloned.data.props || {}, cloned.componentOptions.propsData),
      attrs: Object.assign({}, cloned.data.attrs, this.$attrs, {
        id: this.triggerId,
        'aria-haspopup': 'dialog',
        'aria-expanded': isOpen,
        'aria-controls': popoverId,
        'data-chakra-component': 'CPopoverTrigger'
      }),
      nativeOn: this.eventHandlers
    }), cloned.componentOptions.children);
    return clone;
  }
};
/**
 * CPopoverContent component
 *
 * The popover content element itself.
 *
 * @extends CPopper
 * @see Docs https://vue.chakra-ui.com/popover
 */

var CPopoverContent = {
  name: 'CPopoverContent',
  inheritAttrs: false,
  inject: ['$PopoverContext', '$chakraColorMode'],
  props: {
    gutter: {
      type: [Number, String],
      default: 4
    },
    ariaLabel: String
  },
  computed: {
    context: function context() {
      return this.$PopoverContext();
    },
    contentId: function contentId() {
      return "popover-content-" + utils.useId();
    },
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    },
    eventHandlers: function eventHandlers() {
      var this$1 = this;
      var ref = this.context;
      var trigger = ref.trigger;
      var handleBlur = ref.handleBlur;
      var closePopover = ref.closePopover;
      var closeOnEscape = ref.closeOnEscape;
      var eventHandlers = {};

      if (trigger === 'click') {
        eventHandlers = {
          blur: function blur(e) {
            this$1.$emit('blur', e);
            handleBlur(e);
          }
        };
      }

      if (trigger === 'hover') {
        eventHandlers = Object.assign({}, eventHandlers, {
          mouseenter: function mouseenter(e) {
            this$1.$emit('mouseenter', e);
            this$1.context.set('isHovering', true);
            setTimeout(this$1.context.openPopover(), 300);
          },
          mouseleave: function mouseleave(e) {
            this$1.$emit('mouseleave', e);
            this$1.context.set('isHovering', false);
            setTimeout(function () {
              if (this$1.context.isHovering === false) {
                this$1.context.closePopover();
              }
            }, 300);
          }
        });
      }

      eventHandlers = Object.assign({}, eventHandlers, {
        keydown: function keydown(e) {
          this$1.$emit('keydown', e);

          if (e.key === 'Escape' && closeOnEscape) {
            closePopover && closePopover();
          }
        }
      });
      return eventHandlers;
    },
    calculatedAttrs: function calculatedAttrs() {
      var ref = this.context;
      var trigger = ref.trigger;

      if (trigger === 'click') {
        return {
          role: 'dialog',
          'aria-modal': 'false'
        };
      }

      if (trigger === 'hover') {
        return {
          role: 'tooltip'
        };
      }
    }
  },
  mounted: function mounted() {
    var ref = this.context;
    var set = ref.set;
    var popoverId = ref.popoverId;
    this.$nextTick(function () {
      var contentNode = utils.getElement("#" + popoverId);

      if (!contentNode) {
        console.warn('[Chakra-ui]: Unable to locate PopoverContent node');
      } else {
        set('contentNode', contentNode);
      }
    });
  },
  render: function render(h) {
    var ref = this.context;
    var isOpen = ref.isOpen;
    var triggerNode = ref.triggerNode;
    var popoverId = ref.popoverId;
    var usePortal = ref.usePortal;
    var placement = ref.placement;
    var bg = this.colorMode === 'light' ? 'white' : 'gray.700';
    return h(CPopper.CPopper, {
      props: {
        as: 'section',
        usePortal: usePortal,
        isOpen: isOpen,
        placement: placement,
        anchorEl: triggerNode,
        modifiers: [{
          name: 'offset',
          options: {
            offset: [0, this.gutter]
          }
        }]
      },
      attrs: Object.assign({}, {
        bg: bg,
        width: '100%',
        position: 'relative',
        display: 'flex',
        flexDirection: 'column',
        rounded: 'md',
        shadow: 'sm',
        maxWidth: 'xs',
        _focus: {
          outline: 0,
          shadow: 'outline'
        }
      }, this.$attrs, {
        id: popoverId,
        tabindex: -1,
        'aria-labelledby': this.headerId,
        'aria-describedby': this.bodyId,
        'aria-label': this.ariaLabel,
        'aria-hidden': !isOpen
      }, this.calculatedAttrs, {
        'data-chakra-component': 'CPopoverContent'
      }),
      nativeOn: this.eventHandlers
    }, this.$slots.default);
  }
};
/**
 * CPopoverHeader component
 *
 * The header of the popover.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/popover
 */

var CPopoverHeader = {
  name: 'CPopoverHeader',
  mixins: [utils.createStyledAttrsMixin('CPopoverHeader')],
  inject: ['$PopoverContext'],
  computed: {
    context: function context() {
      return this.$PopoverContext();
    },
    headerId: function headerId() {
      return this.context.headerId;
    },
    componentStyles: function componentStyles() {
      return {
        px: '0.75rem',
        py: '0.5rem',
        borderBottomWidth: '1px'
      };
    }
  },
  render: function render(h) {
    return h('header', {
      class: [this.className],
      attrs: Object.assign({}, this.computedAttrs, {
        id: this.headerId,
        'data-chakra-component': 'CPopoverHeader'
      }),
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CPopoverBody component
 *
 * The body of the popover.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/popover
 */

var CPopoverBody = {
  name: 'CPopoverBody',
  mixins: [utils.createStyledAttrsMixin('CPopoverBody')],
  inject: ['$PopoverContext'],
  computed: {
    context: function context() {
      return this.$PopoverContext();
    },
    bodyId: function bodyId() {
      return this.context.bodyId;
    },
    componentStyles: function componentStyles() {
      return {
        flex: 1,
        px: '0.75rem',
        py: '0.5rem'
      };
    }
  },
  render: function render(h) {
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, this.computedAttrs, {
        id: this.bodyId,
        'data-chakra-component': 'CPopoverBody'
      }),
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CPopoverArrow component
 *
 * A visual arrow that points to the reference (or trigger).
 *
 * @extends CPopperArrow
 * @see Docs https://vue.chakra-ui.com/popover
 */

var CPopoverArrow = {
  name: 'CPopoverArrow',
  functional: true,
  render: function render(h, ref) {
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["data"]);
    var rest = rest$1;
    return h(CPopper.CPopperArrow, Object.assign({}, rest, {
      attrs: Object.assign({}, data.attrs, {
        'data-chakra-component': 'CPopoverArrow'
      })
    }));
  }
};
/**
 * CPopoverCloseButton component
 *
 * The button to close the popover.
 *
 * @extends CCloseButton
 * @see Docs https://vue.chakra-ui.com/popover
 */

var CPopoverCloseButton = {
  name: 'CPopoverCloseButton',
  inheritAttrs: false,
  inject: ['$PopoverContext'],
  computed: {
    context: function context() {
      return this.$PopoverContext();
    }
  },
  render: function render(h) {
    var this$1 = this;
    return h(CCloseButton.default, {
      props: {
        size: 'sm'
      },
      on: {
        click: function click(e) {
          this$1.$emit('click', e);
          this$1.context.closePopover();
        }
      },
      attrs: Object.assign({}, {
        pos: 'absolute',
        rounded: 'md',
        top: 1,
        right: 2,
        p: 2
      }, this.$attrs, {
        'data-chakra-component': 'CPopoverCloseButton'
      })
    });
  }
};
/**
 * CPopoverFooter component
 *
 * The footer of the popover.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/popover
 */

var CPopoverFooter = {
  name: 'CPopoverFooter',
  functional: true,
  render: function render(h, ref) {
    var data = ref.data;
    var slots = ref.slots;
    var rest$1 = objectWithoutProperties(ref, ["data", "slots"]);
    return h(CBox.default, {
      props: {
        as: 'footer'
      },
      attrs: Object.assign({}, {
        px: '0.75rem',
        py: '0.5rem',
        borderTopWidth: '1px'
      }, data.attrs, {
        'data-chakra-component': 'CPopoverFooter'
      })
    }, slots().default);
  }
};
exports.CPopover = CPopover;
exports.CPopoverArrow = CPopoverArrow;
exports.CPopoverBody = CPopoverBody;
exports.CPopoverCloseButton = CPopoverCloseButton;
exports.CPopoverContent = CPopoverContent;
exports.CPopoverFooter = CPopoverFooter;
exports.CPopoverHeader = CPopoverHeader;
exports.CPopoverTrigger = CPopoverTrigger;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

var css = __webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);
/**
 * Hey! Welcome to @chakra-ui/vue Progess
 *
 * Progress is used to display the progress status
 * for a task that takes a long time or consists of several steps.
 *
 * @see Docs     https://vue.chakra-ui.com/progress
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CProgess/CProgess.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CProgess/accessibility.md
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}

var stripe = css.keyframes({
  from: {
    backgroundPosition: '1rem 0'
  },
  to: {
    backgroundPosition: '0 0'
  }
});
var stripeAnimation = css.css({
  animation: stripe + " 1s linear infinite"
});
var progressbarSizes = {
  lg: '1rem',
  md: '0.75rem',
  sm: '0.5rem'
};
/**
 * CProgressLabel component
 *
 * The label for the progress component
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/progress
 */

var CProgressLabel = {
  name: 'CProgressLabel',
  functional: true,
  render: function render(h, ref) {
    var data = ref.data;
    var slots = ref.slots;
    var rest$1 = objectWithoutProperties(ref, ["data", "slots"]);
    var rest = rest$1;
    return h(CBox.default, Object.assign({}, rest, {
      props: {
        as: data.attrs && data.attrs.as || 'div'
      },
      attrs: Object.assign({}, {
        textAlign: 'center',
        width: '100%'
      }, data.attrs, {
        'data-chakra-component': 'CProgressLabel'
      })
    }), slots().default);
  }
};
/**
 * CProgressTrack component
 *
 * The track for the progress component
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/progress
 */

var CProgressTrack = {
  name: 'CProgressTrack',
  functional: true,
  props: {
    size: [String, Number, Array]
  },
  render: function render(h, ref) {
    var props = ref.props;
    var slots = ref.slots;
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["props", "slots", "data"]);
    var rest = rest$1;
    return h(CBox.default, Object.assign({}, rest, {
      attrs: Object.assign({}, {
        pos: 'relative',
        height: progressbarSizes[props.size || 'md'],
        overflow: 'hidden',
        w: '100%',
        'data-chakra-component': 'CProgressTrack'
      }, data.attrs)
    }), slots().default);
  }
};
/**
 * CProgressIndicator component
 *
 * The indicator for the progress component
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/progress
 */

var CProgressIndicator = {
  name: 'CProgressIndicator',
  mixins: [utils.createStyledAttrsMixin('CProgressIndicator')],
  props: {
    isIndeterminate: Boolean,
    min: Number,
    max: Number,
    value: Number
  },
  computed: {
    percent: function percent() {
      return utils.valueToPercent(this.value, this.min, this.max);
    },
    componentStyles: function componentStyles() {
      return {
        height: '100%',
        transition: 'all 0.3s',
        width: this.percent + "%"
      };
    }
  },
  render: function render(h) {
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, this.computedAttrs, {
        'aria-valuemax': this.max,
        'aria-valuemin': this.min,
        'aria-valuenow': this.isIndeterminate ? null : this.value,
        role: 'progressbar',
        'data-chakra-component': 'CProgressIndicator'
      }),
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CProgress component
 *
 * The progress component wrapper
 *
 * @extends CProgressTrack
 * @see Docs https://vue.chakra-ui.com/progress
 */

var CProgress = {
  name: 'CProgress',
  inheritAttrs: false,
  inject: ['$chakraColorMode'],
  props: {
    color: {
      type: String,
      default: 'blue'
    },
    value: {
      type: Number,
      default: 63
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    size: {
      type: [String, Array],
      default: 'md'
    },
    hasStripe: Boolean,
    isAnimated: Boolean,
    borderRadius: [String, Array, Number],
    rounded: [String, Array],
    isIndeterminate: Boolean
  },
  computed: {
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    },
    trackColor: function trackColor() {
      return {
        light: 'gray.100',
        dark: 'whiteAlpha.300'
      };
    },
    indicatorColor: function indicatorColor() {
      return {
        light: this.color + ".500",
        dark: this.color + ".200"
      };
    },
    stripeStyle: function stripeStyle() {
      return {
        light: utils.generateStripe({}),
        dark: utils.generateStripe({
          color: 'rgba( 0, 0, 0, 0.1)'
        })
      };
    },
    __borderRadius: function __borderRadius() {
      return this.rounded || this.borderRadius;
    }
  },
  render: function render(h) {
    var _borderRadius = this.rounded || this.borderRadius;

    var trackColor = {
      light: 'gray.100',
      dark: 'whiteAlpha.300'
    };
    var indicatorColor = {
      light: this.color + ".500",
      dark: this.color + ".200"
    };
    var stripeStyle = {
      light: utils.generateStripe({}),
      dark: utils.generateStripe({
        color: 'rgba( 0, 0, 0, 0.1)'
      })
    };
    return h(CProgressTrack, {
      props: {
        size: this.size
      },
      attrs: Object.assign({}, {
        bg: trackColor[this.colorMode],
        borderRadius: _borderRadius,
        'data-chakra-component': 'CProgress'
      }, this.$attrs)
    }, [h(CProgressIndicator, {
      class: [this.hasStripe && stripeStyle[this.colorMode], this.hasStripe && this.isAnimated && stripeAnimation],
      props: {
        min: this.min,
        max: this.max,
        value: this.value
      },
      attrs: Object.assign({}, {
        bgColor: indicatorColor[this.colorMode],
        borderRadius: this.__borderRadius
      }, this.isIndeterminate && {
        width: '100%',
        position: 'absolute',
        top: 0,
        left: 0,
        bottom: 0,
        willChange: 'left, right'
      })
    }, this.$slots.default)]);
  }
};
exports.CProgress = CProgress;
exports.CProgressLabel = CProgressLabel;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

var CVisuallyHidden = __webpack_require__(18);

var CControlBox = __webpack_require__(58);

var checkbox_styles = __webpack_require__(70);
/**
 * Hey! Welcome to @chakra-ui/vue CRadio
 *
 * Radios are used when only one choice may be
 * selected in a series of options.
 *
 * @see Docs     https://vue.chakra-ui.com/radio
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CRadio/CRadio.js
 */

/**
 * CRadio component
 *
 * The accessible radio component
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/radio
 */


var CRadio = {
  name: 'CRadio',
  mixins: [utils.createStyledAttrsMixin('CRadio')],
  model: {
    prop: 'isChecked',
    event: 'checked'
  },
  props: {
    id: String,
    name: String,
    value: [String, Number],
    ariaLabel: String,
    ariaLabelledBy: String,
    variantColor: {
      type: String,
      default: 'blue'
    },
    defaultIsChecked: Boolean,
    isChecked: Boolean,
    isFullWidth: Boolean,
    size: {
      type: String,
      default: 'md'
    },
    isDisabled: Boolean,
    isInvalid: Boolean
  },
  computed: {
    radioStyles: function radioStyles() {
      utils.useVariantColorWarning(this.theme, 'Radio', this.variantColor);
      return checkbox_styles.useCheckboxStyle({
        color: this.variantColor,
        size: this.size,
        colorMode: this.colorMode,
        type: 'radio'
      });
    },
    componentStyles: function componentStyles() {
      return {
        display: 'inline-flex',
        verticalAlign: 'top',
        alignItems: 'center',
        width: this.isFullWidth ? 'full' : undefined,
        cursor: this.isDisabled ? 'not-allowed' : 'pointer'
      };
    },
    _id: function _id() {
      return this.id || "radio-" + utils.useId(4);
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$nextTick(function () {
      this$1.$emit('checked', Boolean(this$1.defaultIsChecked));
    });
  },
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;
    return h('label', {
      class: [this.className],
      attrs: Object.assign({}, {
        for: this.id
      }, this.computedAttrs)
    }, [h(CVisuallyHidden.default, {
      props: {
        as: 'input'
      },
      domProps: {
        checked: this.isChecked,
        value: this.value
      },
      attrs: {
        type: 'radio',
        'aria-label': this.ariaLabel,
        'aria-labelledby': this.ariaLabelledBy,
        id: this.id,
        name: this.name,
        'aria-invalid': this.isInvalid,
        disabled: this.isDisabled,
        'aria-disabled': this.isDisabled
      },
      nativeOn: {
        change: function change(e) {
          this$1.$emit('change', e);
          this$1.$emit('checked', e.target.checked);
        }
      }
    }), h(CControlBox.default, {
      attrs: Object.assign({}, this.radioStyles, {
        rounded: 'full',
        type: 'radio'
      })
    }, [h(CBox.default, {
      props: {
        as: 'span'
      },
      attrs: {
        bg: 'currentColor',
        rounded: 'full',
        w: '50%',
        h: '50%'
      }
    })]), children && h(CBox.default, {
      attrs: {
        ml: 2,
        fontSize: this.size,
        fontFamily: 'body',
        userSelect: 'none',
        opacity: this.isDisabled ? 0.32 : 1
      }
    }, children)]);
  }
};
exports.default = CRadio;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

var props_types = __webpack_require__(6);
/**
 * Hey! Welcome to @chakra-ui/vue CRadioGroup
 *
 * CRadioGroup component is a wrapper for it's Radio children
 *
 * @see Docs     https://vue.chakra-ui.com/radio
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CRadioGroup/CRadioGroup.js
 */

/**
 * CRadioGroup component
 *
 * The group for radio element children
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/radio
 */


var CRadioGroup = {
  name: 'CRadioGroup',
  mixins: [utils.createStyledAttrsMixin('CRadioGroup')],
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    name: String,
    variantColor: String,
    size: String,
    isInline: Boolean,
    value: {
      type: props_types.StringNumber,
      default: null
    },
    spacing: {
      type: [String, Number],
      default: 2
    },
    as: {
      type: String,
      default: 'fieldset'
    }
  },
  computed: {
    computedName: function computedName() {
      return this.name || "radio-" + utils.useId();
    }
  },
  methods: {
    /**
     * Handles event changes in radio group
     * @param {Event} event Event object
     */
    handleChange: function handleChange(event) {
      this.$emit('change', event.target.value);
    },

    /**
     * Focuses the selected option or first enabled option
     */
    focus: function focus() {
      var this$1 = this;
      var rootRef = this.$refs.radioGroup.$el;

      rootRef.focus = function () {
        var input = rootRef.querySelector('input:not(:disabled):checked');

        if (!input) {
          input = rootRef.querySelector('input:not(:disabled)');
        }

        if (input) {
          this$1.$nextTick(function () {
            input.focus();
          });
        }
      };
    }
  },
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;
    var clones = children.map(function (vnode, index) {
      if (!vnode.tag) {
        return;
      }

      var isLastRadio = children.length === index + 1;
      var spacingProps = this$1.isInline ? {
        mr: this$1.spacing
      } : {
        mb: this$1.spacing
      };
      var clone = utils.cloneVNodeElement(vnode, {
        props: {
          size: vnode.componentOptions.propsData.size || this$1.size,
          variantColor: vnode.componentOptions.propsData.variantColor || this$1.variantColor,
          name: this$1.computedName,
          isChecked: vnode.componentOptions.propsData.value === this$1.value
        },
        nativeOn: {
          change: function change(e) {
            return this$1.handleChange(e);
          }
        }
      }, h);
      return h(CBox.default, {
        attrs: Object.assign({}, {
          display: this$1.isInline ? 'inline-block' : 'block'
        }, !isLastRadio && spacingProps)
      }, [clone]);
    });
    return h('div', {
      class: [this.className],
      attrs: Object.assign({}, this.computedAttrs, {
        role: 'radiogroup',
        'data-chakra-component': 'CRadioGroup'
      })
    }, clones);
  }
};
exports.default = CRadioGroup;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var props_types = __webpack_require__(6);
/**
 * Hey! Welcome to @chakra-ui/vue CRadioButtonGroup
 *
 * RadioButtonGroup component provides radio type component
 *
 * @see Docs     https://vue.chakra-ui.com/radio
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CRadioButtonGroup/CRadioButtonGroup.js
 */

/**
 * CRadioButtonGroup component
 *
 * The group wrapper for radio button children
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/radio
 */


var CRadioButtonGroup = {
  name: 'CRadioButtonGroup',
  mixins: [utils.createStyledAttrsMixin('CRadioButtonGroup')],
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    name: String,
    defaultValue: {
      type: props_types.StringNumber,
      default: null
    },
    value: props_types.StringNumber,
    spacing: {
      type: props_types.SNA,
      default: '12px'
    },
    isInline: Boolean
  },
  data: function data() {
    return {
      focusableValues: [],
      allValues: [],
      allNodes: []
    };
  },
  computed: {
    computedName: function computedName() {
      return this.name || "radiobutton-" + utils.useId();
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    var children = utils.cleanChildren(this.$slots.default);
    this.focusableValues = children.map(function (child) {
      return child.componentOptions.propsData.isDisabled === true ? null : child.componentOptions.propsData.value;
    }).filter(function (val) {
      return utils.isDef(val);
    });
    this.allValues = children.map(function (vnode) {
      return vnode.componentOptions.propsData.value;
    });
    this.$nextTick(function () {
      var children = this$1.$el.children;
      this$1.allNodes = Object.assign({}, children);
    });
  },
  methods: {
    /**
     * Updates the current selected index
     * @param {Number} index
     */
    updateIndex: function updateIndex(index) {
      var childValue = this.focusableValues[index];

      var _index = this.allValues.indexOf(childValue);

      this.allNodes[_index].focus();

      this.$emit('change', childValue);
    },

    /**
     * Handle keydown event
     * @param {Event} event Event object
     */
    handleKeyDown: function handleKeyDown(event) {
      if (event.key === 'Tab') {
        return;
      }

      event.preventDefault();
      var count = this.focusableValues.length;
      var enabledCheckedIndex = this.focusableValues.indexOf(this.value);

      if (enabledCheckedIndex === -1) {
        enabledCheckedIndex = 0;
      }

      switch (event.key) {
        case 'ArrowRight':
        case 'ArrowDown':
          {
            var nextIndex;
            nextIndex = (enabledCheckedIndex + 1) % count;

            if (this.allNodes[nextIndex].disabled) {
              nextIndex = (enabledCheckedIndex + 2) % count;
            }

            this.updateIndex(nextIndex);
            break;
          }

        case 'ArrowLeft':
        case 'ArrowUp':
          {
            var nextIndex$1;
            nextIndex$1 = (enabledCheckedIndex - 1 + count) % count;

            if (this.allNodes[nextIndex$1].disabled) {
              nextIndex$1 = (enabledCheckedIndex - 2 + count) % count;
            }

            this.updateIndex(nextIndex$1);
            break;
          }
      }
    }
  },
  render: function render(h) {
    var children = this.$slots.default;

    if (!children) {
      console.warn("\n        [Chakra-ui]: The <RadioButtonGroup> component expects at least one child.\n      ");
      return;
    }

    var _this = this;

    var clones = children.filter(function (vnode) {
      return utils.isDef(vnode.tag);
    }).map(function (vnode, index) {
      var isLastChild = children.length === index + 1;
      var isFirstChild = index === 0;
      var props = vnode.componentOptions.propsData;
      var spacingProps = _this.isInline ? {
        mr: _this.spacing
      } : {
        mb: _this.spacing
      };
      var isChecked = props.value === _this.value;

      var handleClick = function handleClick() {
        _this.$emit('change', props.value);
      };

      var getTabIndex = function getTabIndex() {
        // If a RadioGroup has no radio selected the first enabled radio should be focusable
        if (_this.value == null) {
          return isFirstChild ? 0 : -1;
        } else {
          return isChecked ? 0 : -1;
        }
      };

      return utils.cloneVNodeElement(vnode, {
        props: Object.assign({}, {
          name: _this.computedName,
          isChecked: isChecked
        }, !isLastChild && spacingProps),
        attrs: {
          tabindex: getTabIndex()
        },
        nativeOn: {
          click: handleClick
        }
      }, h);
    });
    return h('div', {
      class: [this.className],
      attrs: Object.assign({}, this.computedAttrs, {
        role: 'radiogroup'
      }),
      on: Object.assign({}, this.computedListeners, {
        keydown: this.handleKeyDown
      })
    }, clones);
  }
};
exports.default = CRadioButtonGroup;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var props_types = __webpack_require__(6);

var CGrid = __webpack_require__(89);
/**
 * These helper functions are modified versions of the amazing work done by rebass library abd chakra-ui
 * https://github.com/rebassjs/rebass/blob/master/packages/layout/src/index.js
 */


var px = function px(n) {
  return typeof n === 'number' ? n + 'px' : n;
};

var widthToColumns = function widthToColumns(width) {
  if (Array.isArray(width)) {
    return width.map(widthToColumns);
  }

  if (width !== null && utils._typeof(width) === 'object' && Object.keys(width).length > 0) {
    var acc = {};

    for (var key in width) {
      acc[key] = "repeat(auto-fit, minmax(" + px(width[key]) + ", 1fr))";
    }

    return acc;
  }

  if (width != null) {
    return "repeat(auto-fit, minmax(" + px(width) + ", 1fr))";
  }

  return null;
};

var countToColumns = function countToColumns(count) {
  if (Array.isArray(count)) {
    return count.map(countToColumns);
  }

  if (count !== null && utils._typeof(count) === 'object' && Object.keys(count).length > 0) {
    var acc = {};

    for (var key in count) {
      acc[key] = "repeat(" + count[key] + ", 1fr)";
    }

    return acc;
  }

  if (count != null) {
    return "repeat(" + count + ", 1fr)";
  }

  return null;
};
/**
 * Hey! Welcome to @chakra-ui/vue Simple Grid
 *
 * SimpleGrid provides a friendly interface to create
 * responsive grid layouts with ease.
 *
 * @see Docs     https://vue.chakra-ui.com/simplegrid
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CSimpleGrid/CSimpleGrid.js
 */

/**
 * CSimpleGrid component
 *
 * The simple grid component provides basic grid functionalities.
 *
 * @extends CGrid
 * @see Docs https://vue.chakra-ui.com/select
 */


var CSimpleGrid = {
  name: 'CSimpleGrid',
  mixins: [utils.createStyledAttrsMixin('CSimpleGrid')],
  props: {
    columns: props_types.SNA,
    spacingX: props_types.SNA,
    spacingY: props_types.SNA,
    spacing: props_types.SNA,
    minChildWidth: props_types.SNA
  },
  computed: {
    templateColumns: function templateColumns() {
      return this.minChildWidth ? widthToColumns(this.minChildWidth) : countToColumns(this.columns);
    }
  },
  render: function render(h) {
    return h(CGrid.CGrid, {
      class: this.className,
      props: {
        gap: this.spacing,
        columnGap: this.spacingX,
        rowGap: this.spacingY,
        templateColumns: this.templateColumns
      },
      attrs: this.computedAttrs
    }, this.$slots.default);
  }
};
exports.default = CSimpleGrid;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(8);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

var CIcon = __webpack_require__(9);

__webpack_require__(6);

__webpack_require__(15);

var CInput = __webpack_require__(61);

var rootOptions = {
  m: true,
  mt: true,
  mr: true,
  mb: true,
  ml: true,
  mx: true,
  my: true,
  margin: true,
  marginTop: true,
  marginBottom: true,
  marginLeft: true,
  marginRight: true,
  marginY: true,
  marginX: true,
  flex: true,
  flexBasis: true,
  width: true,
  minWidth: true,
  maxWidth: true,
  maxW: true,
  minW: true,
  w: true,
  zIndex: true,
  top: true,
  right: true,
  bottom: true,
  left: true,
  position: true,
  pos: true
};
/**
 * Splits all input[type="select"] props from the root node props
 * @param {Object} props Props object
 * @returns {Array<Object>}
 */

var splitProps = function splitProps(props) {
  var rootProps = {};
  var selectProps = {};

  for (var key in props) {
    var _key = utils.camelize(key);

    if (rootOptions[_key]) {
      rootProps[_key] = props[key];
    } else {
      selectProps[_key] = props[key];
    }
  }

  return [rootProps, selectProps];
};
/**
 * Hey! Welcome to @chakra-ui/vue CSelect
 *
 * Select component is a component that allows users
 * pick a value from predefined options.
 *
 * @see Docs     https://vue.chakra-ui.com/select
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CSelect/CSelect.js
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * CSelectIconWrapper component
 *
 * The wrapper component for the select icon
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/select
 */


var CSelectIconWrapper = {
  name: 'SelectIconWrapper',
  functional: true,
  render: function render(h, ref) {
    var data = ref.data;
    var slots = ref.slots;
    var rest$1 = objectWithoutProperties(ref, ["data", "slots"]);
    var rest = rest$1;
    return h(CBox.default, Object.assign({}, rest, {
      attrs: Object.assign({}, data.attrs, {
        position: 'absolute',
        display: 'inline-flex',
        width: '1.5rem',
        height: '100%',
        alignItems: 'center',
        justifyContent: 'center',
        right: '0.5rem',
        top: '50%',
        pointerEvents: 'none',
        zIndex: 2,
        transform: 'translateY(-50%)',
        'data-chakra-component': 'CSelectIconWrapper'
      })
    }), slots().default);
  }
};
/**
 * CSelectInput component
 *
 * The select input component
 *
 * @extends CInput
 * @see Docs https://vue.chakra-ui.com/select
 */

var CSelectInput = {
  name: 'CSelectInput',
  functional: true,
  props: Object.assign({}, CInput.inputProps, {
    placeholder: String,
    value: String
  }),
  render: function render(h, ref) {
    var props = ref.props;
    var data = ref.data;
    var slots = ref.slots;
    var listeners = ref.listeners;
    var rest$1 = objectWithoutProperties(ref, ["props", "data", "slots", "listeners"]);
    var rest = rest$1;
    var nonNativeEvents = {
      change: function change(e) {
        var emitChange = listeners.change;

        if (emitChange) {
          emitChange(e);
        }
      }
    };
    var ref$1 = utils.extractListeners({
      listeners: listeners
    }, nonNativeEvents);
    var native = ref$1.native;
    var nonNative = ref$1.nonNative;
    return h(CInput.CInput, Object.assign({}, rest, {
      props: Object.assign({}, utils.pickProperty(props), {
        as: 'select'
      }),
      on: nonNative,
      nativeOn: native,
      domProps: {
        value: props.value
      },
      attrs: Object.assign({}, {
        appearance: 'none',
        pr: '2rem',
        pb: 'px',
        lineHeight: 'normal'
      }, data.attrs, {
        'data-chakra-component': 'CSelectInput'
      })
    }), [props.placeholder && h('option', {
      attrs: {
        value: ''
      }
    }, props.placeholder), slots().default]);
  }
};
/**
 * CSelect component
 *
 * The select wrapper component
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/select
 */

var CSelect = {
  name: 'CSelect',
  mixins: [utils.createStyledAttrsMixin('CSelect')],
  model: {
    prop: 'value',
    event: 'change'
  },
  props: Object.assign({}, CInput.inputProps, {
    rootProps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    icon: String,
    iconSize: {
      type: Number,
      default: 5
    },
    size: {
      type: String,
      default: 'md'
    },
    isReadOnly: Boolean,
    isDisabled: Boolean,
    placeholder: String,
    value: {
      type: String,
      default: ''
    }
  }),
  computed: {
    _color: function _color() {
      return this.colorMode === 'dark' ? 'whiteAlpha.800' : 'inherit';
    },
    _opacity: function _opacity() {
      return this.isReadOnly || this.isDisabled ? 0.5 : null;
    },
    _value: function _value() {
      return this.value;
    },
    allSplitProps: function allSplitProps() {
      return splitProps(this.$data.attrs$);
    },
    componentStyles: function componentStyles() {
      var ref = this.allSplitProps;
      var root = ref[0];
      return Object.assign({}, root, this.rootProps, {
        position: 'relative',
        width: '100%'
      });
    },
    filteredComputedAttrs: function filteredComputedAttrs() {
      // filter ID from attributes to not insert it on both the wrapper
      // and the select itself. See https://github.com/chakra-ui/chakra-ui-vue/issues/484
      var removeIdFromAttrs = Object.entries(this.computedAttrs).filter(function (ref) {
        var key = ref[0];
        var _attr = ref[1];
        return key !== 'id';
      });
      return Object.fromEntries(removeIdFromAttrs);
    }
  },
  render: function render(h) {
    var this$1 = this;
    var ref = this.$props;
    var icon = ref.icon;
    var iconSize = ref.iconSize;
    var ref$1 = this.allSplitProps;
    var select = ref$1[1];
    return h('div', {
      class: [this.className],
      attrs: Object.assign({}, this.filteredComputedAttrs, {
        'data-chakra-component': 'CSelect'
      })
    }, [h(CSelectInput, {
      props: Object.assign({}, {
        placeholder: this.placeholder
      }, utils.pickProperty(this.$props)),
      attrs: Object.assign({}, {
        color: this._color
      }, select, {
        value: this._value
      }),
      on: {
        change: function change(e) {
          this$1.$emit('change', e.target.value);
        }
      }
    }, this.$slots.default), h(CSelectIconWrapper, {
      attrs: {
        opacity: this._opacity,
        color: select.color || this._color
      }
    }, [h(CIcon.CIcon, {
      props: {
        name: icon || 'chevron-down',
        size: iconSize
      },
      attrs: {
        focusable: false,
        'aria-hidden': true
      }
    })])]);
  }
};
exports.default = CSelect;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var centeredProps = {
  position: 'absolute',
  top: '50%',
  transform: 'translateY(-50%)'
};

var thumbStyle = function thumbStyle(ref) {
  var thumbSize = ref.thumbSize;
  var trackPercent = ref.trackPercent;
  var theme = ref.theme;
  return Object.assign({}, centeredProps, {
    zIndex: 1,
    width: thumbSize,
    height: thumbSize,
    rounded: 'full',
    bg: '#fff',
    shadow: 'sm',
    left: "calc(" + trackPercent + "% - " + thumbSize + " / 2)",
    border: '1px',
    borderColor: 'transparent',
    // TODO: Find another more performant way to implement the slider transitions
    // We could use the CSS "will-change: width;" property. So for now, abrupt transitions :D
    // transition: 'width 0.3s cubic-bezier(0.25, 0.8, 0.5, 1)'
    _focus: {
      shadow: 'outline'
    },
    _disabled: {
      backgroundColor: 'gray.300'
    },
    _active: {
      transform: 'translateY(-50%) scale(1.15)'
    }
  });
};

var filledTrackStyle = function filledTrackStyle(ref) {
  var trackHeight = ref.trackHeight;
  var trackPercent = ref.trackPercent;
  var color = ref.color;
  var colorMode = ref.colorMode;
  return Object.assign({}, centeredProps, {
    height: trackHeight,
    bg: colorMode === 'light' ? color + ".500" : color + ".200",
    width: trackPercent + "%",
    rounded: 'sm'
  });
};

var themedTrackStyle = {
  light: {
    bg: 'gray.200',
    _disabled: {
      bg: 'gray.300'
    }
  },
  dark: {
    bg: 'whiteAlpha.200',
    _disabled: {
      bg: 'whiteAlpha.300'
    }
  }
};

var trackStyle = function trackStyle(ref) {
  var trackHeight = ref.trackHeight;
  var theme = ref.theme;
  var colorMode = ref.colorMode;
  return Object.assign({}, {
    height: trackHeight,
    borderRadius: 'sm',
    width: '100%'
  }, centeredProps, themedTrackStyle[colorMode]);
};

var rootStyle = {
  width: 'full',
  display: 'inline-block',
  position: 'relative',
  cursor: 'pointer',
  _disabled: {
    opacity: 0.6,
    cursor: 'default',
    pointerEvents: 'none'
  }
};
var sizes = {
  lg: {
    thumb: '16px',
    trackHeight: '4px'
  },
  md: {
    thumb: '14px',
    trackHeight: '4px'
  },
  sm: {
    thumb: '10px',
    trackHeight: '2px'
  }
};
/**
 * Generates slider style props
 * @param {{theme: Object, colorMode: String, trackPercent: String, size: String, color: String}} props Style props
 * @returns {Object} Slider styles
 */

var useSliderStyle = function useSliderStyle(props) {
  var theme = props.theme;
  var colorMode = props.colorMode;
  var trackPercent = props.trackPercent;
  var size = props.size;
  var color = props.color;
  var ref = sizes[size];
  var trackHeight = ref.trackHeight;
  var thumbSize = ref.thumb;
  var _props = {
    trackHeight: trackHeight,
    thumbSize: thumbSize,
    theme: theme,
    trackPercent: trackPercent,
    color: color,
    colorMode: colorMode
  };
  return {
    rootStyle: rootStyle,
    trackStyle: trackStyle(_props),
    filledTrackStyle: filledTrackStyle(_props),
    thumbStyle: thumbStyle(_props)
  };
};
/**
 * Conforms a value to provided precision
 * @param {Value} value Value
 * @param {Number} step step
 * @returns {Number} Precise value
 */


function makeValuePrecise(value, step) {
  var stepDecimalPart = step.toString().split('.')[1];
  var stepPrecision = stepDecimalPart ? stepDecimalPart.length : 0;
  return Number(value.toFixed(stepPrecision));
}
/**
 * Rounds off a value to the nearest step
 * @param {Number} value Value
 * @param {Number} step step
 * @returns {Number} rounded value
 */


function roundValueToStep(value, step) {
  return makeValuePrecise(Math.round(value / step) * step, step);
}
/**
 * Clamps provided value within domain
 * @param {Number} val Value
 * @param {Number} min Minimum value
 * @param {Number} max Maximum value
 * @returns {Number} clamped value
 */


function clampValue(val, min, max) {
  if (val > max) {
    return max;
  }

  if (val < min) {
    return min;
  }

  return val;
}
/**
 * Hey! Welcome to @chakra-ui/vue CSlider
 *
 * The Slider is used to allow users to make
 * selections from a range of values.
 *
 * @see Docs     https://vue.chakra-ui.com/slider
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CSlider/CSlider.js
 */

/**
 * CSlider component
 *
 * The Slider wrapper component
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/slider
 */


var CSlider = {
  name: 'CSlider',
  mixins: [utils.createStyledAttrsMixin('CSlider')],
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    value: Number,
    defaultValue: Number,
    isDisabled: Boolean,
    max: {
      type: Number,
      default: 100
    },
    min: {
      type: Number,
      default: 0
    },
    step: {
      type: Number,
      default: 1
    },
    ariaLabel: String,
    ariaLabelledBy: String,
    ariaValueText: String,
    orientation: {
      type: String,
      default: 'horizontal'
    },
    getAriaValueText: Function,
    size: {
      type: String,
      default: 'md'
    },
    color: {
      type: String,
      default: 'blue'
    },
    name: String,
    id: String
  },
  provide: function provide() {
    var this$1 = this;
    return {
      $SliderContext: function $SliderContext() {
        return this$1.SliderContext;
      }
    };
  },
  data: function data() {
    return {
      innerValue: this.defaultValue || 0,
      trackNode: undefined,
      thumbNode: undefined
    };
  },
  computed: {
    isControlled: function isControlled() {
      return utils.isDef(this.value);
    },
    _value: function _value() {
      return this.isControlled ? this.value : this.innerValue;
    },
    actualValue: function actualValue() {
      return clampValue(this._value, this.min, this.max);
    },
    trackPercentage: function trackPercentage() {
      return utils.valueToPercent(this.actualValue, this.min, this.max);
    },
    theme: function theme() {
      return this.$chakraTheme();
    },
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    },
    _id: function _id() {
      return this.id || utils.useId();
    },
    trackId: function trackId() {
      return "slider-track-" + this._id;
    },
    thumbId: function thumbId() {
      return "slider-thumb-" + this._id;
    },
    sliderStyles: function sliderStyles() {
      var ref = useSliderStyle({
        color: this.color,
        colorMode: this.colorMode,
        size: this.size,
        theme: this.theme,
        trackPercent: this.trackPercentage
      });
      var rootStyle = ref.rootStyle;
      return rootStyle;
    },
    componentStyles: function componentStyles() {
      return Object.assign({}, this.sliderStyles, {
        py: 3
      });
    },
    valueText: function valueText() {
      return this.getAriaValueText ? this.getAriaValueText(this.actualValue) : this.ariaValueText;
    },
    SliderContext: function SliderContext() {
      var this$1 = this;
      return {
        trackNode: this.trackNode,
        thumbNode: this.thumbNode,
        onThumbKeyDown: this.handleThumbKeyDown,
        onFocus: function onFocus(e) {
          return this$1.$emit('focus', e);
        },
        trackPercent: this.trackPercentage,
        ariaLabelledBy: this.ariaLabelledBy,
        orientation: this.orientation,
        isDisabled: this.isDisabled,
        size: this.size,
        color: this.color,
        min: this.min,
        max: this.max,
        valueText: this.valueText,
        value: this.actualValue,
        trackId: this.trackId,
        thumbId: this.thumbId
      };
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$nextTick(function () {
      this$1.trackNode = utils.getElById(this$1.trackId);
      this$1.thumbNode = utils.getElById(this$1.thumbId);
    });
  },
  methods: {
    /**
     * Parses new value returned from slider change event
     * @param {Event} event
     */
    getNewValue: function getNewValue(event) {
      if (this.trackNode) {
        var ref = this.trackNode.getBoundingClientRect();
        var left = ref.left;
        var width = ref.width;
        var ref$1 = event.touches ? event.touches[0] : event;
        var clientX = ref$1.clientX;
        var diffX = clientX - left;
        var percent = diffX / width;
        var newValue = utils.percentToValue(percent, this.min, this.max);

        if (this.step) {
          newValue = roundValueToStep(newValue, this.step);
        }

        newValue = clampValue(newValue, this.min, this.max);
        return newValue;
      }
    },

    /**
     * Updates current inner value
     * @param {Number} newValue New Value
     */
    updateValue: function updateValue(newValue) {
      if (!this.isControlled) {
        this.innerValue = newValue;
      }

      this.$emit('change', newValue);
    },

    /**
     * Handles SliderThumb keydown event
     * @param {Event} event
     */
    handleThumbKeyDown: function handleThumbKeyDown(event) {
      var flag = false;
      var newValue;
      var tenSteps = (this.max - this.min) / 10;

      switch (event.key) {
        case 'ArrowLeft':
        case 'ArrowDown':
          newValue = this.actualValue - this.step;
          flag = true;
          break;

        case 'ArrowRight':
        case 'ArrowUp':
          newValue = this.actualValue + this.step;
          flag = true;
          break;

        case 'PageDown':
          newValue = this.actualValue - tenSteps;
          flag = true;
          break;

        case 'PageUp':
          newValue = this.actualValue + tenSteps;
          flag = true;
          break;

        case 'Home':
          newValue = this.min;
          flag = true;
          break;

        case 'End':
          newValue = this.max;
          flag = true;
          break;

        default:
          return;
      }

      if (flag) {
        event.preventDefault();
        event.stopPropagation();
      }

      if (this.step) {
        newValue = roundValueToStep(newValue, this.step);
      }

      newValue = clampValue(newValue, this.min, this.max);
      this.updateValue(newValue);
      this.$emit('keydown', event);
    },

    /**
     * Handle sliderthumb mouseup event
     */
    handleMouseUp: function handleMouseUp() {
      document.body.removeEventListener('mousemove', this.handleMouseMove);
      document.body.removeEventListener('touchmove', this.handleMouseMove);
      document.body.removeEventListener('mouseup', this.handleMouseUp);
      document.body.removeEventListener('touchend', this.handleMouseUp);
    },

    /**
     * Handles mousedown event for slider
     * @param {Event} event
     */
    handleMouseDown: function handleMouseDown(event) {
      if (this.isDisabled) {
        return;
      }

      this.$emit('mousedown', event);
      event.preventDefault();
      var newValue = this.getNewValue(event);

      if (newValue !== this.actualValue) {
        this.updateValue(newValue);
      }

      document.body.addEventListener('mousemove', this.handleMouseMove);
      document.body.addEventListener('touchmove', this.handleMouseMove);
      document.body.addEventListener('mouseup', this.handleMouseUp);
      document.body.addEventListener('touchend', this.handleMouseUp);
      this.thumbNode && this.thumbNode.focus();
    },

    /**
     * Handles slider thumb mousemove event
     * @param {Event} event
     */
    handleMouseMove: function handleMouseMove(event) {
      var newValue = this.getNewValue(event);
      this.updateValue(newValue);
    }
  },
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default || [];
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, {
        role: 'presentation',
        'aria-disabled': this.isDisabled
      }, this.computedAttrs),
      style: {
        touchAction: 'none'
      },
      on: Object.assign({}, this.computedListeners, {
        mousedown: this.handleMouseDown,
        touchstart: this.handleMouseDown,
        mouseleave: this.handleMouseUp,
        touchend: this.handleMouseUp,
        blur: function blur(event) {
          this$1.handleMouseUp(event);
          this$1.$emit('blur', event);
        }
      })
    }, children.concat([h('input', {
      attrs: {
        type: 'hidden',
        value: this.actualValue,
        name: this.name,
        id: this._id
      }
    })]));
  }
};
/**
 * CSliderTrack component
 *
 * The track for the slider component
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/slider
 */

var CSliderTrack = {
  name: 'CSliderTrack',
  mixins: [utils.createStyledAttrsMixin('CSliderTrack')],
  inject: ['$SliderContext'],
  computed: {
    context: function context() {
      return this.$SliderContext();
    },
    componentStyles: function componentStyles() {
      var ref = useSliderStyle(Object.assign({}, this.context, {
        theme: this.theme,
        colorMode: this.colorMode
      }));
      var trackStyle = ref.trackStyle;
      return trackStyle;
    }
  },
  render: function render(h) {
    var ref = this.context;
    var isDisabled = ref.isDisabled;
    var trackId = ref.trackId;
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, this.computedAttrs, {
        id: trackId,
        'data-slider-track': '',
        'aria-disabled': isDisabled
      }),
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CSliderFilledTrack component
 *
 * The track filler for the slider component
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/slider
 */

var CSliderFilledTrack = {
  name: 'CSliderFilledTrack',
  mixins: [utils.createStyledAttrsMixin('CSliderFilledTrack')],
  inject: ['$SliderContext'],
  computed: {
    context: function context() {
      return this.$SliderContext();
    },
    componentStyles: function componentStyles() {
      var ref = useSliderStyle(Object.assign({}, this.context, {
        theme: this.theme,
        colorMode: this.colorMode
      }));
      var filledTrackStyle = ref.filledTrackStyle;
      return filledTrackStyle;
    }
  },
  render: function render(h) {
    var ref = this.context;
    var isDisabled = ref.isDisabled;
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, this.computedAttrs, {
        'aria-disabled': isDisabled,
        'data-slider-filled-track': ''
      }),
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CSliderThumb component
 *
 * The thumb handler for the slider component
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/slider
 */

var CSliderThumb = {
  name: 'CSliderThumb',
  mixins: [utils.createStyledAttrsMixin('CSliderThumb')],
  inject: ['$SliderContext'],
  computed: {
    context: function context() {
      return this.$SliderContext();
    },
    componentStyles: function componentStyles() {
      var ref = this.context;
      var orientation = ref.orientation;
      var trackPercent = ref.trackPercent;
      var size = ref.size;
      var color = ref.color;
      var ref$1 = useSliderStyle({
        trackPercent: trackPercent,
        orientation: orientation,
        color: color,
        size: size,
        theme: this.theme,
        colorMode: this.colorMode
      });
      var thumbStyle = ref$1.thumbStyle;
      return Object.assign({}, {
        d: 'flex',
        alignItems: 'center',
        outline: 'none',
        justifyContent: 'center'
      }, thumbStyle);
    }
  },
  render: function render(h) {
    var ref = this.context;
    var thumbId = ref.thumbId;
    var isDisabled = ref.isDisabled;
    var onFocus = ref.onFocus;
    var onKeyDown = ref.onThumbKeyDown;
    var min = ref.min;
    var max = ref.max;
    var valueText = ref.valueText;
    var orientation = ref.orientation;
    var value = ref.value;
    var ariaLabelledBy = ref.ariaLabelledBy;
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, this.computedAttrs, {
        id: thumbId,
        role: 'slider',
        tabindex: isDisabled ? undefined : 0,
        'aria-disabled': isDisabled,
        'aria-valuemin': min,
        'aria-valuetext': valueText,
        'aria-orientation': orientation,
        'aria-valuenow': value,
        'aria-valuemax': max,
        'aria-labelledby': ariaLabelledBy
      }),
      on: Object.assign({}, this.computedListeners, {
        keydown: onKeyDown,
        focus: onFocus
      })
    }, this.$slots.default);
  }
};
exports.CSliderFilledTrack = CSliderFilledTrack;
exports.CSliderThumb = CSliderThumb;
exports.CSliderTrack = CSliderTrack;
exports.default = CSlider;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

var props_types = __webpack_require__(6);

var CFlex = __webpack_require__(21);
/**
 * Hey! Welcome to @chakra-ui/vue Stack
 *
 * Stack is a layout utility component that makes
 * it easy to stack elements together and apply a space between them.
 *
 * @see Docs     https://vue.chakra-ui.com/stack
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CStack/CStack.js
 */

/**
 * CStack component
 *
 * Flex container to stck it's children
 *
 * @extends CFlex
 * @see Docs https://vue.chakra-ui.com/stack
 */


var CStack = {
  name: 'CStack',
  mixins: [utils.createStyledAttrsMixin('CStack')],
  props: {
    direction: [String, Array],
    isInline: {
      type: Boolean,
      default: false
    },
    isReversed: {
      type: Boolean,
      default: false
    },
    align: props_types.StringArray,
    justify: props_types.StringArray,
    spacing: {
      type: props_types.SNA,
      default: 2
    },
    shouldWrapChildren: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    _isInline: function _isInline() {
      return this.isInline || this.direction && this.direction.startsWith('row');
    },
    _isReversed: function _isReversed() {
      return this.isReversed || this.direction && this.direction.endsWith('reverse');
    },
    _direction: function _direction() {
      var _direction;

      if (this._isInline) {
        _direction = 'row';
      }

      if (this._isReversed) {
        _direction = this.isInline ? 'row-reverse' : 'column-reverse';
      }

      if (this.direction) {
        _direction = this.direction;
      }

      if (!this._isInline && !this._isReversed && !this.direction) {
        _direction = 'column';
      }

      return _direction;
    }
  },
  render: function render(h) {
    var this$1 = this;
    var defaultSlot = this.$slots.default || [];
    var children = defaultSlot.filter(function (e) {
      return e.tag;
    });
    var stackables = children.map(function (node, index) {
      var obj, obj$1;
      var isLastChild = children.length === index + 1;
      var spacingProps = this$1._isInline ? (obj = {}, obj[this$1._isReversed ? 'ml' : 'mr'] = isLastChild ? null : this$1.spacing, obj) : (obj$1 = {}, obj$1[this$1._isReversed ? 'mt' : 'mb'] = isLastChild ? null : this$1.spacing, obj$1);
      var clone = utils.cloneVNode(node, h);

      if (!clone.componentOptions) {
        clone = h(CBox.default, [clone]);
      }

      var ref = clone.componentOptions;
      var propsData = ref.propsData;
      var ref$1 = clone.data;
      var attrs = ref$1.attrs; // If children nodes should wrap,
      // we wrap them inside block with
      // display set to inline block.

      if (this$1.shouldWrapChildren) {
        return h(CBox.default, {
          props: {
            as: this$1.as,
            to: this$1.to
          },
          attrs: Object.assign({}, {
            d: 'inline-block'
          }, spacingProps)
        }, [clone]);
      } // Otherwise we simply set spacing props
      // to current node.


      clone.componentOptions.propsData = Object.assign({}, propsData);
      clone.data.attrs = Object.assign({}, attrs, spacingProps);
      return clone;
    });
    return h(CFlex.CFlex, {
      class: this.className,
      props: {
        as: this.as,
        align: this.align,
        justify: this.justify,
        direction: this._direction
      },
      attrs: this.computedAttrs,
      on: this.computedListeners
    }, stackables);
  }
};
exports.default = CStack;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(8);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

var CIcon = __webpack_require__(9);

__webpack_require__(6);

var CFlex = __webpack_require__(21);

__webpack_require__(22);

var CText = __webpack_require__(26);
/**
 * Hey! Welcome to @chakra-ui/vue Stat
 *
 * The Stat component is used to display a single statistic.
 *
 * @see Docs     https://vue.chakra-ui.com/stat
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CStat/CStat.js
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * Stat Arrow options
 */


var arrowOptions = {
  increase: {
    name: 'triangle-up',
    color: 'green.400'
  },
  decrease: {
    name: 'triangle-down',
    color: 'red.400'
  }
};
/**
 * CStat component
 *
 * Stat wrapper component for it's children
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/stat
 */

var CStat = {
  name: 'CStat',
  functional: true,
  render: function render(h, ref) {
    var props = ref.props;
    var slots = ref.slots;
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["props", "slots", "data"]);
    var rest = rest$1;
    var children = utils.cleanChildren(slots().default);
    return h(CBox.default, Object.assign({}, rest, {
      props: {
        as: props.as
      },
      attrs: Object.assign({}, {
        flex: 1,
        pr: 4,
        position: 'relative'
      }, data.attrs || {}, {
        'data-chakra-component': 'CStat'
      })
    }), children);
  }
};
/**
 * CStatGroup component
 *
 * group component for stat
 *
 * @extends CFlex
 * @see Docs https://vue.chakra-ui.com/stat
 */

var CStatGroup = {
  name: 'CStatGroup',
  functional: true,
  props: CFlex.CFlex.props,
  render: function render(h, ref) {
    var props = ref.props;
    var slots = ref.slots;
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["props", "slots", "data"]);
    var rest = rest$1;
    var children = utils.cleanChildren(slots().default);
    return h(CFlex.CFlex, Object.assign({}, rest, {
      props: Object.assign({}, {
        flexWrap: 'wrap',
        justifyContent: 'space-around',
        alignItems: 'flex-start'
      }, utils.pickProperty(props)),
      attrs: Object.assign({}, data.attrs || {}, {
        'data-chakra-component': 'CStatGroup'
      })
    }), children);
  }
};
/**
 * CStatArrow component
 *
 * Arrow component for stat
 *
 * @extends CIcon
 * @see Docs https://vue.chakra-ui.com/stat
 */

var CStatArrow = {
  name: 'CStatArrow',
  functional: true,
  props: Object.assign({}, CIcon.CIcon.props, {
    type: {
      type: String,
      default: 'increase'
    }
  }),
  render: function render(h, ref) {
    var props = ref.props;
    var slots = ref.slots;
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["props", "slots", "data"]);
    var rest = rest$1;
    return h(CIcon.CIcon, Object.assign({}, rest, {
      props: Object.assign({}, {
        size: '14px'
      }, arrowOptions[props.type], utils.pickProperty(props)),
      attrs: Object.assign({}, {
        mr: 1,
        verticalAlign: 'middle'
      }, data.attrs || {}, {
        color: arrowOptions[props.type].color,
        'data-chakra-component': 'CStatArrow'
      })
    }));
  }
};
/**
 * CStatNumber component
 *
 * number component for stat
 *
 * @extends CIcon
 * @see Docs https://vue.chakra-ui.com/stat
 */

var CStatNumber = {
  name: 'CStatNumber',
  functional: true,
  props: CText.default.props,
  render: function render(h, ref) {
    var props = ref.props;
    var slots = ref.slots;
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["props", "slots", "data"]);
    var rest = rest$1;
    return h(CText.default, Object.assign({}, rest, {
      props: utils.pickProperty(props),
      attrs: Object.assign({}, {
        fontSize: '2xl',
        verticalAlign: 'baseline',
        fontWeight: 'semibold'
      }, data.attrs || {}, {
        'data-chakra-component': 'CStatNumber'
      })
    }), slots().default);
  }
};
/**
 * CStatHelperText component
 *
 * text component for stat
 *
 * @extends CText
 * @see Docs https://vue.chakra-ui.com/stat
 */

var CStatHelperText = {
  name: 'CStatHelperText',
  functional: true,
  props: CText.default.props,
  render: function render(h, ref) {
    var props = ref.props;
    var slots = ref.slots;
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["props", "slots", "data"]);
    var rest = rest$1;
    return h(CText.default, Object.assign({}, rest, {
      props: utils.pickProperty(props),
      attrs: Object.assign({}, {
        fontSize: 'sm',
        opacity: 0.8,
        mb: 2
      }, data.attrs || {}, {
        'data-chakra-component': 'CStatHelperText'
      })
    }), slots().default);
  }
};
/**
 * CStatLabel component
 *
 * label text component for stat
 *
 * @extends CText
 * @see Docs https://vue.chakra-ui.com/stat
 */

var CStatLabel = {
  name: 'CStatLabel',
  functional: true,
  props: CText.default.props,
  render: function render(h, ref) {
    var props = ref.props;
    var slots = ref.slots;
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["props", "slots", "data"]);
    var rest = rest$1;
    return h(CText.default, Object.assign({}, rest, {
      props: utils.pickProperty(props),
      attrs: Object.assign({}, {
        fontWeight: 'medium',
        fontSize: 'sm'
      }, data.attrs || {}, {
        'data-chakra-component': 'CStatLabel'
      })
    }), slots().default);
  }
};
exports.CStat = CStat;
exports.CStatArrow = CStatArrow;
exports.CStatGroup = CStatGroup;
exports.CStatHelperText = CStatHelperText;
exports.CStatLabel = CStatLabel;
exports.CStatNumber = CStatNumber;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

var CVisuallyHidden = __webpack_require__(18);

var CControlBox = __webpack_require__(58);
/**
 * Hey! Welcome to @chakra-ui/vue CSwitch
 *
 * The Switch component is used as an alternative for the Checkbox
 * component, switch between enabled or disabled states.
 *
 * @see Docs     https://vue.chakra-ui.com/stat
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CSwitch/CSwitch.js
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}

var switchSizes = {
  sm: {
    width: '1.375rem',
    height: '0.75rem'
  },
  md: {
    width: '1.875rem',
    height: '1rem'
  },
  lg: {
    width: '2.875rem',
    height: '1.5rem'
  }
};
/** Emits events for functional components */

var emitFunctionalEvent = function emitFunctionalEvent(fn) {
  var args = [],
      len = arguments.length - 1;

  while (len-- > 0) {
    args[len] = arguments[len + 1];
  }

  if (fn && typeof fn === 'function') {
    fn.apply(void 0, args);
  } else if (Array.isArray(fn)) {
    fn.forEach(function (handler) {
      return typeof handler === 'function' && handler.apply(void 0, args);
    });
  }
};
/**
 * CSwitch component
 *
 * the switch component that serves as an alternative for checkbox.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/stat
 */


var CSwitch = {
  name: 'CSwitch',
  functional: true,
  model: {
    prop: 'isChecked',
    event: 'change'
  },
  inject: ['$chakraColorMode'],
  props: {
    id: String,
    name: String,
    value: Boolean,
    ariaLabel: String,
    ariaLabelledBy: String,
    color: {
      type: String,
      default: 'blue'
    },
    defaultIsChecked: Boolean,
    isChecked: Boolean,
    size: {
      type: String,
      default: 'md'
    },
    isDisabled: Boolean,
    isInvalid: Boolean
  },
  render: function render(h, ref) {
    var props = ref.props;
    var data = ref.data;
    var listeners = ref.listeners;
    var injections = ref.injections;
    var rest$1 = objectWithoutProperties(ref, ["props", "data", "listeners", "injections"]);
    var rest = rest$1;
    var colorMode = injections.$chakraColorMode();
    var width = switchSizes[props.size] && switchSizes[props.size].width;
    var height = switchSizes[props.size] && switchSizes[props.size].height;
    var styleProps = {
      rounded: 'full',
      justifyContent: 'flex-start',
      width: width,
      height: height,
      bg: colorMode === 'dark' ? 'whiteAlpha.400' : 'gray.300',
      boxSizing: 'content-box',
      p: '2px',
      _checked: {
        bg: props.color + ".500"
      },
      _child: {
        transform: 'translateX(0)'
      },
      _checkedAndChild: {
        transform: "translateX(calc(" + width + " - " + height + "))"
      },
      _focus: {
        boxShadow: 'outline'
      },
      _hover: {
        cursor: 'pointer'
      },
      _checkedAndHover: {
        cursor: 'pointer'
      },
      _disabled: {
        opacity: 0.4,
        cursor: 'not-allowed'
      }
    };
    var eventListeners = Object.assign({}, listeners, {
      change: function change(e) {
        var newValue = !props.isChecked;
        emitFunctionalEvent(listeners.change, newValue, e);
      }
    });
    return h(CBox.default, Object.assign({}, rest, {
      props: Object.assign({}, utils.pickProperty(props), {
        as: 'label'
      }),
      attrs: Object.assign({}, {
        position: 'relative',
        display: 'inline-block',
        verticalAlign: 'middle'
      }, data.attrs, {
        'data-chakra-component': 'CSwitch'
      })
    }), [h(CVisuallyHidden.default, {
      props: {
        as: 'input'
      },
      attrs: {
        type: 'checkbox',
        'aria-label': props.ariaLabel,
        'aria-labelledby': props.ariaLabelledBy,
        id: props.id,
        name: props.name,
        value: props.value,
        'aria-invalid': props.isInvalid,
        defaultChecked: props.defaultIsChecked,
        checked: props.isChecked,
        disabled: props.isDisabled
      },
      on: eventListeners
    }), h(CControlBox.default, {
      attrs: styleProps
    }, [h(CBox.default, {
      attrs: {
        bg: 'white',
        transition: 'transform 250ms',
        rounded: 'full',
        h: height,
        w: height
      }
    })])]);
  }
};
exports.default = CSwitch;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var baseProps = {
  display: 'flex',
  cursor: 'pointer',
  alignItems: 'center',
  justifyContent: 'center',
  transition: 'all 0.2s',
  _focus: {
    zIndex: '1',
    boxShadow: 'outline'
  }
};
var disabledProps = {
  _disabled: {
    opacity: 0.4,
    cursor: 'not-allowed'
  }
};

var lineStyle = function lineStyle(ref) {
  var color = ref.color;
  var colorMode = ref.colorMode;
  var _color = {
    light: color + ".600",
    dark: color + ".300"
  };
  return {
    tabList: {
      borderBottom: '2px',
      borderColor: 'inherit'
    },
    tab: {
      borderBottom: '2px',
      borderColor: 'transparent',
      mb: '-2px',
      _selected: {
        color: _color[colorMode],
        borderColor: 'currentColor'
      },
      _active: {
        bg: 'gray.200'
      },
      _disabled: {
        opacity: 0.4,
        cursor: 'not-allowed'
      }
    }
  };
};

var enclosedStyle = function enclosedStyle(ref) {
  var color = ref.color;
  var colorMode = ref.colorMode;
  var theme = ref.theme;
  var _selectedColor = {
    light: color + ".600",
    dark: color + ".300"
  };
  var _selectedBg = {
    light: '#fff',
    dark: theme.colors.gray[800]
  };
  return {
    tab: {
      roundedTop: 'md',
      border: '1px',
      borderColor: 'transparent',
      mb: '-1px',
      _selected: {
        color: _selectedColor[colorMode],
        borderColor: 'inherit',
        borderBottomColor: _selectedBg[colorMode]
      }
    },
    tabList: {
      mb: '-1px',
      borderBottom: '1px',
      borderColor: 'inherit'
    }
  };
};

var enclosedColoredStyle = function enclosedColoredStyle(ref) {
  var color = ref.color;
  var colorMode = ref.colorMode;
  var bg = {
    light: 'gray.50',
    dark: 'whiteAlpha.50'
  };
  var _selectedColor = {
    light: color + ".600",
    dark: color + ".300"
  };
  var _selectedBg = {
    light: '#fff',
    dark: 'gray.800'
  };
  return {
    tab: {
      border: '1px',
      borderColor: 'inherit',
      bg: bg[colorMode],
      mb: '-1px',
      _notLast: {
        mr: '-1px'
      },
      _selected: {
        bg: _selectedBg[colorMode],
        color: _selectedColor[colorMode],
        borderColor: 'inherit',
        borderTopColor: 'currentColor',
        borderBottomColor: 'transparent'
      }
    },
    tabList: {
      mb: '-1px',
      borderBottom: '1px',
      borderColor: 'inherit'
    }
  };
};

var softRoundedStyle = function softRoundedStyle(ref) {
  var color = ref.color;
  return {
    tab: {
      rounded: 'full',
      fontWeight: 'semibold',
      color: 'gray.600',
      _selected: {
        color: color + ".700",
        bg: color + ".100"
      }
    },
    tabList: {}
  };
};

var solidRoundedStyle = function solidRoundedStyle(ref) {
  var color = ref.color;
  var colorMode = ref.colorMode;
  var _color = {
    light: 'gray.600',
    dark: 'inherit'
  };
  var _selectedBg = {
    light: color + ".600",
    dark: color + ".300"
  };
  var _selectedColor = {
    light: '#fff',
    dark: 'gray.800'
  };
  return {
    tab: {
      rounded: 'full',
      fontWeight: 'semibold',
      color: _color[colorMode],
      _selected: {
        color: _selectedColor[colorMode],
        bg: _selectedBg[colorMode]
      }
    },
    tabList: {}
  };
};

var variantStyle = function variantStyle(props) {
  switch (props.variant) {
    case 'line':
      return lineStyle(props);

    case 'enclosed':
      return enclosedStyle(props);

    case 'enclosed-colored':
      return enclosedColoredStyle(props);

    case 'soft-rounded':
      return softRoundedStyle(props);

    case 'solid-rounded':
      return solidRoundedStyle(props);

    case 'unstyled':
      return {};
  }
};

var orientationStyle = function orientationStyle(ref) {
  var align = ref.align;
  var orientation = ref.orientation;
  var alignments = {
    end: 'flex-end',
    center: 'center',
    start: 'flex-start'
  };
  var tabListStyle;
  var tabStyle;

  if (orientation === 'horizontal') {
    tabListStyle = {
      alignItems: 'center',
      justifyContent: alignments[align],
      maxWidth: 'full'
    };
    tabStyle = {
      height: '100%'
    };
  }

  if (orientation === 'vertical') {
    tabListStyle = {
      flexDirection: 'column'
    };
    tabStyle = {
      width: '100%'
    };
  }

  return {
    tabList: tabListStyle,
    tab: tabStyle
  };
};

var tabSizes = {
  sm: {
    padding: '0.25rem 1rem',
    fontSize: '0.85rem'
  },
  md: {
    fontSize: '1rem',
    padding: '0.5rem 1rem'
  },
  lg: {
    fontSize: '1.15rem',
    padding: '0.75rem 1rem'
  }
};
/**
 * Creates tab styles
 * @param {{ theme: Object, colorMode: String, variant: String, color: String, size: String, isFitted: Boolean, orientation: String }} props Variant props
 */

var useTabStyle = function useTabStyle(ref) {
  var theme = ref.theme;
  var colorMode = ref.colorMode;
  var variant = ref.variant;
  var color = ref.color;
  var size = ref.size;
  var isFitted = ref.isFitted;
  var orientation = ref.orientation;

  var _variantStyle = variantStyle({
    variant: variant,
    color: color,
    theme: theme,
    colorMode: colorMode
  });

  var _orientationStyle = orientationStyle({
    orientation: orientation
  });

  return Object.assign({}, baseProps, disabledProps, tabSizes[size], _variantStyle && _variantStyle.tab, _orientationStyle && _orientationStyle.tab, isFitted && {
    flex: 1
  });
};
/**
 * Creates TabList styles
 * @param {{ theme: Object, variant: String, align: String, orientation: String }} props Variant props
 */


var useTabListStyle = function useTabListStyle(ref) {
  var theme = ref.theme;
  var variant = ref.variant;
  var align = ref.align;
  var orientation = ref.orientation;

  var _variantStyle = variantStyle({
    variant: variant,
    theme: theme
  });

  var _orientationStyle = orientationStyle({
    align: align,
    orientation: orientation
  });

  return Object.assign({}, _variantStyle && _variantStyle.tabList, _orientationStyle && _orientationStyle.tabList);
};
/**
 * Hey! Welcome to @chakra-ui/vue Tabs
 *
 * The CTab component consists of clickable tabs, that are aligned side by side.
 *
 * @see Docs     https://vue.chakra-ui.com/tabs
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CTabs/CTabs.js
 */

/**
 * CTabs component
 *
 * the switch component that serves as an alternative for checkbox.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/tabs
 */


var CTabs = {
  name: 'CTabs',
  mixins: [utils.createStyledAttrsMixin('CTabs')],
  props: {
    index: Number,
    defaultIndex: Number,
    isManual: Boolean,
    variant: {
      type: String,
      default: 'line'
    },
    variantColor: {
      type: String,
      default: 'blue'
    },
    align: {
      type: String,
      default: 'start'
    },
    size: {
      type: String,
      default: 'md'
    },
    orientation: {
      type: String,
      default: 'horizontal'
    },
    isFitted: Boolean
  },
  provide: function provide() {
    var this$1 = this;
    return {
      $TabContext: function $TabContext() {
        return this$1.TabContext;
      }
    };
  },
  data: function data() {
    return {
      selectedPanelNode: undefined,
      selectedIndex: this.getInitialIndex(),
      manualIndex: this.index || this.defaultIndex || 0
    };
  },
  computed: {
    TabContext: function TabContext() {
      return {
        id: this.id,
        selectedIndex: this.selectedIndex,
        index: this.actualIdx,
        manualIndex: this.manualIdx,
        onManualTabChange: this.onManualTabChange,
        isManual: this.isManual,
        onChangeTab: this.onChangeTab,
        selectedPanelRef: this.selectedPanelRef,
        onFocusPanel: this.onFocusPanel,
        color: this.variantColor,
        size: this.size,
        align: this.align,
        variant: this.variant,
        isFitted: this.isFitted,
        orientation: this.orientation,
        set: this.set
      };
    },
    isControlled: function isControlled() {
      return utils.isDef(this.index);
    },
    id: function id() {
      return "tabs-" + utils.useId();
    },
    actualIdx: function actualIdx() {
      if (!this.isManual) {
        return this.defaultIndex || 0;
      } else {
        return this.index || this.defaultIndex || 0;
      }
    },
    manualIdx: function manualIdx() {
      return this.isControlled ? this.index : this.manualIndex;
    }
  },
  created: function created() {
    utils.useVariantColorWarning(this.theme, 'CTabs', this.variantColor);
  },
  methods: {
    /**
     * Gets initial active tab index
     */
    getInitialIndex: function getInitialIndex() {
      if (!this.isManual) {
        return this.defaultIndex || 0;
      } else {
        return this.index || this.defaultIndex || 0;
      }
    },

    /**
     * Handles tab chage
     * @param {Number} index Index to vbe set
     */
    onChangeTab: function onChangeTab(index) {
      if (!this.isControlled) {
        this.selectedIndex = index;
      }

      if (this.isControlled && this.isManual) {
        this.selectedIndex = index;
      }

      if (!this.isManual) {
        this.$emit('change', index);
      }
    },

    /**
     * Manual tab change handler
     * @param {Number} index Index of tab to set
     */
    onManualTabChange: function onManualTabChange(index) {
      if (!this.isControlled) {
        this.manualIndex = index;
      }

      if (this.isManual) {
        this.$emit('change', index);
      }
    },

    /**
     * Focuses on active tab
     */
    onFocusPanel: function onFocusPanel() {
      if (this.selectedPanelNode) {
        this.selectedPanelNode.focus();
      }
    },

    /**
     * Sets the value of any component instance property.
     * This function is to be passed down to context so that consumers
     * can mutate context values with out doing it directly.
     * Serves as a temporary fix until Vue 3 comes out
     * @param {String} prop Component instance property
     * @param {Any} value Property value
     */
    set: function set(prop, value) {
      this[prop] = value;
      return this[prop];
    }
  },
  render: function render(h) {
    return h(this.as, {
      class: [this.className],
      attrs: this.computedAttrs,
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CTabList component
 *
 * the list wrapper component for each tab
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/tabs
 */

var CTabList = {
  name: 'CTabList',
  mixins: [utils.createStyledAttrsMixin('CTabList')],
  inject: ['$TabContext'],
  data: function data() {
    return {
      allNodes: {},
      validChildren: [],
      focusableIndexes: []
    };
  },
  computed: {
    context: function context() {
      return this.$TabContext();
    },
    componentStyles: function componentStyles() {
      var ref = this.context;
      var align = ref.align;
      var variant = ref.variant;
      var orientation = ref.orientation;
      return Object.assign({}, {
        display: 'flex'
      }, useTabListStyle({
        theme: this.theme,
        align: align,
        orientation: orientation,
        variant: variant
      }));
    },
    enabledSelectedIndex: function enabledSelectedIndex() {
      var ref = this.context;
      var selectedIndex = ref.selectedIndex;
      return this.focusableIndexes.indexOf(selectedIndex);
    },
    count: function count() {
      return this.focusableIndexes.length;
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$nextTick(function () {
      var children = this$1.$el.children;
      this$1.allNodes = Object.assign({}, children);
    });
  },
  methods: {
    /**
     * Updates current Index
     * @param {Number} index Index
     */
    updateIndex: function updateIndex(index) {
      var ref = this.context;
      var onChangeTab = ref.onChangeTab;
      var childIndex = this.focusableIndexes[index];
      this.allNodes[childIndex].focus();
      onChangeTab && onChangeTab(childIndex);
    },

    /**
     * Handles keydown event
     * @param {Event} event event
     */
    handleKeyDown: function handleKeyDown(event) {
      var ref = this.context;
      var onFocusPanel = ref.onFocusPanel;

      if (event.key === 'ArrowRight') {
        event.preventDefault();
        var nextIndex = (this.enabledSelectedIndex + 1) % this.count;
        this.updateIndex(nextIndex);
      }

      if (event.key === 'ArrowLeft' || event.key === 'ArrowUp') {
        event.preventDefault();
        var nextIndex$1 = (this.enabledSelectedIndex - 1 + this.count) % this.count;
        this.updateIndex(nextIndex$1);
      }

      if (event.key === 'Home') {
        event.preventDefault();
        this.updateIndex(0);
      }

      if (event.key === 'End') {
        event.preventDefault();
        this.updateIndex(this.count - 1);
      }

      if (event.key === 'ArrowDown') {
        event.preventDefault();
        onFocusPanel && onFocusPanel();
      }

      this.$emit('keydown', event);
    }
  },
  render: function render(h) {
    var this$1 = this;
    this.validChildren = utils.cleanChildren(this.$slots.default);
    var ref = this.context;
    var id = ref.id;
    var isManual = ref.isManual;
    var manualIndex = ref.manualIndex;
    var selectedIndex = ref.selectedIndex;
    var onManualTabChange = ref.onManualTabChange;
    var onChangeTab = ref.onChangeTab;
    var orientation = ref.orientation;
    var validChildren = utils.cleanChildren(this.$slots.default);
    var clones = validChildren.map(function (vnode, index) {
      var isSelected = isManual ? index === manualIndex : index === selectedIndex;

      var handleClick = function handleClick(event) {
        // Hack for Safari. Buttons don't receive focus on click on Safari
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
        this$1.allNodes[index].focus();
        onManualTabChange(index);
        onChangeTab(index);
        this$1.$emit('click', event);
      };

      var clone = utils.cloneVNodeElement(vnode, {
        props: {
          isSelected: isSelected
        },
        nativeOn: {
          click: handleClick
        },
        attrs: {
          id: id + "-" + index
        }
      }, h);
      return clone;
    });
    this.focusableIndexes = clones.map(function (child, index) {
      return child.componentOptions.propsData.isDisabled === true ? null : index;
    }).filter(function (index) {
      return index != null;
    });
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, {
        role: 'tablist',
        'aria-orientation': orientation
      }, this.computedAttrs),
      on: Object.assign({}, this.computedListeners, {
        keydown: this.handleKeyDown
      })
    }, clones);
  }
};
/**
 * CTab component
 *
 * the tab element component
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/tabs
 */

var CTab = {
  name: 'CTab',
  mixins: [utils.createStyledAttrsMixin('CTab')],
  inject: ['$TabContext'],
  props: {
    isSelected: Boolean,
    isDisabled: Boolean,
    id: String,
    as: {
      type: [String, Object],
      default: 'button'
    }
  },
  computed: {
    context: function context() {
      return this.$TabContext();
    },
    componentStyles: function componentStyles() {
      var ref = this.context;
      var color = ref.color;
      var isFitted = ref.isFitted;
      var orientation = ref.orientation;
      var size = ref.size;
      var variant = ref.variant;
      return Object.assign({}, {
        outline: 'none'
      }, useTabStyle({
        colorMode: this.colorMode,
        theme: this.theme,
        color: color,
        isFitted: isFitted,
        orientation: orientation,
        size: size,
        variant: variant
      }));
    }
  },
  render: function render(h) {
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, {
        role: 'tab',
        tabindex: this.isSelected ? 0 : -1,
        id: "tab:" + this.id,
        type: 'button',
        disabled: this.isDisabled,
        'aria-disabled': this.isDisabled,
        'aria-selected': this.isSelected,
        'aria-controls': "panel:" + this.id
      }, this.computedAttrs),
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CTabPanel component
 *
 * the panel element component fro tab content
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/tabs
 */

var CTabPanel = {
  name: 'CTabPanel',
  mixins: [utils.createStyledAttrsMixin('CTabPanel')],
  props: {
    isSelected: Boolean,
    selectedPanelNode: Object,
    id: String
  },
  render: function render(h) {
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, {
        role: 'tabpanel',
        tabindex: -1,
        'aria-labelledby': "tab:" + this.id,
        hidden: !this.isSelected,
        id: "panel:" + this.id,
        outline: 0
      }, this.computedAttrs),
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CTabPanels component
 *
 * the wrapper  component fro tab panels
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/tabs
 */

var CTabPanels = {
  name: 'CTabPanels',
  mixins: [utils.createStyledAttrsMixin('CTabPanels')],
  inject: ['$TabContext'],
  computed: {
    context: function context() {
      return this.$TabContext();
    }
  },
  render: function render(h) {
    var ref = this.context;
    var selectedIndex = ref.selectedIndex;
    var id = ref.id;
    var isManual = ref.isManual;
    var manualIndex = ref.manualIndex;
    var validChildren = utils.cleanChildren(this.$slots.default);
    var clones = validChildren.map(function (child, index) {
      var isSelected = isManual ? index === manualIndex : index === selectedIndex;
      return utils.cloneVNodeElement(child, {
        props: {
          isSelected: isSelected,
          id: id + "-" + index
        }
      }, h);
    });
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, {
        tabindex: -1
      }, this.computedAttrs),
      on: this.computedListeners
    }, clones);
  }
};
exports.CTab = CTab;
exports.CTabList = CTabList;
exports.CTabPanel = CTabPanel;
exports.CTabPanels = CTabPanels;
exports.CTabs = CTabs;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(8);

var css = __webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

var CIcon = __webpack_require__(9);

var CPseudoBox = __webpack_require__(12);

var badge_styles = __webpack_require__(57);

__webpack_require__(22);

var CText = __webpack_require__(26);
/**
 * Hey! Welcome to @chakra-ui/vue Tag
 *
 * Tag component is used for items that need to be
 * labeled, categorized, or organized using keywords
 * that describe them.
 *
 * @see Docs     https://vue.chakra-ui.com/tag
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CTag/CTag.js
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}

var tagSizes = {
  sm: {
    minH: 6,
    minW: 6,
    fontSize: 'sm',
    px: 2
  },
  md: {
    minH: '1.75rem',
    minW: '1.75rem',
    fontSize: 'sm',
    px: 2
  },
  lg: {
    minH: 8,
    minW: 8,
    px: 3
  }
};
/**
 * CTagCloseButton component
 *
 * the close button for the tag
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/tabs
 */

var CTagCloseButton = {
  name: 'CTagCloseButton',
  functional: true,
  props: {
    isDisabled: Boolean
  },
  render: function render(h, ref) {
    var data = ref.data;
    var props = ref.props;
    var listeners = ref.listeners;
    var rest$1 = objectWithoutProperties(ref, ["data", "props", "listeners"]);
    var rest = rest$1; // Event listeners

    var nonNativeEvents = {
      click: function click(e) {
        var emitClick = listeners.click;

        if (emitClick) {
          emitClick(e);
        }
      }
    };
    var ref$1 = utils.extractListeners({
      listeners: listeners
    }, nonNativeEvents);
    var native = ref$1.native;
    var nonNative = ref$1.nonNative;
    return h(CPseudoBox.default, Object.assign({}, rest, {
      props: {
        as: 'button'
      },
      on: nonNative,
      nativeOn: native,
      attrs: Object.assign({}, data.attrs, {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        transition: 'all 0.2s',
        rounded: 'full',
        size: '1.25rem',
        outline: 'none',
        opacity: '0.5',
        mr: -1,
        _disabled: {
          opacity: '0.4',
          cursor: 'not-allowed',
          boxShadow: 'none'
        },
        _focus: {
          boxShadow: 'outline',
          bg: 'rgba(0, 0, 0, 0.14)'
        },
        _hover: {
          opacity: '0.8'
        },
        _active: {
          opacity: '1'
        },
        disabled: props.isDisabled,
        'data-chakra-component': 'CTagCloseButton'
      })
    }), [h(CIcon.CIcon, {
      props: {
        size: '18px',
        name: 'small-close'
      },
      attrs: {
        focusable: false
      }
    })]);
  }
};
/**
 * CTagIcon component
 *
 * the icon for the tag
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/tabs
 */

var CTagIcon = {
  name: 'CTagIcon',
  functional: true,
  props: {
    icon: [String, Object]
  },
  render: function render(h, ref) {
    var props = ref.props;
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["props", "data"]);
    var rest = rest$1;
    var childrenClassName = css.css({
      '&:first-child': {
        marginLeft: 0
      },
      '&:last-child': {
        marginRight: 0
      }
    });

    if (typeof props.icon === 'string') {
      return h(CIcon.CIcon, Object.assign({}, rest, {
        class: [childrenClassName],
        props: {
          name: props.icon
        },
        attrs: Object.assign({}, data.attrs, {
          mx: '0.5rem',
          'data-chakra-component': 'CTagIcon'
        })
      }));
    }

    return h(CBox.default, Object.assign({}, rest, {
      class: [childrenClassName],
      props: {
        as: props.icon
      },
      attrs: Object.assign({}, data.attrs, {
        mx: '0.5rem',
        color: 'currentColor',
        'data-chakra-component': 'CTagIcon'
      })
    }));
  }
};
/**
 * CTagLabel component
 *
 * the icon for the tag
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/tabs
 */

var CTagLabel = {
  name: 'CTagLabel',
  functional: true,
  render: function render(h, ref) {
    var props = ref.props;
    var data = ref.data;
    var slots = ref.slots;
    var rest$1 = objectWithoutProperties(ref, ["props", "data", "slots"]);
    var rest = rest$1;
    return h(CText.default, Object.assign({}, rest, {
      props: {
        as: 'span',
        isTruncated: true
      },
      attrs: Object.assign({}, {
        lineHeight: 1.2
      }, data.attrs, {
        'data-chakra-component': 'CTagLabel'
      })
    }), slots().default);
  }
};
/**
 * CTag component
 *
 * the wrapper element for the tag's children
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/tabs
 */

var CTag = {
  name: 'CTag',
  inject: ['$chakraTheme', '$chakraColorMode'],
  functional: true,
  props: {
    variant: {
      type: String,
      default: 'subtle'
    },
    size: {
      type: String,
      default: 'lg'
    },
    variantColor: {
      type: String,
      default: 'gray'
    }
  },
  render: function render(h, ref) {
    var injections = ref.injections;
    var props = ref.props;
    var slots = ref.slots;
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["injections", "props", "slots", "data"]);
    var rest = rest$1;
    var theme = injections.$chakraTheme();
    var colorMode = injections.$chakraColorMode();
    utils.useVariantColorWarning(theme, 'Tag', props.variantColor);
    var tagStyles = badge_styles.useBadgeStyle({
      variant: props.variant,
      color: props.variantColor,
      colorMode: colorMode,
      theme: theme
    });
    var sizeStyles = tagSizes[props.size];
    return h(CPseudoBox.default, Object.assign({}, rest, {
      attrs: Object.assign({}, {
        display: 'inline-flex',
        alignItems: 'center',
        minH: 6,
        maxW: '100%',
        rounded: 'md',
        fontWeight: 'medium'
      }, data.attrs || {}, sizeStyles, tagStyles, {
        'data-chakra-component': 'CTag'
      })
    }), slots().default);
  }
};
exports.CTag = CTag;
exports.CTagCloseButton = CTagCloseButton;
exports.CTagIcon = CTagIcon;
exports.CTagLabel = CTagLabel;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var props_types = __webpack_require__(6);

__webpack_require__(15);

var CInput = __webpack_require__(61);
/**
 * Hey! Welcome to @chakra-ui/vue Textarea
 *
 * The Textarea component allows you to easily
 * create multi-line text inputs.
 *
 * @see Docs     https://vue.chakra-ui.com/textarea
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CTextarea/CTextarea.js
 */


function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * CTextarea component
 *
 * the textarea element component
 *
 * @extends CInput
 * @see Docs https://vue.chakra-ui.com/textarea
 */


var CTextarea = {
  name: 'CTextarea',
  functional: true,
  model: {
    prop: 'inputValue',
    event: 'change'
  },
  props: Object.assign({}, CInput.inputProps, {
    inputValue: String,
    py: {
      type: props_types.SNA,
      default: '8px'
    },
    minHeight: {
      type: props_types.SNA,
      default: '80px'
    },
    fontFamily: {
      type: props_types.SNA,
      default: 'body'
    },
    lineHeight: {
      type: props_types.SNA,
      default: 'shorter'
    }
  }),
  render: function render(h, ref) {
    var props = ref.props;
    var slots = ref.slots;
    var data = ref.data;
    var listeners = ref.listeners;
    var rest$1 = objectWithoutProperties(ref, ["props", "slots", "data", "listeners"]);
    var rest = rest$1; // Default styles

    var defaultStyles = {
      py: '8px',
      minHeight: '80px',
      fontFamily: 'body',
      lineHeight: 'shorter'
    }; // Event listeners

    var nonNativeEvents = {
      input: function input(value, $e) {
        var emitChange = listeners.change;

        if (emitChange && $e instanceof Event) {
          if (typeof emitChange === 'function') {
            return emitChange(value, $e);
          }

          emitChange.forEach(function (listener) {
            return listener(value, $e);
          });
        }
      }
    };
    var ref$1 = utils.extractListeners({
      listeners: listeners
    }, nonNativeEvents);
    var nonNative = ref$1.nonNative;
    return h(CInput.CInput, Object.assign({}, rest, {
      props: Object.assign({}, utils.pickProperty(props), {
        as: 'textarea'
      }),
      attrs: Object.assign({}, defaultStyles, data.attrs || {}, {
        'data-chakra-component': 'CTextarea'
      }),
      on: nonNative
    }), slots().default);
  }
};
exports.default = CTextarea;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * ! @chakra-ui/vue v0.11.0 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(2);

__webpack_require__(4);

__webpack_require__(25);

__webpack_require__(1);

__webpack_require__(0);

__webpack_require__(3);

var CBox = __webpack_require__(5);

__webpack_require__(12);

__webpack_require__(17);

__webpack_require__(13);

var CVisuallyHidden = __webpack_require__(18);

var CFragment = __webpack_require__(60);

var CPopper = __webpack_require__(62);
/**
 * Hey! Welcome to @chakra-ui/vue Tooltip
 *
 * A Tooltip is a popup that displays information related
 * to an element when the element receives keyboard focus
 * or the mouse hovers over it
 *
 * 🚨NOTE: The WAI-ARIA design pattern for Tooltips is work in
 * progress; it does not yet have task force consensus.
 * Progress and discussions are captured in
 * [issue 128](https://github.com/w3c/aria-practices/issues/128).
 *
 * @see Docs     https://vue.chakra-ui.com/tooltip
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CTooltip/CTooltip.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CTooltip/accessibility.md
 */


var tooltipProps = {
  label: String,
  _ariaLabel: String,
  showDelay: {
    type: Number,
    default: 0
  },
  hideDelay: {
    type: Number,
    default: 0
  },
  placement: {
    type: String,
    default: 'top'
  },
  hasArrow: Boolean,
  closeOnClick: Boolean,
  defaultIsOpen: Boolean,
  shouldWrapChildren: Boolean,
  controlledIsOpen: Boolean,
  isControlled: Boolean,
  onOpen: Function,
  onClose: Function
};
/**
 * CTooltip component
 *
 * A tooltip is a brief, informative message that appears when a
 * user interacts with an element.
 *
 * The `CTooltip` achieves this by cloning it's children VNodes
 * and then attaches hover and focus events to it in order to display
 * and hide the tooltip conveniently as per WAI-ARIA specs
 *
 * @extends CPopper
 * @see Docs https://vue.chakra-ui.com/tooltip
 */

var CTooltip = {
  name: 'CTooltip',
  inject: ['$chakraColorMode'],
  inheritAttrs: false,
  data: function data() {
    return {
      isOpen: this.isControlled ? this.controlledIsOpen : this.defaultIsOpen || false,
      enterTimeout: null,
      exitTimeout: null,
      tooltipAnchor: undefined,
      noop: 0
    };
  },
  computed: {
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    },
    tooltipId: function tooltipId() {
      return "tooltip-" + utils.useId(4);
    }
  },
  methods: {
    open: function open() {
      this.isOpen = true;
    },
    close: function close() {
      this.isOpen = false;
    },
    openWithDelay: function openWithDelay() {
      this.enterTimeout = setTimeout(this.open, this.showDelay);
    },
    closeWithDelay: function closeWithDelay() {
      this.exitTimeout = setTimeout(this.close, this.hideDelay);
    },
    handleOpen: function handleOpen() {
      if (!this.isControlled) {
        this.openWithDelay();
      }

      this.open && this.open();
      this.$emit('open');
    },
    handleClose: function handleClose() {
      if (!this.isControlled) {
        this.closeWithDelay();
      }

      this.close && this.close();
      this.$emit('close');
    },
    handleClick: function handleClick() {
      this.closeOnClick && this.closeOnClick();
      this.$emit('click');
    },
    handleKeydown: function handleKeydown(event) {
      var key = event.key;

      if (key === 'Escape') {
        this.handleClose();
      }
    }
  },
  props: tooltipProps,
  mounted: function mounted() {
    var this$1 = this; // When component is mounted we force re-render because component
    // children may not yet be rendered so event listeners may not be
    // Attached immediately.

    this.$nextTick(function () {
      this$1.noop++;
      this$1.tooltipAnchor = document.querySelector("[x-tooltip-anchor=" + this$1.tooltipId + "]");
    });
  },
  render: function render(h) {
    var this$1 = this;
    var clone; // Styles for tooltip

    var _bg = this.colorMode === 'dark' ? 'gray.300' : 'gray.700';

    var _color = this.colorMode === 'dark' ? 'gray.900' : 'whiteAlpha.900'; // ARIA label for tooltip


    var hasAriaLabel = this._ariaLabel !== undefined; // Child nodes parsing

    var children = this.$slots.default;

    if (children.length > 1) {
      return console.error('[ChakraUI]: The CTooltip component only expects one child.');
    }

    if (children[0].text || this.shouldWrapChildren) {
      clone = clone = h(CBox.default, {
        props: {
          as: 'span'
        },
        attrs: Object.assign({}, {
          tabindex: 0,
          'x-tooltip-anchor': "" + this.tooltipId
        }, this.isOpen && {
          'aria-describedby': this.tooltipId
        }),
        on: {
          mouseenter: this.handleOpen,
          mouseleave: this.handleClose,
          click: this.handleClick,
          focus: this.handleOpen,
          blur: this.handleClose,
          keydown: this.handleKeydown
        },
        ref: 'tooltipRef'
      }, children[0].text);
    } else {
      var cloned = utils.cloneVNode(children[0], h);

      if (cloned.componentOptions) {
        clone = h(cloned.componentOptions.Ctor, Object.assign({}, cloned.data, cloned.componentOptions.listeners || {}, {
          props: Object.assign({}, cloned.data.props || {}, cloned.componentOptions.propsData),
          attrs: Object.assign({}, cloned.data.attrs, this.isOpen && {
            'aria-describedby': this.tooltipId
          }, {
            'x-tooltip-anchor': "" + this.tooltipId
          }),
          on: cloned.componentOptions.listeners,
          nativeOn: {
            mouseenter: this.handleOpen,
            mouseleave: this.handleClose,
            click: utils.wrapEvent(this.handleClick, function (e) {
              return this$1.$emit('click', e);
            }),
            focus: this.handleOpen,
            blur: this.handleClose,
            keydown: this.handleKeydown
          }
        }), cloned.componentOptions.children);
      }
    }

    return h(CFragment.default, [clone, h(CPopper.CPopper, {
      props: Object.assign({}, {
        usePortal: true,
        anchorEl: this.tooltipAnchor,
        hasArrow: true,
        isOpen: this.isOpen,
        placement: this.placement,
        modifiers: [{
          name: 'offset',
          options: {
            offset: [0, 8]
          }
        }],
        arrowSize: '10px'
      }, utils.pickProperty(this.$props)),
      attrs: Object.assign({}, {
        px: '8px',
        py: '2px',
        bg: _bg,
        borderRadius: 'sm',
        fontWeight: 'medium',
        pointerEvents: 'none',
        color: _color,
        fontSize: 'sm',
        shadow: 'md',
        maxW: '320px'
      }, this.$attrs, {
        id: hasAriaLabel ? undefined : this.tooltipId,
        role: hasAriaLabel ? undefined : 'tooltip',
        'data-noop': this.noop,
        'data-chakra-component': 'CTooltip'
      })
    }, [this.label, hasAriaLabel && h(CVisuallyHidden.default, {
      attrs: {
        role: 'tooltip',
        id: this.tooltipId
      }
    }, this._ariaLabel), this.hasArrow && h(CPopper.CPopperArrow)])]);
  }
};
exports.default = CTooltip;

/***/ }),
/* 146 */
/***/ (function(module, exports) {

module.exports = function installChakraComponents (component, components) {
  const options = typeof component.exports === 'function'
    ? component.exports.extendOptions
    : component.options

  if (typeof component.exports === 'function') {
    options.components = component.exports.options.components
  }

  options.components = options.components || {}

  for (var i in components) {
    options.components[i] = options.components[i] || components[i]
  }


  if (options.functional) {
    provideFunctionalComponents(component, options.components)
  }
}

const functionalPatchKey = '_functionalComponents'

function provideFunctionalComponents(component, components) {
  if (component.exports[functionalPatchKey]) {
    return
  }
  component.exports[functionalPatchKey] = true

  const render = component.exports.render
  component.exports.render = function (h, vm) {
    return render(h, Object.assign({}, vm, {
      _c: function (n, a, b) {
        return vm._c(components[n] || n, a, b)
      }
    }))
  }
}

/***/ }),
/* 147 */
/***/ (function(module, exports) {

// This file is intentionally left empty for noop aliases

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(24);

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _colors = _interopRequireDefault(__webpack_require__(149));

var _typography = _interopRequireDefault(__webpack_require__(150));

var _borders = _interopRequireWildcard(__webpack_require__(151));

var _opacity = _interopRequireDefault(__webpack_require__(152));

var _radii = _interopRequireDefault(__webpack_require__(153));

var _shadows = _interopRequireDefault(__webpack_require__(154));

var _sizes = _interopRequireWildcard(__webpack_require__(155));

var _zIndices = _interopRequireDefault(__webpack_require__(156));

var _breakpoints = _interopRequireDefault(__webpack_require__(157));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var space = _sizes.baseSizes;
var config = {
  useSystemColorMode: false,
  initialColorMode: 'light',
  cssVarPrefix: 'chakra'
};

var theme = _objectSpread(_objectSpread({
  breakpoints: _breakpoints.default,
  zIndices: _zIndices.default,
  radii: _radii.default,
  opacity: _opacity.default,
  borders: _borders.default,
  colors: _colors.default
}, _typography.default), {}, {
  borderWidths: _borders.borderWidths,
  sizes: _sizes.default,
  shadows: _shadows.default,
  space: space,
  config: config
});

var _default = theme;
exports.default = _default;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var colors = {
  transparent: 'transparent',
  current: 'currentColor',
  black: '#000',
  white: '#fff',
  primary: '#1a72ff',
  secondary: '#7425f3',
  tertiary: '#fe9e4d',
  success: '#3ea76a',
  warning: '#ffc61a',
  error: '#dd3b4b',
  whiteAlpha: {
    50: 'rgba(255, 255, 255, 0.04)',
    100: 'rgba(255, 255, 255, 0.06)',
    200: 'rgba(255, 255, 255, 0.08)',
    300: 'rgba(255, 255, 255, 0.16)',
    400: 'rgba(255, 255, 255, 0.24)',
    500: 'rgba(255, 255, 255, 0.36)',
    600: 'rgba(255, 255, 255, 0.48)',
    700: 'rgba(255, 255, 255, 0.64)',
    800: 'rgba(255, 255, 255, 0.80)',
    900: 'rgba(255, 255, 255, 0.92)'
  },
  blackAlpha: {
    50: 'rgba(0, 0, 0, 0.04)',
    100: 'rgba(0, 0, 0, 0.06)',
    200: 'rgba(0, 0, 0, 0.08)',
    300: 'rgba(0, 0, 0, 0.16)',
    400: 'rgba(0, 0, 0, 0.24)',
    500: 'rgba(0, 0, 0, 0.36)',
    600: 'rgba(0, 0, 0, 0.48)',
    700: 'rgba(0, 0, 0, 0.64)',
    800: 'rgba(0, 0, 0, 0.80)',
    900: 'rgba(0, 0, 0, 0.92)'
  },
  gray: {
    50: '#F7FAFC',
    100: '#EDF2F7',
    200: '#E2E8F0',
    300: '#CBD5E0',
    400: '#A0AEC0',
    500: '#718096',
    600: '#4A5568',
    700: '#2D3748',
    800: '#1A202C',
    900: '#171923'
  },
  cyan: {
    50: '#EDFDFD',
    100: '#C4F1F9',
    200: '#9DECF9',
    300: '#76E4F7',
    400: '#0BC5EA',
    500: '#00B5D8',
    600: '#00A3C4',
    700: '#0987A0',
    800: '#086F83',
    900: '#065666'
  },
  vue: {
    50: '#e1fbf0',
    100: '#c0ecda',
    200: '#9edfc2',
    300: '#79d0aa',
    400: '#55c392',
    500: '#3caa79',
    600: '#2d845e',
    700: '#1d5e42',
    800: '#0c3a26',
    900: '#001508'
  },
  green: {
    50: '#e2fbed',
    100: '#c2ebd4',
    200: '#9fddb9',
    300: '#7ccf9e',
    400: '#58c184',
    500: '#3ea76a',
    600: '#2e8251',
    700: '#1f5d3a',
    800: '#0f3921',
    900: '#001506'
  },
  orange: {
    50: '#ffefdc',
    100: '#ffd4ae',
    200: '#ffba7f',
    300: '#fe9e4d',
    400: '#fd821b',
    500: '#e46902',
    600: '#b25100',
    700: '#7f3900',
    800: '#4e2200',
    900: '#1f0900'
  },
  red: {
    50: '#ffe5e9',
    100: '#f9bcc2',
    200: '#ee919a',
    300: '#e66673',
    400: '#dd3b4b',
    500: '#c42231',
    600: '#991826',
    700: '#6e101a',
    800: '#44070e',
    900: '#1e0001'
  },
  yellow: {
    50: '#fff9da',
    100: '#ffecad',
    200: '#ffdf7d',
    300: '#ffd24b',
    400: '#ffc61a',
    500: '#e6ac00',
    600: '#b38600',
    700: '#806000',
    800: '#4e3900',
    900: '#1d1300'
  },
  indigo: {
    50: '#f2e5ff',
    100: '#d2b5ff',
    200: '#b285fa',
    300: '#9356f7',
    400: '#7425f3',
    500: '#5a0cda',
    600: '#4608aa',
    700: '#32057b',
    800: '#1e024c',
    900: '#0c001e'
  },
  pink: {
    50: '#fff5f7',
    100: '#fed7e2',
    200: '#fbb6ce',
    300: '#f687b3',
    400: '#ed64a6',
    500: '#d53f8c',
    600: '#b83280',
    700: '#97266d',
    800: '#702459',
    900: '#521B41'
  },
  blue: {
    50: '#def0ff',
    100: '#afd0ff',
    200: '#7db1ff',
    300: '#4b91ff',
    400: '#1a72ff',
    500: '#0058e6',
    600: '#0045b4',
    700: '#003182',
    800: '#001d51',
    900: '#000a21'
  }
};
var _default = colors;
exports.default = _default;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @description This typography style was adapted from [@chakra-ui](https://chakra-ui.com/)
 */

var typography = {
  letterSpacings: {
    tighter: '-0.05em',
    tight: '-0.025em',
    normal: '0',
    wide: '0.025em',
    wider: '0.05em',
    widest: '0.1em'
  },
  lineHeights: {
    normal: 'normal',
    none: '1',
    shorter: '1.25',
    short: '1.375',
    base: '1.5',
    tall: '1.625',
    taller: '2'
  },
  fontWeights: {
    hairline: 100,
    thin: 200,
    light: 300,
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
    extrabold: 800,
    black: 900
  },
  fonts: {
    heading: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    mono: 'SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'
  },
  fontSizes: {
    xs: '0.75rem',
    sm: '0.875rem',
    md: '1rem',
    lg: '1.125rem',
    xl: '1.25rem',
    '2xl': '1.5rem',
    '3xl': '1.875rem',
    '4xl': '2.25rem',
    '5xl': '3rem',
    '6xl': '4rem'
  }
};
var _default = typography;
exports.default = _default;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.borderWidths = void 0;
/**
 * @description These border styles were adapted from [@chakra-ui](https://chakra-ui.com/)
 */

var borders = {
  none: 0,
  '1px': '1px solid',
  '2px': '2px solid',
  '4px': '4px solid'
};
var borderWidths = {
  sm: '1px',
  md: '2px',
  lg: '4px'
};
exports.borderWidths = borderWidths;
var _default = borders;
exports.default = _default;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @description These opacity styles was adapted from [@chakra-ui](https://chakra-ui.com/)
 */

var opacity = {
  0: '0',
  '20%': '0.2',
  '40%': '0.4',
  '60%': '0.6',
  '80%': '0.8',
  '100%': '1'
};
var _default = opacity;
exports.default = _default;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @description These radii styles was adapted from [@chakra-ui](https://chakra-ui.com/)
 */

var radii = {
  none: '0',
  sm: '0.125rem',
  md: '0.25rem',
  lg: '0.5rem',
  full: '9999px'
};
var _default = radii;
exports.default = _default;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @description These shadow styles was adapted from [@chakra-ui](https://chakra-ui.com/)
 */

var shadows = {
  sm: '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)',
  md: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
  lg: '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',
  xl: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
  '2xl': '0 25px 50px -12px rgba(0, 0, 0, 0.25)',
  outline: '0 0 0 3px rgba(66, 153, 225, 0.6)',
  inner: 'inset 0 2px 4px 0 rgba( 0, 0, 0, 0.06)',
  none: 'none'
};
var _default = shadows;
exports.default = _default;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.baseSizes = void 0;

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
/**
 * @description These sizes styles was adapted from [@chakra-ui](https://chakra-ui.com/)
 */


var baseSizes = {
  px: '1px',
  0: '0',
  1: '0.25rem',
  2: '0.5rem',
  3: '0.75rem',
  4: '1rem',
  5: '1.25rem',
  6: '1.5rem',
  8: '2rem',
  10: '2.5rem',
  12: '3rem',
  16: '4rem',
  20: '5rem',
  24: '6rem',
  32: '8rem',
  40: '10rem',
  48: '12rem',
  56: '14rem',
  64: '16rem'
};
exports.baseSizes = baseSizes;
var largeSizes = {
  full: '100%',
  '3xs': '14rem',
  '2xs': '16rem',
  xs: '20rem',
  sm: '24rem',
  md: '28rem',
  lg: '32rem',
  xl: '36rem',
  '2xl': '42rem',
  '3xl': '48rem',
  '4xl': '56rem',
  '5xl': '64rem',
  '6xl': '72rem'
};
var containers = {
  sm: '640px',
  md: '768px',
  lg: '1024px',
  xl: '1280px'
};

var sizes = _objectSpread(_objectSpread(_objectSpread({}, baseSizes), largeSizes), {}, {
  containers: containers
});

var _default = sizes;
exports.default = _default;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @description This typography style was adapted from [@chakra-ui](https://chakra-ui.com/)
 */

var zIndices = {
  hide: -1,
  auto: 'auto',
  base: 0,
  docked: 10,
  dropdown: 1000,
  sticky: 1100,
  banner: 1200,
  overlay: 1300,
  modal: 1400,
  popover: 1500,
  skipLink: 1600,
  toast: 1700,
  tooltip: 1800
};
var _default = zIndices;
exports.default = _default;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.createBreakpoints = void 0;

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
/**
 * @description These breakpoint styles were adapted from [@chakra-ui](https://chakra-ui.com/)
 */


var _breakpoints = {
  sm: '30em',
  md: '48em',
  lg: '62em',
  xl: '80em',
  '2xl': '96em'
};

var createBreakpoints = function createBreakpoints() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return _objectSpread({
    base: '0em'
  }, config);
};

exports.createBreakpoints = createBreakpoints;
var breakpoints = createBreakpoints(_breakpoints);
var _default = breakpoints;
exports.default = _default;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(24);

__webpack_require__(41);

__webpack_require__(42);

__webpack_require__(43);

__webpack_require__(44);

__webpack_require__(45);

__webpack_require__(46);

__webpack_require__(47);

__webpack_require__(48);

__webpack_require__(49);

__webpack_require__(50);

__webpack_require__(51);

__webpack_require__(52);

__webpack_require__(53);

__webpack_require__(54);

__webpack_require__(55);

__webpack_require__(56);

Object.defineProperty(exports, '__esModule', {
  value: true
});

var utils = __webpack_require__(71);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var tokenToCSSVar = function tokenToCSSVar(scale, value) {
  return function (theme) {
    var valueStr = String(value);
    var key = scale ? scale + "." + valueStr : valueStr;
    return utils.isObject(theme.__cssMap) && key in theme.__cssMap ? theme.__cssMap[key].varRef : value;
  };
};

function createTransform(options) {
  var scale = options.scale,
      transform = options.transform,
      compose = options.compose;

  var fn = function fn(value, theme) {
    var _transform;

    var _value = tokenToCSSVar(scale, value)(theme);

    var result = (_transform = transform == null ? void 0 : transform(_value, theme)) != null ? _transform : _value;

    if (compose) {
      result = compose(result, theme);
    }

    return result;
  };

  return fn;
}

function toConfig(scale, transform) {
  return function (property) {
    var result = {
      property: property,
      scale: scale
    };
    result.transform = createTransform({
      scale: scale,
      transform: transform
    });
    return result;
  };
}

var getRtl = function getRtl(_ref) {
  var rtl = _ref.rtl,
      ltr = _ref.ltr;
  return function (theme) {
    return theme.direction === "rtl" ? rtl : ltr;
  };
};

function logical(options) {
  var property = options.property,
      scale = options.scale,
      transform = options.transform;
  return {
    scale: scale,
    property: getRtl(property),
    transform: scale ? createTransform({
      scale: scale,
      compose: transform
    }) : transform
  };
}

var _spaceXTemplate, _spaceYTemplate;
/**
 * The CSS transform order following the upcoming spec from CSSWG
 * translate => rotate => scale => skew
 * @see https://drafts.csswg.org/css-transforms-2/#ctm
 * @see https://www.stefanjudis.com/blog/order-in-css-transformation-transform-functions-vs-individual-transforms/
 */


var transformTemplate = ["rotate(var(--chakra-rotate, 0))", "scaleX(var(--chakra-scale-x, 1))", "scaleY(var(--chakra-scale-y, 1))", "skewX(var(--chakra-skew-x, 0))", "skewY(var(--chakra-skew-y, 0))"];

function getTransformTemplate() {
  return ["translateX(var(--chakra-translate-x, 0))", "translateY(var(--chakra-translate-y, 0))"].concat(transformTemplate).join(" ");
}

function getTransformGpuTemplate() {
  return ["translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)"].concat(transformTemplate).join(" ");
}

var filterTemplate = {
  "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
  filter: ["var(--chakra-blur)", "var(--chakra-brightness)", "var(--chakra-contrast)", "var(--chakra-grayscale)", "var(--chakra-hue-rotate)", "var(--chakra-invert)", "var(--chakra-saturate)", "var(--chakra-sepia)", "var(--chakra-drop-shadow)"].join(" ")
};
var backdropFilterTemplate = {
  backdropFilter: ["var(--chakra-backdrop-blur)", "var(--chakra-backdrop-brightness)", "var(--chakra-backdrop-contrast)", "var(--chakra-backdrop-grayscale)", "var(--chakra-backdrop-hue-rotate)", "var(--chakra-backdrop-invert)", "var(--chakra-backdrop-opacity)", "var(--chakra-backdrop-saturate)", "var(--chakra-backdrop-sepia)"].join(" "),
  "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
};

function getRingTemplate(value) {
  return {
    "--chakra-ring-offset-shadow": "var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)",
    "--chakra-ring-shadow": "var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)",
    "--chakra-ring-width": value,
    boxShadow: ["var(--chakra-ring-offset-shadow)", "var(--chakra-ring-shadow)", "var(--chakra-shadow, 0 0 #0000)"].join(", ")
  };
}

var flexDirectionTemplate = {
  "row-reverse": {
    space: "--chakra-space-x-reverse",
    divide: "--chakra-divide-x-reverse"
  },
  "column-reverse": {
    space: "--chakra-space-y-reverse",
    divide: "--chakra-divide-y-reverse"
  }
};
var owlSelector = "& > :not(style) ~ :not(style)";
var spaceXTemplate = (_spaceXTemplate = {}, _spaceXTemplate[owlSelector] = {
  marginInlineStart: "calc(var(--chakra-space-x) * calc(1 - var(--chakra-space-x-reverse)))",
  marginInlineEnd: "calc(var(--chakra-space-x) * var(--chakra-space-x-reverse))"
}, _spaceXTemplate);
var spaceYTemplate = (_spaceYTemplate = {}, _spaceYTemplate[owlSelector] = {
  marginTop: "calc(var(--chakra-space-y) * calc(1 - var(--chakra-space-y-reverse)))",
  marginBottom: "calc(var(--chakra-space-y) * var(--chakra-space-y-reverse))"
}, _spaceYTemplate);

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _wrapRegExp() {
  _wrapRegExp = function (re, groups) {
    return new BabelRegExp(re, undefined, groups);
  };

  var _super = RegExp.prototype;

  var _groups = new WeakMap();

  function BabelRegExp(re, flags, groups) {
    var _this = new RegExp(re, flags);

    _groups.set(_this, groups || _groups.get(re));

    return _setPrototypeOf(_this, BabelRegExp.prototype);
  }

  _inherits(BabelRegExp, RegExp);

  BabelRegExp.prototype.exec = function (str) {
    var result = _super.exec.call(this, str);

    if (result) result.groups = buildGroups(result, this);
    return result;
  };

  BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {
    if (typeof substitution === "string") {
      var groups = _groups.get(this);

      return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) {
        return "$" + groups[name];
      }));
    } else if (typeof substitution === "function") {
      var _this = this;

      return _super[Symbol.replace].call(this, str, function () {
        var args = arguments;

        if (typeof args[args.length - 1] !== "object") {
          args = [].slice.call(args);
          args.push(buildGroups(args, _this));
        }

        return substitution.apply(this, args);
      });
    } else {
      return _super[Symbol.replace].call(this, str, substitution);
    }
  };

  function buildGroups(result, re) {
    var g = _groups.get(re);

    return Object.keys(g).reduce(function (groups, name) {
      groups[name] = result[g[name]];
      return groups;
    }, Object.create(null));
  }

  return _wrapRegExp.apply(this, arguments);
}

var directionMap = {
  "to-t": "to top",
  "to-tr": "to top right",
  "to-r": "to right",
  "to-br": "to bottom right",
  "to-b": "to bottom",
  "to-bl": "to bottom left",
  "to-l": "to left",
  "to-tl": "to top left"
};
var valueSet = new Set(Object.values(directionMap));
var globalSet = new Set(["none", "-moz-initial", "inherit", "initial", "revert", "unset"]);

var trimSpace = function trimSpace(str) {
  return str.trim();
};

function parseGradient(value, theme) {
  var _regex$exec$groups, _regex$exec;

  if (value == null || globalSet.has(value)) return value;

  var regex = /*#__PURE__*/_wrapRegExp(/(^[\x2DA-Za-z]+)\(((.*))\)/g, {
    type: 1,
    values: 2
  });

  var _ref = (_regex$exec$groups = (_regex$exec = regex.exec(value)) == null ? void 0 : _regex$exec.groups) != null ? _regex$exec$groups : {},
      type = _ref.type,
      values = _ref.values;

  if (!type || !values) return value;

  var _type = type.includes("-gradient") ? type : type + "-gradient";

  var _values$split$map$fil = values.split(",").map(trimSpace).filter(Boolean),
      maybeDirection = _values$split$map$fil[0],
      stops = _values$split$map$fil.slice(1);

  if ((stops == null ? void 0 : stops.length) === 0) return value;
  var direction = maybeDirection in directionMap ? directionMap[maybeDirection] : maybeDirection;
  stops.unshift(direction);

  var _values = stops.map(function (stop) {
    // if stop is valid shorthand direction, return it
    if (valueSet.has(stop)) return stop;
    var firstStop = stop.indexOf(" "); // color stop could be `red.200 20%` based on css gradient spec

    var _ref2 = firstStop !== -1 ? [stop.substr(0, firstStop), stop.substr(firstStop + 1)] : [stop],
        _color = _ref2[0],
        _stop = _ref2[1];

    var _stopOrFunc = isCSSFunction(_stop) ? _stop : _stop && _stop.split(" "); // else, get and transform the color token or css value


    var key = "colors." + _color;
    var color = key in theme.__cssMap ? theme.__cssMap[key].varRef : _color;
    return _stopOrFunc ? [color].concat(Array.isArray(_stopOrFunc) ? _stopOrFunc : [_stopOrFunc]).join(" ") : color;
  });

  return _type + "(" + _values.join(", ") + ")";
}

var isCSSFunction = function isCSSFunction(value) {
  return utils.isString(value) && value.includes("(") && value.includes(")");
};

var gradientTransform = function gradientTransform(value, theme) {
  return parseGradient(value, theme != null ? theme : {});
};

var analyzeCSSValue = function analyzeCSSValue(value) {
  var num = parseFloat(value.toString());
  var unit = value.toString().replace(String(num), "");
  return {
    unitless: !unit,
    value: num,
    unit: unit
  };
};

var wrap = function wrap(str) {
  return function (value) {
    return str + "(" + value + ")";
  };
};

var transformFunctions = {
  filter: function filter(value) {
    return value !== "auto" ? value : filterTemplate;
  },
  backdropFilter: function backdropFilter(value) {
    return value !== "auto" ? value : backdropFilterTemplate;
  },
  ring: function ring(value) {
    return getRingTemplate(transformFunctions.px(value));
  },
  bgClip: function bgClip(value) {
    return value === "text" ? {
      color: "transparent",
      backgroundClip: "text"
    } : {
      backgroundClip: value
    };
  },
  transform: function transform(value) {
    if (value === "auto") return getTransformTemplate();
    if (value === "auto-gpu") return getTransformGpuTemplate();
    return value;
  },
  px: function px(value) {
    if (value == null) return value;

    var _analyzeCSSValue = analyzeCSSValue(value),
        unitless = _analyzeCSSValue.unitless;

    return unitless || utils.isNumber(value) ? value + "px" : value;
  },
  fraction: function fraction(value) {
    return !utils.isNumber(value) || value > 1 ? value : value * 100 + "%";
  },
  "float": function float(value, theme) {
    var map = {
      left: "right",
      right: "left"
    };
    return theme.direction === "rtl" ? map[value] : value;
  },
  degree: function degree(value) {
    if (utils.isCssVar(value) || value == null) return value;
    var unitless = utils.isString(value) && !value.endsWith("deg");
    return utils.isNumber(value) || unitless ? value + "deg" : value;
  },
  gradient: gradientTransform,
  blur: wrap("blur"),
  opacity: wrap("opacity"),
  brightness: wrap("brightness"),
  contrast: wrap("contrast"),
  dropShadow: wrap("drop-shadow"),
  grayscale: wrap("grayscale"),
  hueRotate: wrap("hue-rotate"),
  invert: wrap("invert"),
  saturate: wrap("saturate"),
  sepia: wrap("sepia"),
  bgImage: function bgImage(value) {
    if (value == null) return value;
    var prevent = isCSSFunction(value) || globalSet.has(value);
    return !prevent ? "url(" + value + ")" : value;
  },
  outline: function outline(value) {
    var isNoneOrZero = String(value) === "0" || String(value) === "none";
    return value !== null && isNoneOrZero ? {
      outline: "2px solid transparent",
      outlineOffset: "2px"
    } : {
      outline: value
    };
  },
  flexDirection: function flexDirection(value) {
    var _flexDirectionTemplat;

    var _ref = (_flexDirectionTemplat = flexDirectionTemplate[value]) != null ? _flexDirectionTemplat : {},
        space = _ref.space,
        divide = _ref.divide;

    var result = {
      flexDirection: value
    };
    if (space) result[space] = 1;
    if (divide) result[divide] = 1;
    return result;
  }
};
var t = {
  borderWidths: toConfig("borderWidths"),
  borderStyles: toConfig("borderStyles"),
  colors: toConfig("colors"),
  borders: toConfig("borders"),
  radii: toConfig("radii", transformFunctions.px),
  space: toConfig("space", transformFunctions.px),
  spaceT: toConfig("space", transformFunctions.px),
  degreeT: function degreeT(property) {
    return {
      property: property,
      transform: transformFunctions.degree
    };
  },
  prop: function prop(property, scale, transform) {
    return _extends({
      property: property,
      scale: scale
    }, scale && {
      transform: createTransform({
        scale: scale,
        transform: transform
      })
    });
  },
  propT: function propT(property, transform) {
    return {
      property: property,
      transform: transform
    };
  },
  sizes: toConfig("sizes", transformFunctions.px),
  sizesT: toConfig("sizes", transformFunctions.fraction),
  shadows: toConfig("shadows"),
  logical: logical,
  blur: toConfig("blur", transformFunctions.blur)
};
var background = {
  background: t.colors("background"),
  backgroundColor: t.colors("backgroundColor"),
  backgroundImage: t.propT("backgroundImage", transformFunctions.bgImage),
  backgroundSize: true,
  backgroundPosition: true,
  backgroundRepeat: true,
  backgroundAttachment: true,
  backgroundClip: {
    transform: transformFunctions.bgClip
  },
  bgSize: t.prop("backgroundSize"),
  bgPosition: t.prop("backgroundPosition"),
  bg: t.colors("background"),
  bgColor: t.colors("backgroundColor"),
  bgPos: t.prop("backgroundPosition"),
  bgRepeat: t.prop("backgroundRepeat"),
  bgAttachment: t.prop("backgroundAttachment"),
  bgGradient: t.propT("backgroundImage", transformFunctions.gradient),
  bgClip: {
    transform: transformFunctions.bgClip
  }
};
Object.assign(background, {
  bgImage: background.backgroundImage,
  bgImg: background.backgroundImage
});
var border = {
  border: t.borders("border"),
  borderWidth: t.borderWidths("borderWidth"),
  borderStyle: t.borderStyles("borderStyle"),
  borderColor: t.colors("borderColor"),
  borderRadius: t.radii("borderRadius"),
  borderTop: t.borders("borderTop"),
  borderBlockStart: t.borders("borderBlockStart"),
  borderTopLeftRadius: t.radii("borderTopLeftRadius"),
  borderStartStartRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderTopLeftRadius",
      rtl: "borderTopRightRadius"
    }
  }),
  borderEndStartRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomLeftRadius",
      rtl: "borderBottomRightRadius"
    }
  }),
  borderTopRightRadius: t.radii("borderTopRightRadius"),
  borderStartEndRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderTopRightRadius",
      rtl: "borderTopLeftRadius"
    }
  }),
  borderEndEndRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomRightRadius",
      rtl: "borderBottomLeftRadius"
    }
  }),
  borderRight: t.borders("borderRight"),
  borderInlineEnd: t.borders("borderInlineEnd"),
  borderBottom: t.borders("borderBottom"),
  borderBlockEnd: t.borders("borderBlockEnd"),
  borderBottomLeftRadius: t.radii("borderBottomLeftRadius"),
  borderBottomRightRadius: t.radii("borderBottomRightRadius"),
  borderLeft: t.borders("borderLeft"),
  borderInlineStart: {
    property: "borderInlineStart",
    scale: "borders"
  },
  borderInlineStartRadius: t.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopLeftRadius", "borderBottomLeftRadius"],
      rtl: ["borderTopRightRadius", "borderBottomRightRadius"]
    }
  }),
  borderInlineEndRadius: t.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopRightRadius", "borderBottomRightRadius"],
      rtl: ["borderTopLeftRadius", "borderBottomLeftRadius"]
    }
  }),
  borderX: t.borders(["borderLeft", "borderRight"]),
  borderInline: t.borders("borderInline"),
  borderY: t.borders(["borderTop", "borderBottom"]),
  borderBlock: t.borders("borderBlock"),
  borderTopWidth: t.borderWidths("borderTopWidth"),
  borderBlockStartWidth: t.borderWidths("borderBlockStartWidth"),
  borderTopColor: t.colors("borderTopColor"),
  borderBlockStartColor: t.colors("borderBlockStartColor"),
  borderTopStyle: t.borderStyles("borderTopStyle"),
  borderBlockStartStyle: t.borderStyles("borderBlockStartStyle"),
  borderBottomWidth: t.borderWidths("borderBottomWidth"),
  borderBlockEndWidth: t.borderWidths("borderBlockEndWidth"),
  borderBottomColor: t.colors("borderBottomColor"),
  borderBlockEndColor: t.colors("borderBlockEndColor"),
  borderBottomStyle: t.borderStyles("borderBottomStyle"),
  borderBlockEndStyle: t.borderStyles("borderBlockEndStyle"),
  borderLeftWidth: t.borderWidths("borderLeftWidth"),
  borderInlineStartWidth: t.borderWidths("borderInlineStartWidth"),
  borderLeftColor: t.colors("borderLeftColor"),
  borderInlineStartColor: t.colors("borderInlineStartColor"),
  borderLeftStyle: t.borderStyles("borderLeftStyle"),
  borderInlineStartStyle: t.borderStyles("borderInlineStartStyle"),
  borderRightWidth: t.borderWidths("borderRightWidth"),
  borderInlineEndWidth: t.borderWidths("borderInlineEndWidth"),
  borderRightColor: t.colors("borderRightColor"),
  borderInlineEndColor: t.colors("borderInlineEndColor"),
  borderRightStyle: t.borderStyles("borderRightStyle"),
  borderInlineEndStyle: t.borderStyles("borderInlineEndStyle"),
  borderTopRadius: t.radii(["borderTopLeftRadius", "borderTopRightRadius"]),
  borderBottomRadius: t.radii(["borderBottomLeftRadius", "borderBottomRightRadius"]),
  borderLeftRadius: t.radii(["borderTopLeftRadius", "borderBottomLeftRadius"]),
  borderRightRadius: t.radii(["borderTopRightRadius", "borderBottomRightRadius"])
};
Object.assign(border, {
  rounded: border.borderRadius,
  roundedTop: border.borderTopRadius,
  roundedTopLeft: border.borderTopLeftRadius,
  roundedTopRight: border.borderTopRightRadius,
  roundedTopStart: border.borderStartStartRadius,
  roundedTopEnd: border.borderStartEndRadius,
  roundedBottom: border.borderBottomRadius,
  roundedBottomLeft: border.borderBottomLeftRadius,
  roundedBottomRight: border.borderBottomRightRadius,
  roundedBottomStart: border.borderEndStartRadius,
  roundedBottomEnd: border.borderEndEndRadius,
  roundedLeft: border.borderLeftRadius,
  roundedRight: border.borderRightRadius,
  roundedStart: border.borderInlineStartRadius,
  roundedEnd: border.borderInlineEndRadius,
  borderStart: border.borderInlineStart,
  borderEnd: border.borderInlineEnd,
  borderTopStartRadius: border.borderStartStartRadius,
  borderTopEndRadius: border.borderStartEndRadius,
  borderBottomStartRadius: border.borderEndStartRadius,
  borderBottomEndRadius: border.borderEndEndRadius,
  borderStartRadius: border.borderInlineStartRadius,
  borderEndRadius: border.borderInlineEndRadius,
  borderStartWidth: border.borderInlineStartWidth,
  borderEndWidth: border.borderInlineEndWidth,
  borderStartColor: border.borderInlineStartColor,
  borderEndColor: border.borderInlineEndColor,
  borderStartStyle: border.borderInlineStartStyle,
  borderEndStyle: border.borderInlineEndStyle
});
/**
 * The prop types for border properties listed above
 */

var color = {
  color: t.colors("color"),
  textColor: t.colors("color"),
  fill: t.colors("fill"),
  stroke: t.colors("stroke")
};
var effect = {
  boxShadow: t.shadows("boxShadow"),
  mixBlendMode: true,
  blendMode: t.prop("mixBlendMode"),
  backgroundBlendMode: true,
  bgBlendMode: t.prop("backgroundBlendMode"),
  opacity: true
};
Object.assign(effect, {
  shadow: effect.boxShadow
});
/**
 * Types for box and text shadow properties
 */

var filter = {
  filter: {
    transform: transformFunctions.filter
  },
  blur: t.blur("--chakra-blur"),
  brightness: t.propT("--chakra-brightness", transformFunctions.brightness),
  contrast: t.propT("--chakra-contrast", transformFunctions.contrast),
  hueRotate: t.degreeT("--chakra-hue-rotate"),
  invert: t.propT("--chakra-invert", transformFunctions.invert),
  saturate: t.propT("--chakra-saturate", transformFunctions.saturate),
  dropShadow: t.propT("--chakra-drop-shadow", transformFunctions.dropShadow),
  backdropFilter: {
    transform: transformFunctions.backdropFilter
  },
  backdropBlur: t.blur("--chakra-backdrop-blur"),
  backdropBrightness: t.propT("--chakra-backdrop-brightness", transformFunctions.brightness),
  backdropContrast: t.propT("--chakra-backdrop-contrast", transformFunctions.contrast),
  backdropHueRotate: t.degreeT("--chakra-backdrop-hue-rotate"),
  backdropInvert: t.propT("--chakra-backdrop-invert", transformFunctions.invert),
  backdropSaturate: t.propT("--chakra-backdrop-saturate", transformFunctions.saturate)
};
var flexbox = {
  alignItems: true,
  alignContent: true,
  justifyItems: true,
  justifyContent: true,
  flexWrap: true,
  flexDirection: {
    transform: transformFunctions.flexDirection
  },
  experimental_spaceX: {
    "static": spaceXTemplate,
    transform: createTransform({
      scale: "space",
      transform: function transform(value) {
        return value !== null ? {
          "--chakra-space-x": value
        } : null;
      }
    })
  },
  experimental_spaceY: {
    "static": spaceYTemplate,
    transform: createTransform({
      scale: "space",
      transform: function transform(value) {
        return value != null ? {
          "--chakra-space-y": value
        } : null;
      }
    })
  },
  flex: true,
  flexFlow: true,
  flexGrow: true,
  flexShrink: true,
  flexBasis: t.sizes("flexBasis"),
  justifySelf: true,
  alignSelf: true,
  order: true,
  placeItems: true,
  placeContent: true,
  placeSelf: true,
  gap: t.space("gap"),
  rowGap: t.space("rowGap"),
  columnGap: t.space("columnGap")
};
Object.assign(flexbox, {
  flexDir: flexbox.flexDirection
});
var grid = {
  gridGap: t.space("gridGap"),
  gridColumnGap: t.space("gridColumnGap"),
  gridRowGap: t.space("gridRowGap"),
  gridColumn: true,
  gridRow: true,
  gridAutoFlow: true,
  gridAutoColumns: true,
  gridColumnStart: true,
  gridColumnEnd: true,
  gridRowStart: true,
  gridRowEnd: true,
  gridAutoRows: true,
  gridTemplate: true,
  gridTemplateColumns: true,
  gridTemplateRows: true,
  gridTemplateAreas: true,
  gridArea: true
};
var interactivity = {
  appearance: true,
  cursor: true,
  resize: true,
  userSelect: true,
  pointerEvents: true,
  outline: {
    transform: transformFunctions.outline
  },
  outlineOffset: true,
  outlineColor: t.colors("outlineColor")
};
var layout = {
  width: t.sizesT("width"),
  inlineSize: t.sizesT("inlineSize"),
  height: t.sizes("height"),
  blockSize: t.sizes("blockSize"),
  boxSize: t.sizes(["width", "height"]),
  minWidth: t.sizes("minWidth"),
  minInlineSize: t.sizes("minInlineSize"),
  minHeight: t.sizes("minHeight"),
  minBlockSize: t.sizes("minBlockSize"),
  maxWidth: t.sizes("maxWidth"),
  maxInlineSize: t.sizes("maxInlineSize"),
  maxHeight: t.sizes("maxHeight"),
  maxBlockSize: t.sizes("maxBlockSize"),
  d: t.prop("display"),
  overflow: true,
  overflowX: true,
  overflowY: true,
  overscrollBehavior: true,
  overscrollBehaviorX: true,
  overscrollBehaviorY: true,
  display: true,
  verticalAlign: true,
  boxSizing: true,
  boxDecorationBreak: true,
  "float": t.propT("float", transformFunctions["float"]),
  objectFit: true,
  objectPosition: true,
  visibility: true,
  isolation: true
};
Object.assign(layout, {
  w: layout.width,
  h: layout.height,
  minW: layout.minWidth,
  maxW: layout.maxWidth,
  minH: layout.minHeight,
  maxH: layout.maxHeight,
  overscroll: layout.overscrollBehavior,
  overscrollX: layout.overscrollBehaviorX,
  overscrollY: layout.overscrollBehaviorY
});
/**
 * Types for layout related CSS properties
 */

var list = {
  listStyleType: true,
  listStylePosition: true,
  listStylePos: t.prop("listStylePosition"),
  listStyleImage: true,
  listStyleImg: t.prop("listStyleImage")
};
var srOnly = {
  border: "0px",
  clip: "rect(0, 0, 0, 0)",
  width: "1px",
  height: "1px",
  margin: "-1px",
  padding: "0px",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
};
var srFocusable = {
  position: "static",
  width: "auto",
  height: "auto",
  clip: "auto",
  padding: "0",
  margin: "0",
  overflow: "visible",
  whiteSpace: "normal"
};

var getWithPriority = function getWithPriority(theme, key, styles) {
  var result = {};
  var obj = utils.memoizedGet(theme, key, {});

  for (var prop in obj) {
    var isInStyles = prop in styles && styles[prop] != null;
    if (!isInStyles) result[prop] = obj[prop];
  }

  return result;
};

var others = {
  srOnly: {
    transform: function transform(value) {
      if (value === true) return srOnly;
      if (value === "focusable") return srFocusable;
      return {};
    }
  },
  layerStyle: {
    processResult: true,
    transform: function transform(value, theme, styles) {
      return getWithPriority(theme, "layerStyles." + value, styles);
    }
  },
  textStyle: {
    processResult: true,
    transform: function transform(value, theme, styles) {
      return getWithPriority(theme, "textStyles." + value, styles);
    }
  },
  apply: {
    processResult: true,
    transform: function transform(value, theme, styles) {
      return getWithPriority(theme, value, styles);
    }
  }
};
var position = {
  position: true,
  pos: t.prop("position"),
  zIndex: t.prop("zIndex", "zIndices"),
  inset: t.spaceT("inset"),
  insetX: t.spaceT(["left", "right"]),
  insetInline: t.spaceT("insetInline"),
  insetY: t.spaceT(["top", "bottom"]),
  insetBlock: t.spaceT("insetBlock"),
  top: t.spaceT("top"),
  insetBlockStart: t.spaceT("insetBlockStart"),
  bottom: t.spaceT("bottom"),
  insetBlockEnd: t.spaceT("insetBlockEnd"),
  left: t.spaceT("left"),
  insetInlineStart: t.logical({
    scale: "space",
    property: {
      ltr: "left",
      rtl: "right"
    }
  }),
  right: t.spaceT("right"),
  insetInlineEnd: t.logical({
    scale: "space",
    property: {
      ltr: "right",
      rtl: "left"
    }
  })
};
Object.assign(position, {
  insetStart: position.insetInlineStart,
  insetEnd: position.insetInlineEnd
});
/**
 * Types for position CSS properties
 */

/**
 * The parser configuration for common outline properties
 */

var ring = {
  ring: {
    transform: transformFunctions.ring
  },
  ringColor: t.colors("--chakra-ring-color"),
  ringOffset: t.prop("--chakra-ring-offset-width"),
  ringOffsetColor: t.colors("--chakra-ring-offset-color"),
  ringInset: t.prop("--chakra-ring-inset")
};
var space = {
  margin: t.spaceT("margin"),
  marginTop: t.spaceT("marginTop"),
  marginBlockStart: t.spaceT("marginBlockStart"),
  marginRight: t.spaceT("marginRight"),
  marginInlineEnd: t.spaceT("marginInlineEnd"),
  marginBottom: t.spaceT("marginBottom"),
  marginBlockEnd: t.spaceT("marginBlockEnd"),
  marginLeft: t.spaceT("marginLeft"),
  marginInlineStart: t.spaceT("marginInlineStart"),
  marginX: t.spaceT(["marginInlineStart", "marginInlineEnd"]),
  marginInline: t.spaceT("marginInline"),
  marginY: t.spaceT(["marginTop", "marginBottom"]),
  marginBlock: t.spaceT("marginBlock"),
  padding: t.space("padding"),
  paddingTop: t.space("paddingTop"),
  paddingBlockStart: t.space("paddingBlockStart"),
  paddingRight: t.space("paddingRight"),
  paddingBottom: t.space("paddingBottom"),
  paddingBlockEnd: t.space("paddingBlockEnd"),
  paddingLeft: t.space("paddingLeft"),
  paddingInlineStart: t.space("paddingInlineStart"),
  paddingInlineEnd: t.space("paddingInlineEnd"),
  paddingX: t.space(["paddingInlineStart", "paddingInlineEnd"]),
  paddingInline: t.space("paddingInline"),
  paddingY: t.space(["paddingTop", "paddingBottom"]),
  paddingBlock: t.space("paddingBlock")
};
Object.assign(space, {
  m: space.margin,
  mt: space.marginTop,
  mr: space.marginRight,
  me: space.marginInlineEnd,
  marginEnd: space.marginInlineEnd,
  mb: space.marginBottom,
  ml: space.marginLeft,
  ms: space.marginInlineStart,
  marginStart: space.marginInlineStart,
  mx: space.marginX,
  my: space.marginY,
  p: space.padding,
  pt: space.paddingTop,
  py: space.paddingY,
  px: space.paddingX,
  pb: space.paddingBottom,
  pl: space.paddingLeft,
  ps: space.paddingInlineStart,
  paddingStart: space.paddingInlineStart,
  pr: space.paddingRight,
  pe: space.paddingInlineEnd,
  paddingEnd: space.paddingInlineEnd
});
/**
 * Types for space related CSS properties
 */

var textDecoration = {
  textDecorationColor: t.colors("textDecorationColor"),
  textDecoration: true,
  textDecor: {
    property: "textDecoration"
  },
  textDecorationLine: true,
  textDecorationStyle: true,
  textDecorationThickness: true,
  textUnderlineOffset: true,
  textShadow: t.shadows("textShadow")
};
var transform = {
  clipPath: true,
  transform: t.propT("transform", transformFunctions.transform),
  transformOrigin: true,
  translateX: t.spaceT("--chakra-translate-x"),
  translateY: t.spaceT("--chakra-translate-y"),
  skewX: t.degreeT("--chakra-skew-x"),
  skewY: t.degreeT("--chakra-skew-y"),
  scaleX: t.prop("--chakra-scale-x"),
  scaleY: t.prop("--chakra-scale-y"),
  scale: t.prop(["--chakra-scale-x", "--chakra-scale-y"]),
  rotate: t.degreeT("--chakra-rotate")
};
var transition = {
  transition: true,
  transitionDelay: true,
  animation: true,
  willChange: true,
  transitionDuration: t.prop("transitionDuration", "transition.duration"),
  transitionProperty: t.prop("transitionProperty", "transition.property"),
  transitionTimingFunction: t.prop("transitionTimingFunction", "transition.easing")
};
var typography = {
  fontFamily: t.prop("fontFamily", "fonts"),
  fontSize: t.prop("fontSize", "fontSizes", transformFunctions.px),
  fontWeight: t.prop("fontWeight", "fontWeights"),
  lineHeight: t.prop("lineHeight", "lineHeights"),
  letterSpacing: t.prop("letterSpacing", "letterSpacings"),
  textAlign: true,
  fontStyle: true,
  wordBreak: true,
  overflowWrap: true,
  textOverflow: true,
  textTransform: true,
  whiteSpace: true,
  noOfLines: {
    "static": {
      overflow: "hidden",
      textOverflow: "ellipsis",
      display: "-webkit-box",
      WebkitBoxOrient: "vertical",
      //@ts-ignore
      WebkitLineClamp: "var(--chakra-line-clamp)"
    },
    property: "--chakra-line-clamp"
  },
  isTruncated: {
    transform: function transform(value) {
      if (value === true) {
        return {
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap"
        };
      }
    }
  }
};
/**
 * Types for typography related CSS properties
 */

var scroll = {
  scrollBehavior: true,
  scrollSnapAlign: true,
  scrollSnapStop: true,
  scrollSnapType: true,
  // scroll margin
  scrollMargin: t.spaceT("scrollMargin"),
  scrollMarginTop: t.spaceT("scrollMarginTop"),
  scrollMarginBottom: t.spaceT("scrollMarginBottom"),
  scrollMarginLeft: t.spaceT("scrollMarginLeft"),
  scrollMarginRight: t.spaceT("scrollMarginRight"),
  scrollMarginX: t.spaceT(["scrollMarginLeft", "scrollMarginRight"]),
  scrollMarginY: t.spaceT(["scrollMarginTop", "scrollMarginBottom"]),
  // scroll padding
  scrollPadding: t.spaceT("scrollPadding"),
  scrollPaddingTop: t.spaceT("scrollPaddingTop"),
  scrollPaddingBottom: t.spaceT("scrollPaddingBottom"),
  scrollPaddingLeft: t.spaceT("scrollPaddingLeft"),
  scrollPaddingRight: t.spaceT("scrollPaddingRight"),
  scrollPaddingX: t.spaceT(["scrollPaddingLeft", "scrollPaddingRight"]),
  scrollPaddingY: t.spaceT(["scrollPaddingTop", "scrollPaddingBottom"])
};

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var state = {
  hover: function hover(str, post) {
    return str + ":hover " + post + ", " + str + "[data-hover] " + post;
  },
  focus: function focus(str, post) {
    return str + ":focus " + post + ", " + str + "[data-focus] " + post;
  },
  focusVisible: function focusVisible(str, post) {
    return str + ":focus-visible " + post;
  },
  focusWithin: function focusWithin(str, post) {
    return str + ":focus-within " + post;
  },
  active: function active(str, post) {
    return str + ":active " + post + ", " + str + "[data-active] " + post;
  },
  disabled: function disabled(str, post) {
    return str + ":disabled " + post + ", " + str + "[data-disabled] " + post;
  },
  invalid: function invalid(str, post) {
    return str + ":invalid " + post + ", " + str + "[data-invalid] " + post;
  },
  checked: function checked(str, post) {
    return str + ":checked " + post + ", " + str + "[data-checked] " + post;
  },
  indeterminate: function indeterminate(str, post) {
    return str + ":indeterminate " + post + ", " + str + "[aria-checked=mixed] " + post + ", " + str + "[data-indeterminate] " + post;
  },
  readOnly: function readOnly(str, post) {
    return str + ":read-only " + post + ", " + str + "[readonly] " + post + ", " + str + "[data-read-only] " + post;
  },
  expanded: function expanded(str, post) {
    return str + ":read-only " + post + ", " + str + "[aria-expanded=true] " + post + ", " + str + "[data-expanded] " + post;
  },
  placeholderShown: function placeholderShown(str, post) {
    return str + ":placeholder-shown " + post;
  }
};

var toGroup = function toGroup(fn) {
  return merge(function (v) {
    return fn(v, "&");
  }, "[role=group]", "[data-group]", ".group");
};

var toPeer = function toPeer(fn) {
  return merge(function (v) {
    return fn(v, "~ &");
  }, "[data-peer]", ".peer");
};

var merge = function merge(fn) {
  for (var _len = arguments.length, selectors = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    selectors[_key - 1] = arguments[_key];
  }

  return selectors.map(fn).join(", ");
};

var pseudoSelectors = {
  /**
   * Styles for CSS selector `&:hover`
   */
  _hover: "&:hover, &[data-hover]",

  /**
   * Styles for CSS Selector `&:active`
   */
  _active: "&:active, &[data-active]",

  /**
   * Styles for CSS selector `&:focus`
   *
   */
  _focus: "&:focus, &[data-focus]",

  /**
   * Styles for the highlighted state.
   */
  _highlighted: "&[data-highlighted]",

  /**
   * Styles to apply when a child of this element has received focus
   * - CSS Selector `&:focus-within`
   */
  _focusWithin: "&:focus-within",

  /**
   * Styles to apply when this element has received focus via tabbing
   * - CSS Selector `&:focus-visible`
   */
  _focusVisible: "&:focus-visible",

  /**
   * Styles to apply when this element is disabled. The passed styles are applied to these CSS selectors:
   * - `&[aria-disabled=true]`
   * - `&:disabled`
   * - `&[data-disabled]`
   */
  _disabled: "&[disabled], &[aria-disabled=true], &[data-disabled]",

  /**
   * Styles for CSS Selector `&:readonly`
   */
  _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",

  /**
   * Styles for CSS selector `&::before`
   *
   * NOTE:When using this, ensure the `content` is wrapped in a backtick.
   * @example
   * ```jsx
   * <Box _before={{content:`""` }}/>
   * ```
   */
  _before: "&::before",

  /**
   * Styles for CSS selector `&::after`
   *
   * NOTE:When using this, ensure the `content` is wrapped in a backtick.
   * @example
   * ```jsx
   * <Box _after={{content:`""` }}/>
   * ```
   */
  _after: "&::after",

  /**
   * Styles for CSS selector `&:empty`
   */
  _empty: "&:empty",

  /**
   * Styles to apply when the ARIA attribute `aria-expanded` is `true`
   * - CSS selector `&[aria-expanded=true]`
   */
  _expanded: "&[aria-expanded=true], &[data-expanded]",

  /**
   * Styles to apply when the ARIA attribute `aria-checked` is `true`
   * - CSS selector `&[aria-checked=true]`
   */
  _checked: "&[aria-checked=true], &[data-checked]",

  /**
   * Styles to apply when the ARIA attribute `aria-grabbed` is `true`
   * - CSS selector `&[aria-grabbed=true]`
   */
  _grabbed: "&[aria-grabbed=true], &[data-grabbed]",

  /**
   * Styles for CSS Selector `&[aria-pressed=true]`
   * Typically used to style the current "pressed" state of toggle buttons
   */
  _pressed: "&[aria-pressed=true], &[data-pressed]",

  /**
   * Styles to apply when the ARIA attribute `aria-invalid` is `true`
   * - CSS selector `&[aria-invalid=true]`
   */
  _invalid: "&[aria-invalid=true], &[data-invalid]",

  /**
   * Styles for the valid state
   * - CSS selector `&[data-valid], &[data-state=valid]`
   */
  _valid: "&[data-valid], &[data-state=valid]",

  /**
   * Styles for CSS Selector `&[aria-busy=true]` or `&[data-loading=true]`.
   * Useful for styling loading states
   */
  _loading: "&[data-loading], &[aria-busy=true]",

  /**
   * Styles to apply when the ARIA attribute `aria-selected` is `true`
   *
   * - CSS selector `&[aria-selected=true]`
   */
  _selected: "&[aria-selected=true], &[data-selected]",

  /**
   * Styles for CSS Selector `[hidden=true]`
   */
  _hidden: "&[hidden], &[data-hidden]",

  /**
   * Styles for CSS Selector `&:-webkit-autofill`
   */
  _autofill: "&:-webkit-autofill",

  /**
   * Styles for CSS Selector `&:nth-child(even)`
   */
  _even: "&:nth-of-type(even)",

  /**
   * Styles for CSS Selector `&:nth-child(odd)`
   */
  _odd: "&:nth-of-type(odd)",

  /**
   * Styles for CSS Selector `&:first-of-type`
   */
  _first: "&:first-of-type",

  /**
   * Styles for CSS Selector `&:last-of-type`
   */
  _last: "&:last-of-type",

  /**
   * Styles for CSS Selector `&:not(:first-of-type)`
   */
  _notFirst: "&:not(:first-of-type)",

  /**
   * Styles for CSS Selector `&:not(:last-of-type)`
   */
  _notLast: "&:not(:last-of-type)",

  /**
   * Styles for CSS Selector `&:visited`
   */
  _visited: "&:visited",

  /**
   * Used to style the active link in a navigation
   * Styles for CSS Selector `&[aria-current=page]`
   */
  _activeLink: "&[aria-current=page]",

  /**
   * Used to style the current step within a process
   * Styles for CSS Selector `&[aria-current=step]`
   */
  _activeStep: "&[aria-current=step]",

  /**
   * Styles to apply when the ARIA attribute `aria-checked` is `mixed`
   * - CSS selector `&[aria-checked=mixed]`
   */
  _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate]",

  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is hovered
   */
  _groupHover: toGroup(state.hover),

  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is hovered
   */
  _peerHover: toPeer(state.hover),

  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is focused
   */
  _groupFocus: toGroup(state.focus),

  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is focused
   */
  _peerFocus: toPeer(state.focus),

  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` has visible focus
   */
  _groupFocusVisible: toGroup(state.focusVisible),

  /**
   * Styles to apply when a sibling element with `.peer`or `data-peer` has visible focus
   */
  _peerFocusVisible: toPeer(state.focusVisible),

  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is active
   */
  _groupActive: toGroup(state.active),

  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is active
   */
  _peerActive: toPeer(state.active),

  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is disabled
   */
  _groupDisabled: toGroup(state.disabled),

  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` is disabled
   */
  _peerDisabled: toPeer(state.disabled),

  /**
   *  Styles to apply when a parent element with `.group`, `data-group` or `role=group` is invalid
   */
  _groupInvalid: toGroup(state.invalid),

  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` is invalid
   */
  _peerInvalid: toPeer(state.invalid),

  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is checked
   */
  _groupChecked: toGroup(state.checked),

  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is checked
   */
  _peerChecked: toPeer(state.checked),

  /**
   *  Styles to apply when a parent element with `.group`, `data-group` or `role=group` has focus within
   */
  _groupFocusWithin: toGroup(state.focusWithin),

  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` has focus within
   */
  _peerFocusWithin: toPeer(state.focusWithin),

  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` has placeholder shown
   */
  _peerPlaceholderShown: toPeer(state.placeholderShown),

  /**
   * Styles for CSS Selector `&::placeholder`.
   */
  _placeholder: "&::placeholder",

  /**
   * Styles for CSS Selector `&:placeholder-shown`.
   */
  _placeholderShown: "&:placeholder-shown",

  /**
   * Styles for CSS Selector `&:fullscreen`.
   */
  _fullScreen: "&:fullscreen",

  /**
   * Styles for CSS Selector `&::selection`
   */
  _selection: "&::selection",

  /**
   * Styles for CSS Selector `[dir=rtl] &`
   * It is applied when a parent element or this element has `dir="rtl"`
   */
  _rtl: "[dir=rtl] &, &[dir=rtl]",

  /**
   * Styles for CSS Selector `[dir=ltr] &`
   * It is applied when a parent element or this element has `dir="ltr"`
   */
  _ltr: "[dir=ltr] &, &[dir=ltr]",

  /**
   * Styles for CSS Selector `@media (prefers-color-scheme: dark)`
   * It is used when the user has requested the system use a light or dark color theme.
   */
  _mediaDark: "@media (prefers-color-scheme: dark)",

  /**
   * Styles for CSS Selector `@media (prefers-reduced-motion: reduce)`
   * It is used when the user has requested the system to reduce the amount of animations.
   */
  _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",

  /**
   * Styles for when `data-theme` is applied to any parent of
   * this component or element.
   */
  _dark: ".chakra-ui-dark &:not([data-theme])," + "[data-theme=dark] &:not([data-theme])," + "&[data-theme=dark]",

  /**
   * Styles for when `data-theme` is applied to any parent of
   * this component or element.
   */
  _light: ".chakra-ui-light &:not([data-theme])," + "[data-theme=light] &:not([data-theme])," + "&[data-theme=light]"
};
var pseudoPropNames = utils.objectKeys(pseudoSelectors);
var systemProps = utils.mergeWith({}, background, border, color, flexbox, layout, filter, ring, interactivity, grid, others, position, effect, space, scroll, typography, textDecoration, transform, list, transition);
var layoutSystem = Object.assign({}, space, layout, flexbox, grid, position);
var layoutPropNames = utils.objectKeys(layoutSystem);
var propNames = [].concat(utils.objectKeys(systemProps), pseudoPropNames);

var styleProps = _extends({}, systemProps, pseudoSelectors);

var isStyleProp = function isStyleProp(prop) {
  return prop in styleProps;
};
/**
 * Expands an array or object syntax responsive style.
 *
 * @example
 * expandResponsive({ mx: [1, 2] })
 * // or
 * expandResponsive({ mx: { base: 1, sm: 2 } })
 *
 * // => { mx: 1, "@media(min-width:<sm>)": { mx: 2 } }
 */


var expandResponsive = function expandResponsive(styles) {
  return function (theme) {
    /**
     * Before any style can be processed, the user needs to call `toCSSVar`
     * which analyzes the theme's breakpoint and appends a `__breakpoints` property
     * to the theme with more details of the breakpoints.
     *
     * To learn more, go here: packages/utils/src/responsive.ts #analyzeBreakpoints
     */
    if (!theme.__breakpoints) return styles;
    var _theme$__breakpoints = theme.__breakpoints,
        isResponsive = _theme$__breakpoints.isResponsive,
        toArrayValue = _theme$__breakpoints.toArrayValue,
        medias = _theme$__breakpoints.media;
    var computedStyles = {};

    for (var key in styles) {
      var value = utils.runIfFn(styles[key], theme);
      if (value == null) continue; // converts the object responsive syntax to array syntax

      value = utils.isObject(value) && isResponsive(value) ? toArrayValue(value) : value;

      if (!Array.isArray(value)) {
        computedStyles[key] = value;
        continue;
      }

      var queries = value.slice(0, medias.length).length;

      for (var index = 0; index < queries; index += 1) {
        var media = medias == null ? void 0 : medias[index];

        if (!media) {
          computedStyles[key] = value[index];
          continue;
        }

        computedStyles[media] = computedStyles[media] || {};

        if (value[index] == null) {
          continue;
        }

        computedStyles[media][key] = value[index];
      }
    }

    return computedStyles;
  };
};

var isCSSVariableTokenValue = function isCSSVariableTokenValue(key, value) {
  return key.startsWith("--") && utils.isString(value) && !utils.isCssVar(value);
};

var resolveTokenValue = function resolveTokenValue(theme, value) {
  var _ref, _getVar2;

  if (value == null) return value;

  var getVar = function getVar(val) {
    var _theme$__cssMap, _theme$__cssMap$val;

    return (_theme$__cssMap = theme.__cssMap) == null ? void 0 : (_theme$__cssMap$val = _theme$__cssMap[val]) == null ? void 0 : _theme$__cssMap$val.varRef;
  };

  var getValue = function getValue(val) {
    var _getVar;

    return (_getVar = getVar(val)) != null ? _getVar : val;
  };

  var valueSplit = value.split(",").map(function (v) {
    return v.trim();
  });
  var tokenValue = valueSplit[0],
      fallbackValue = valueSplit[1];
  value = (_ref = (_getVar2 = getVar(tokenValue)) != null ? _getVar2 : getValue(fallbackValue)) != null ? _ref : getValue(value);
  return value;
};

function getCss(options) {
  var _options$configs = options.configs,
      configs = _options$configs === void 0 ? {} : _options$configs,
      _options$pseudos = options.pseudos,
      pseudos = _options$pseudos === void 0 ? {} : _options$pseudos,
      theme = options.theme;

  var css = function css(stylesOrFn, nested) {
    if (nested === void 0) {
      nested = false;
    }

    var _styles = utils.runIfFn(stylesOrFn, theme);

    var styles = expandResponsive(_styles)(theme);
    var computedStyles = {};

    for (var key in styles) {
      var _config$transform, _config, _config2, _config3, _config4;

      var valueOrFn = styles[key];
      /**
       * allows the user to pass functional values
       * boxShadow: theme => `0 2px 2px ${theme.colors.red}`
       */

      var value = utils.runIfFn(valueOrFn, theme);
      /**
       * converts pseudo shorthands to valid selector
       * "_hover" => "&:hover"
       */

      if (key in pseudos) {
        key = pseudos[key];
      }
      /**
       * allows the user to use theme tokens in css vars
       * { --banner-height: "sizes.md" } => { --banner-height: "var(--chakra-sizes-md)" }
       *
       * You can also provide fallback values
       * { --banner-height: "sizes.no-exist, 40px" } => { --banner-height: "40px" }
       */


      if (isCSSVariableTokenValue(key, value)) {
        value = resolveTokenValue(theme, value);
      }

      var config = configs[key];

      if (config === true) {
        config = {
          property: key
        };
      }

      if (utils.isObject(value)) {
        var _computedStyles$key;

        computedStyles[key] = (_computedStyles$key = computedStyles[key]) != null ? _computedStyles$key : {};
        computedStyles[key] = utils.mergeWith({}, computedStyles[key], css(value, true));
        continue;
      }

      var rawValue = (_config$transform = (_config = config) == null ? void 0 : _config.transform == null ? void 0 : _config.transform(value, theme, _styles)) != null ? _config$transform : value;
      /**
       * Used for `layerStyle`, `textStyle` and `apply`. After getting the
       * styles in the theme, we need to process them since they might
       * contain theme tokens.
       *
       * `processResult` is the config property we pass to `layerStyle`, `textStyle` and `apply`
       */

      rawValue = (_config2 = config) != null && _config2.processResult ? css(rawValue, true) : rawValue;
      /**
       * allows us define css properties for RTL and LTR.
       *
       * const marginStart = {
       *   property: theme => theme.direction === "rtl" ? "marginRight": "marginLeft",
       * }
       */

      var configProperty = utils.runIfFn((_config3 = config) == null ? void 0 : _config3.property, theme);

      if (!nested && (_config4 = config) != null && _config4["static"]) {
        var staticStyles = utils.runIfFn(config["static"], theme);
        computedStyles = utils.mergeWith({}, computedStyles, staticStyles);
      }

      if (configProperty && Array.isArray(configProperty)) {
        for (var _iterator = _createForOfIteratorHelperLoose(configProperty), _step; !(_step = _iterator()).done;) {
          var property = _step.value;
          computedStyles[property] = rawValue;
        }

        continue;
      }

      if (configProperty) {
        if (configProperty === "&" && utils.isObject(rawValue)) {
          computedStyles = utils.mergeWith({}, computedStyles, rawValue);
        } else {
          computedStyles[configProperty] = rawValue;
        }

        continue;
      }

      if (utils.isObject(rawValue)) {
        computedStyles = utils.mergeWith({}, computedStyles, rawValue);
        continue;
      }

      computedStyles[key] = rawValue;
    }

    return computedStyles;
  };

  return css;
}

var css = function css(styles) {
  return function (theme) {
    var cssFn = getCss({
      theme: theme,
      pseudos: pseudoSelectors,
      configs: systemProps
    });
    return cssFn(styles);
  };
};
/**
 * Thank you @markdalgleish for this piece of art!
 */


function resolveReference(operand) {
  if (utils.isObject(operand) && operand.reference) {
    return operand.reference;
  }

  return String(operand);
}

var toExpression = function toExpression(operator) {
  for (var _len = arguments.length, operands = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    operands[_key - 1] = arguments[_key];
  }

  return operands.map(resolveReference).join(" " + operator + " ").replace(/calc/g, "");
};

var _add = function add() {
  for (var _len2 = arguments.length, operands = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    operands[_key2] = arguments[_key2];
  }

  return "calc(" + toExpression.apply(void 0, ["+"].concat(operands)) + ")";
};

var _subtract = function subtract() {
  for (var _len3 = arguments.length, operands = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    operands[_key3] = arguments[_key3];
  }

  return "calc(" + toExpression.apply(void 0, ["-"].concat(operands)) + ")";
};

var _multiply = function multiply() {
  for (var _len4 = arguments.length, operands = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    operands[_key4] = arguments[_key4];
  }

  return "calc(" + toExpression.apply(void 0, ["*"].concat(operands)) + ")";
};

var _divide = function divide() {
  for (var _len5 = arguments.length, operands = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    operands[_key5] = arguments[_key5];
  }

  return "calc(" + toExpression.apply(void 0, ["/"].concat(operands)) + ")";
};

var _negate = function negate(x) {
  var value = resolveReference(x);

  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : "-" + value;
  }

  return _multiply(value, -1);
};

var calc = Object.assign(function (x) {
  return {
    add: function add() {
      for (var _len6 = arguments.length, operands = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        operands[_key6] = arguments[_key6];
      }

      return calc(_add.apply(void 0, [x].concat(operands)));
    },
    subtract: function subtract() {
      for (var _len7 = arguments.length, operands = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        operands[_key7] = arguments[_key7];
      }

      return calc(_subtract.apply(void 0, [x].concat(operands)));
    },
    multiply: function multiply() {
      for (var _len8 = arguments.length, operands = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        operands[_key8] = arguments[_key8];
      }

      return calc(_multiply.apply(void 0, [x].concat(operands)));
    },
    divide: function divide() {
      for (var _len9 = arguments.length, operands = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        operands[_key9] = arguments[_key9];
      }

      return calc(_divide.apply(void 0, [x].concat(operands)));
    },
    negate: function negate() {
      return calc(_negate(x));
    },
    toString: function toString() {
      return x.toString();
    }
  };
}, {
  add: _add,
  subtract: _subtract,
  multiply: _multiply,
  divide: _divide,
  negate: _negate
});

function replaceWhiteSpace(value, replaceValue) {
  if (replaceValue === void 0) {
    replaceValue = "-";
  }

  return value.replace(/\s+/g, replaceValue);
}

function escape(value) {
  var valueStr = replaceWhiteSpace(value.toString());
  if (valueStr.includes("\\.")) return value;
  var isDecimal = !Number.isInteger(parseFloat(value.toString()));
  return isDecimal ? valueStr.replace(".", "\\.") : value;
}

function addPrefix(value, prefix) {
  if (prefix === void 0) {
    prefix = "";
  }

  return [prefix, escape(value)].filter(Boolean).join("-");
}

function toVarReference(name, fallback) {
  return "var(" + escape(name) + (fallback ? ", " + fallback : "") + ")";
}

function toVarDefinition(value, prefix) {
  if (prefix === void 0) {
    prefix = "";
  }

  return "--" + addPrefix(value, prefix);
}

function cssVar(name, fallback, cssVarPrefix) {
  var cssVariable = toVarDefinition(name, cssVarPrefix);
  return {
    variable: cssVariable,
    reference: toVarReference(cssVariable, fallback)
  };
}
/**
 * Convert a token name to a css variable
 *
 * @example
 * tokenToCssVar('colors.red.500', 'chakra')
 * => {
 *   variable: '--chakra-colors-red-500',
 *   reference: 'var(--chakra-colors-red-500)'
 * }
 */


function tokenToCssVar(token, prefix) {
  return cssVar(String(token).replace(/\./g, "-"), undefined, prefix);
}

function createThemeVars(flatTokens, options) {
  var cssVars = {};
  var cssMap = {};

  var _loop = function _loop() {
    var _Object$entries$_i = _Object$entries[_i],
        token = _Object$entries$_i[0],
        tokenValue = _Object$entries$_i[1];
    var isSemantic = tokenValue.isSemantic,
        value = tokenValue.value;

    var _tokenToCssVar = tokenToCssVar(token, options == null ? void 0 : options.cssVarPrefix),
        variable = _tokenToCssVar.variable,
        reference = _tokenToCssVar.reference;

    if (!isSemantic) {
      if (token.startsWith("space")) {
        var keys = token.split(".");
        var firstKey = keys[0],
            referenceKeys = keys.slice(1);
        /** @example space.-4 */

        var negativeLookupKey = firstKey + ".-" + referenceKeys.join(".");
        var negativeValue = calc.negate(value);
        var negatedReference = calc.negate(reference);
        cssMap[negativeLookupKey] = {
          value: negativeValue,
          "var": variable,
          varRef: negatedReference
        };
      }

      cssVars[variable] = value;
      cssMap[token] = {
        value: value,
        "var": variable,
        varRef: reference
      };
      return "continue";
    }

    var lookupToken = function lookupToken(maybeToken) {
      var scale = String(token).split(".")[0];
      var withScale = [scale, maybeToken].join(".");
      /** @example flatTokens['space.4'] === '16px' */

      var resolvedTokenValue = flatTokens[withScale];
      if (!resolvedTokenValue) return maybeToken;

      var _tokenToCssVar2 = tokenToCssVar(withScale, options == null ? void 0 : options.cssVarPrefix),
          reference = _tokenToCssVar2.reference;

      return reference;
    };

    var normalizedValue = utils.isObject(value) ? value : {
      "default": value
    };
    cssVars = utils.mergeWith(cssVars, Object.entries(normalizedValue).reduce(function (acc, _ref) {
      var _pseudoSelectors$cond, _acc$conditionSelecto;

      var conditionAlias = _ref[0],
          conditionValue = _ref[1];
      var maybeReference = lookupToken(conditionValue);

      if (conditionAlias === "default") {
        acc[variable] = maybeReference;
        return acc;
      }
      /** @example { _dark: "#fff" } => { '.chakra-ui-dark': "#fff" } */


      var conditionSelector = (_pseudoSelectors$cond = pseudoSelectors == null ? void 0 : pseudoSelectors[conditionAlias]) != null ? _pseudoSelectors$cond : conditionAlias;
      acc[conditionSelector] = (_acc$conditionSelecto = {}, _acc$conditionSelecto[variable] = maybeReference, _acc$conditionSelecto);
      return acc;
    }, {}));
    cssMap[token] = {
      value: reference,
      "var": variable,
      varRef: reference
    };
  };

  for (var _i = 0, _Object$entries = Object.entries(flatTokens); _i < _Object$entries.length; _i++) {
    var _ret = _loop();

    if (_ret === "continue") continue;
  }

  return {
    cssVars: cssVars,
    cssMap: cssMap
  };
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var _excluded = ["__cssMap", "__cssVars", "__breakpoints"];
var tokens = ["colors", "borders", "borderWidths", "borderStyles", "fonts", "fontSizes", "fontWeights", "letterSpacings", "lineHeights", "radii", "space", "shadows", "sizes", "zIndices", "transition", "blur"];

function extractTokens(theme) {
  var _tokens = tokens;
  return utils.pick(theme, _tokens);
}

function extractSemanticTokens(theme) {
  return theme.semanticTokens;
}

function omitVars(rawTheme) {
  rawTheme.__cssMap;
  rawTheme.__cssVars;
  rawTheme.__breakpoints;

  var cleanTheme = _objectWithoutPropertiesLoose(rawTheme, _excluded);

  return cleanTheme;
}

function flattenTokens(_ref) {
  var _flatten, _flatten2;

  var tokens = _ref.tokens,
      semanticTokens = _ref.semanticTokens;
  var tokenEntries = Object.entries((_flatten = utils.flatten(tokens)) != null ? _flatten : {}).map(function (_ref2) {
    var token = _ref2[0],
        value = _ref2[1];
    var enhancedToken = {
      isSemantic: false,
      value: value
    };
    return [token, enhancedToken];
  });
  var semanticTokenEntries = Object.entries((_flatten2 = utils.flatten(semanticTokens, 1)) != null ? _flatten2 : {}).map(function (_ref3) {
    var token = _ref3[0],
        value = _ref3[1];
    var enhancedToken = {
      isSemantic: true,
      value: value
    };
    return [token, enhancedToken];
  });
  return utils.fromEntries([].concat(tokenEntries, semanticTokenEntries));
}

function toCSSVar(rawTheme) {
  var _theme$config;
  /**
   * In the case the theme has already been converted to css-var (e.g extending the theme),
   * we can omit the computed css vars and recompute it for the extended theme.
   */


  var theme = omitVars(rawTheme); // omit components and breakpoints from css variable map

  var tokens = extractTokens(theme);
  var semanticTokens = extractSemanticTokens(theme);
  var flatTokens = flattenTokens({
    tokens: tokens,
    semanticTokens: semanticTokens
  });
  var cssVarPrefix = (_theme$config = theme.config) == null ? void 0 : _theme$config.cssVarPrefix;

  var _createThemeVars = createThemeVars(flatTokens, {
    cssVarPrefix: cssVarPrefix
  }),
      cssMap = _createThemeVars.cssMap,
      cssVars = _createThemeVars.cssVars;

  var defaultCssVars = {
    "--chakra-ring-inset": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-ring-offset-width": "0px",
    "--chakra-ring-offset-color": "#fff",
    "--chakra-ring-color": "rgba(66, 153, 225, 0.6)",
    "--chakra-ring-offset-shadow": "0 0 #0000",
    "--chakra-ring-shadow": "0 0 #0000",
    "--chakra-space-x-reverse": "0",
    "--chakra-space-y-reverse": "0"
  };
  Object.assign(theme, {
    __cssVars: _extends({}, defaultCssVars, cssVars),
    __cssMap: cssMap,
    __breakpoints: utils.analyzeBreakpoints(theme.breakpoints)
  });
  return theme;
}

exports.addPrefix = addPrefix;
exports.background = background;
exports.border = border;
exports.calc = calc;
exports.color = color;
exports.css = css;
exports.cssVar = cssVar;
exports.effect = effect;
exports.filter = filter;
exports.flattenTokens = flattenTokens;
exports.flexbox = flexbox;
exports.getCss = getCss;
exports.grid = grid;
exports.interactivity = interactivity;
exports.isStyleProp = isStyleProp;
exports.layout = layout;
exports.layoutPropNames = layoutPropNames;
exports.list = list;
exports.others = others;
exports.position = position;
exports.propNames = propNames;
exports.pseudoPropNames = pseudoPropNames;
exports.pseudoSelectors = pseudoSelectors;
exports.ring = ring;
exports.scroll = scroll;
exports.space = space;
exports.systemProps = systemProps;
exports.textDecoration = textDecoration;
exports.toCSSVar = toCSSVar;
exports.toVarDefinition = toVarDefinition;
exports.toVarReference = toVarReference;
exports.tokenToCSSVar = tokenToCSSVar;
exports.transform = transform;
exports.transition = transition;
exports.typography = typography;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(24);

__webpack_require__(28);

__webpack_require__(29);

__webpack_require__(30);

__webpack_require__(31);

__webpack_require__(32);

__webpack_require__(33);

__webpack_require__(34);

__webpack_require__(35);

__webpack_require__(36);

__webpack_require__(37);

__webpack_require__(38);

__webpack_require__(39);

__webpack_require__(40);

__webpack_require__(41);

__webpack_require__(42);

__webpack_require__(43);

__webpack_require__(44);

__webpack_require__(45);

__webpack_require__(46);

__webpack_require__(47);

__webpack_require__(48);

__webpack_require__(49);

__webpack_require__(50);

__webpack_require__(51);

__webpack_require__(52);

__webpack_require__(53);

__webpack_require__(54);

__webpack_require__(55);

__webpack_require__(56);

Object.defineProperty(exports, '__esModule', {
  value: true
});

var cssBoxModel = __webpack_require__(160);

var lodash_mergewith = __webpack_require__(161);

var sync = __webpack_require__(162);

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

var lodash_mergewith__default = /*#__PURE__*/_interopDefault(lodash_mergewith);

var sync__default = /*#__PURE__*/_interopDefault(sync);

function getFirstItem(array) {
  return array != null && array.length ? array[0] : undefined;
}

function getLastItem(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

function getPrevItem(index, array, loop) {
  if (loop === void 0) {
    loop = true;
  }

  var prevIndex = getPrevIndex(index, array.length, loop);
  return array[prevIndex];
}

function getNextItem(index, array, loop) {
  if (loop === void 0) {
    loop = true;
  }

  var nextIndex = getNextIndex(index, array.length, 1, loop);
  return array[nextIndex];
}

function removeIndex(array, index) {
  return array.filter(function (_, idx) {
    return idx !== index;
  });
}

function addItem(array, item) {
  return [].concat(array, [item]);
}

function removeItem(array, item) {
  return array.filter(function (eachItem) {
    return eachItem !== item;
  });
}
/**
 * Get the next index based on the current index and step.
 *
 * @param currentIndex the current index
 * @param length the total length or count of items
 * @param step the number of steps
 * @param loop whether to circle back once `currentIndex` is at the start/end
 */


function getNextIndex(currentIndex, length, step, loop) {
  if (step === void 0) {
    step = 1;
  }

  if (loop === void 0) {
    loop = true;
  }

  var lastIndex = length - 1;

  if (currentIndex === -1) {
    return step > 0 ? 0 : lastIndex;
  }

  var nextIndex = currentIndex + step;

  if (nextIndex < 0) {
    return loop ? lastIndex : 0;
  }

  if (nextIndex >= length) {
    if (loop) return 0;
    return currentIndex > length ? length : currentIndex;
  }

  return nextIndex;
}
/**
 * Get's the previous index based on the current index.
 * Mostly used for keyboard navigation.
 *
 * @param index - the current index
 * @param count - the length or total count of items in the array
 * @param loop - whether we should circle back to the
 * first/last once `currentIndex` is at the start/end
 */


function getPrevIndex(index, count, loop) {
  if (loop === void 0) {
    loop = true;
  }

  return getNextIndex(index, count, -1, loop);
}
/**
 * Converts an array into smaller chunks or groups.
 *
 * @param array the array to chunk into group
 * @param size the length of each chunk
 */


function chunk(array, size) {
  return array.reduce(function (rows, currentValue, index) {
    if (index % size === 0) {
      rows.push([currentValue]);
    } else {
      rows[rows.length - 1].push(currentValue);
    }

    return rows;
  }, []);
}
/**
 * Gets the next item based on a search string
 *
 * @param items array of items
 * @param searchString the search string
 * @param itemToString resolves an item to string
 * @param currentItem the current selected item
 */


function getNextItemFromSearch(items, searchString, itemToString, currentItem) {
  if (searchString == null) {
    return currentItem;
  } // If current item doesn't exist, find the item that matches the search string


  if (!currentItem) {
    var foundItem = items.find(function (item) {
      return itemToString(item).toLowerCase().startsWith(searchString.toLowerCase());
    });
    return foundItem;
  } // Filter items for ones that match the search string (case insensitive)


  var matchingItems = items.filter(function (item) {
    return itemToString(item).toLowerCase().startsWith(searchString.toLowerCase());
  }); // If there's a match, let's get the next item to select

  if (matchingItems.length > 0) {
    var nextIndex; // If the currentItem is in the available items, we move to the next available option

    if (matchingItems.includes(currentItem)) {
      var currentIndex = matchingItems.indexOf(currentItem);
      nextIndex = currentIndex + 1;

      if (nextIndex === matchingItems.length) {
        nextIndex = 0;
      }

      return matchingItems[nextIndex];
    } // Else, we pick the first item in the available items


    nextIndex = items.indexOf(matchingItems[0]);
    return items[nextIndex];
  } // a decent fallback to the currentItem


  return currentItem;
} // Number assertions


function isNumber(value) {
  return typeof value === "number";
}

function isNotNumber(value) {
  return typeof value !== "number" || Number.isNaN(value) || !Number.isFinite(value);
}

function isNumeric(value) {
  return value != null && value - parseFloat(value) + 1 >= 0;
} // Array assertions


function isArray(value) {
  return Array.isArray(value);
}

function isEmptyArray(value) {
  return isArray(value) && value.length === 0;
} // Function assertions


function isFunction(value) {
  return typeof value === "function";
} // Generic assertions


function isDefined(value) {
  return typeof value !== "undefined" && value !== undefined;
}

function isUndefined(value) {
  return typeof value === "undefined" || value === undefined;
} // Object assertions


function isObject(value) {
  var type = typeof value;
  return value != null && (type === "object" || type === "function") && !isArray(value);
}

function isEmptyObject(value) {
  return isObject(value) && Object.keys(value).length === 0;
}

function isNotEmptyObject(value) {
  return value && !isEmptyObject(value);
}

function isNull(value) {
  return value == null;
} // String assertions


function isString(value) {
  return Object.prototype.toString.call(value) === "[object String]";
}

function isCssVar(value) {
  return /^var\(--.+\)$/.test(value);
} // Empty assertions


function isEmpty(value) {
  if (isArray(value)) return isEmptyArray(value);
  if (isObject(value)) return isEmptyObject(value);
  if (value == null || value === "") return true;
  return false;
}

var __DEV__ = "production" !== "production";

var __TEST__ = "production" === "test";

function isRefObject(val) {
  return "current" in val;
}

function isInputEvent(value) {
  return value && isObject(value) && isObject(value.target);
}

function omit(object, keys) {
  var result = {};
  Object.keys(object).forEach(function (key) {
    if (keys.includes(key)) return;
    result[key] = object[key];
  });
  return result;
}

function pick(object, keys) {
  var result = {};
  keys.forEach(function (key) {
    if (key in object) {
      result[key] = object[key];
    }
  });
  return result;
}

function split(object, keys) {
  var picked = {};
  var omitted = {};
  Object.keys(object).forEach(function (key) {
    if (keys.includes(key)) {
      picked[key] = object[key];
    } else {
      omitted[key] = object[key];
    }
  });
  return [picked, omitted];
}
/**
 * Get value from a deeply nested object using a string path.
 * Memoizes the value.
 * @param obj - the object
 * @param path - the string path
 * @param def  - the fallback value
 */


function get(obj, path, fallback, index) {
  var key = typeof path === "string" ? path.split(".") : [path];

  for (index = 0; index < key.length; index += 1) {
    if (!obj) break;
    obj = obj[key[index]];
  }

  return obj === undefined ? fallback : obj;
}

var memoize = function memoize(fn) {
  var cache = new WeakMap();

  var memoizedFn = function memoizedFn(obj, path, fallback, index) {
    if (typeof obj === "undefined") {
      return fn(obj, path, fallback);
    }

    if (!cache.has(obj)) {
      cache.set(obj, new Map());
    }

    var map = cache.get(obj);

    if (map.has(path)) {
      return map.get(path);
    }

    var value = fn(obj, path, fallback, index);
    map.set(path, value);
    return value;
  };

  return memoizedFn;
};

var memoizedGet = memoize(get);
/**
 * Get value from deeply nested object, based on path
 * It returns the path value if not found in object
 *
 * @param path - the string path or value
 * @param scale - the string path or value
 */

function getWithDefault(path, scale) {
  return memoizedGet(scale, path, path);
}
/**
 * Returns the items of an object that meet the condition specified in a callback function.
 *
 * @param object the object to loop through
 * @param fn The filter function
 */


function objectFilter(object, fn) {
  var result = {};
  Object.keys(object).forEach(function (key) {
    var value = object[key];
    var shouldPass = fn(value, key, object);

    if (shouldPass) {
      result[key] = value;
    }
  });
  return result;
}

var filterUndefined = function filterUndefined(object) {
  return objectFilter(object, function (val) {
    return val !== null && val !== undefined;
  });
};

var objectKeys = function objectKeys(obj) {
  return Object.keys(obj);
};
/**
 * Object.entries polyfill for Nodev10 compatibility
 */


var fromEntries = function fromEntries(entries) {
  return entries.reduce(function (carry, _ref) {
    var key = _ref[0],
        value = _ref[1];
    carry[key] = value;
    return carry;
  }, {});
};
/**
 * Get the CSS variable ref stored in the theme
 */


var getCSSVar = function getCSSVar(theme, scale, value) {
  var _theme$__cssMap$$varR, _theme$__cssMap$;

  return (_theme$__cssMap$$varR = (_theme$__cssMap$ = theme.__cssMap[scale + "." + value]) == null ? void 0 : _theme$__cssMap$.varRef) != null ? _theme$__cssMap$$varR : value;
};

function analyzeCSSValue(value) {
  var num = parseFloat(value.toString());
  var unit = value.toString().replace(String(num), "");
  return {
    unitless: !unit,
    value: num,
    unit: unit
  };
}

function px(value) {
  if (value == null) return value;

  var _analyzeCSSValue = analyzeCSSValue(value),
      unitless = _analyzeCSSValue.unitless;

  return unitless || isNumber(value) ? value + "px" : value;
}

var sortByBreakpointValue = function sortByBreakpointValue(a, b) {
  return parseInt(a[1], 10) > parseInt(b[1], 10) ? 1 : -1;
};

var sortBps = function sortBps(breakpoints) {
  return fromEntries(Object.entries(breakpoints).sort(sortByBreakpointValue));
};

function normalize(breakpoints) {
  var sorted = sortBps(breakpoints);
  return Object.assign(Object.values(sorted), sorted);
}

function keys(breakpoints) {
  var value = Object.keys(sortBps(breakpoints));
  return new Set(value);
}

function subtract(value) {
  var _px;

  if (!value) return value;
  value = (_px = px(value)) != null ? _px : value;
  var factor = value.endsWith("px") ? -1 : // the equivalent of 1px in em using a 16px base
  -0.0635;
  return isNumber(value) ? "" + (value + factor) : value.replace(/([0-9]+\.?[0-9]*)/, function (m) {
    return "" + (parseFloat(m) + factor);
  });
}

function queryString(min, max) {
  var query = ["@media screen"];
  if (min) query.push("and", "(min-width: " + px(min) + ")");
  if (max) query.push("and", "(max-width: " + px(max) + ")");
  return query.join(" ");
}

function analyzeBreakpoints(breakpoints) {
  var _breakpoints$base;

  if (!breakpoints) return null;
  breakpoints.base = (_breakpoints$base = breakpoints.base) != null ? _breakpoints$base : "0px";
  var normalized = normalize(breakpoints);
  var queries = Object.entries(breakpoints).sort(sortByBreakpointValue).map(function (_ref, index, entry) {
    var _entry;

    var breakpoint = _ref[0],
        minW = _ref[1];

    var _ref2 = (_entry = entry[index + 1]) != null ? _entry : [],
        maxW = _ref2[1];

    maxW = parseFloat(maxW) > 0 ? subtract(maxW) : undefined;
    return {
      breakpoint: breakpoint,
      minW: minW,
      maxW: maxW,
      maxWQuery: queryString(null, maxW),
      minWQuery: queryString(minW),
      minMaxQuery: queryString(minW, maxW)
    };
  });

  var _keys = keys(breakpoints);

  var _keysArr = Array.from(_keys.values());

  return {
    keys: _keys,
    normalized: normalized,
    isResponsive: function isResponsive(test) {
      var keys = Object.keys(test);
      return keys.length > 0 && keys.every(function (key) {
        return _keys.has(key);
      });
    },
    asObject: sortBps(breakpoints),
    asArray: normalize(breakpoints),
    details: queries,
    media: [null].concat(normalized.map(function (minW) {
      return queryString(minW);
    }).slice(1)),
    toArrayValue: function toArrayValue(test) {
      if (!isObject(test)) {
        throw new Error("toArrayValue: value must be an object");
      }

      var result = _keysArr.map(function (bp) {
        var _test$bp;

        return (_test$bp = test[bp]) != null ? _test$bp : null;
      });

      while (getLastItem(result) === null) {
        result.pop();
      }

      return result;
    },
    toObjectValue: function toObjectValue(test) {
      if (!Array.isArray(test)) {
        throw new Error("toObjectValue: value must be an array");
      }

      return test.reduce(function (acc, value, index) {
        var key = _keysArr[index];
        if (key != null && value != null) acc[key] = value;
        return acc;
      }, {});
    }
  };
}

function isElement(el) {
  return el != null && typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
}

function isHTMLElement(el) {
  var _el$ownerDocument$def;

  if (!isElement(el)) {
    return false;
  }

  var win = (_el$ownerDocument$def = el.ownerDocument.defaultView) != null ? _el$ownerDocument$def : window;
  return el instanceof win.HTMLElement;
}

function getOwnerWindow(node) {
  var _getOwnerDocument$def, _getOwnerDocument;

  return isElement(node) ? (_getOwnerDocument$def = (_getOwnerDocument = getOwnerDocument(node)) == null ? void 0 : _getOwnerDocument.defaultView) != null ? _getOwnerDocument$def : window : window;
}

function getOwnerDocument(node) {
  var _node$ownerDocument;

  return isElement(node) ? (_node$ownerDocument = node.ownerDocument) != null ? _node$ownerDocument : document : document;
}

function getEventWindow(event) {
  var _view;

  return (_view = event.view) != null ? _view : window;
}

function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}

var isBrowser = canUseDOM();

var dataAttr = function dataAttr(condition) {
  return condition ? "" : undefined;
};

var ariaAttr = function ariaAttr(condition) {
  return condition ? true : undefined;
};

var cx = function cx() {
  for (var _len = arguments.length, classNames = new Array(_len), _key = 0; _key < _len; _key++) {
    classNames[_key] = arguments[_key];
  }

  return classNames.filter(Boolean).join(" ");
};

function getActiveElement(node) {
  var doc = getOwnerDocument(node);
  return doc == null ? void 0 : doc.activeElement;
}

function contains(parent, child) {
  if (!parent) return false;
  return parent === child || parent.contains(child);
}

function addDomEvent(target, eventName, handler, options) {
  target.addEventListener(eventName, handler, options);
  return function () {
    target.removeEventListener(eventName, handler, options);
  };
}
/**
 * Get the normalized event key across all browsers
 * @param event keyboard event
 */


function normalizeEventKey(event) {
  var key = event.key,
      keyCode = event.keyCode;
  var isArrowKey = keyCode >= 37 && keyCode <= 40 && key.indexOf("Arrow") !== 0;
  var eventKey = isArrowKey ? "Arrow" + key : key;
  return eventKey;
}

function getRelatedTarget(event) {
  var _event$target, _event$relatedTarget;

  var target = (_event$target = event.target) != null ? _event$target : event.currentTarget;
  var activeElement = getActiveElement(target);
  return (_event$relatedTarget = event.relatedTarget) != null ? _event$relatedTarget : activeElement;
}

function isRightClick(event) {
  return event.button !== 0;
} // Really great work done by Diego Haz on this one


var hasDisplayNone = function hasDisplayNone(element) {
  return window.getComputedStyle(element).display === "none";
};

var hasTabIndex = function hasTabIndex(element) {
  return element.hasAttribute("tabindex");
};

var hasNegativeTabIndex = function hasNegativeTabIndex(element) {
  return hasTabIndex(element) && element.tabIndex === -1;
};

function isDisabled(element) {
  return Boolean(element.getAttribute("disabled")) === true || Boolean(element.getAttribute("aria-disabled")) === true;
}

function isInputElement(element) {
  return isHTMLElement(element) && element.tagName.toLowerCase() === "input" && "select" in element;
}

function isActiveElement(element) {
  var doc = isHTMLElement(element) ? getOwnerDocument(element) : document;
  return doc.activeElement === element;
}

function hasFocusWithin(element) {
  if (!document.activeElement) return false;
  return element.contains(document.activeElement);
}

function isHidden(element) {
  if (element.parentElement && isHidden(element.parentElement)) return true;
  return element.hidden;
}

function isContentEditable(element) {
  var value = element.getAttribute("contenteditable");
  return value !== "false" && value != null;
}

function isFocusable(element) {
  if (!isHTMLElement(element) || isHidden(element) || isDisabled(element)) {
    return false;
  }

  var localName = element.localName;
  var focusableTags = ["input", "select", "textarea", "button"];
  if (focusableTags.indexOf(localName) >= 0) return true;
  var others = {
    a: function a() {
      return element.hasAttribute("href");
    },
    audio: function audio() {
      return element.hasAttribute("controls");
    },
    video: function video() {
      return element.hasAttribute("controls");
    }
  };

  if (localName in others) {
    return others[localName]();
  }

  if (isContentEditable(element)) return true;
  return hasTabIndex(element);
}

function isTabbable(element) {
  if (!element) return false;
  return isHTMLElement(element) && isFocusable(element) && !hasNegativeTabIndex(element);
}

var focusableElList = ["input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", "embed", "iframe", "object", "a[href]", "area[href]", "button:not([disabled])", "[tabindex]", "audio[controls]", "video[controls]", "*[tabindex]:not([aria-disabled])", "*[contenteditable]"];
var focusableElSelector = focusableElList.join();

function getAllFocusable(container) {
  var focusableEls = Array.from(container.querySelectorAll(focusableElSelector));
  focusableEls.unshift(container);
  return focusableEls.filter(isFocusable).filter(function (el) {
    return window.getComputedStyle(el).display !== "none";
  });
}

function getFirstFocusable(container) {
  var allFocusable = getAllFocusable(container);
  return allFocusable.length ? allFocusable[0] : null;
}

function getAllTabbable(container, fallbackToFocusable) {
  var allFocusable = Array.from(container.querySelectorAll(focusableElSelector));
  var allTabbable = allFocusable.filter(isTabbable);

  if (isTabbable(container)) {
    allTabbable.unshift(container);
  }

  if (!allTabbable.length && fallbackToFocusable) {
    return allFocusable;
  }

  return allTabbable;
}

function getFirstTabbableIn(container, fallbackToFocusable) {
  var _getAllTabbable = getAllTabbable(container, fallbackToFocusable),
      first = _getAllTabbable[0];

  return first || null;
}

function getLastTabbableIn(container, fallbackToFocusable) {
  var allTabbable = getAllTabbable(container, fallbackToFocusable);
  return allTabbable[allTabbable.length - 1] || null;
}

function getNextTabbable(container, fallbackToFocusable) {
  var allFocusable = getAllFocusable(container);
  var index = allFocusable.indexOf(document.activeElement);
  var slice = allFocusable.slice(index + 1);
  return slice.find(isTabbable) || allFocusable.find(isTabbable) || (fallbackToFocusable ? slice[0] : null);
}

function getPreviousTabbable(container, fallbackToFocusable) {
  var allFocusable = getAllFocusable(container).reverse();
  var index = allFocusable.indexOf(document.activeElement);
  var slice = allFocusable.slice(index + 1);
  return slice.find(isTabbable) || allFocusable.find(isTabbable) || (fallbackToFocusable ? slice[0] : null);
}

function focusNextTabbable(container, fallbackToFocusable) {
  var nextTabbable = getNextTabbable(container, fallbackToFocusable);

  if (nextTabbable && isHTMLElement(nextTabbable)) {
    nextTabbable.focus();
  }
}

function focusPreviousTabbable(container, fallbackToFocusable) {
  var previousTabbable = getPreviousTabbable(container, fallbackToFocusable);

  if (previousTabbable && isHTMLElement(previousTabbable)) {
    previousTabbable.focus();
  }
}

function matches(element, selectors) {
  if ("matches" in element) return element.matches(selectors);
  if ("msMatchesSelector" in element) return element.msMatchesSelector(selectors);
  return element.webkitMatchesSelector(selectors);
}

function closest(element, selectors) {
  if ("closest" in element) return element.closest(selectors);

  do {
    if (matches(element, selectors)) return element;
    element = element.parentElement || element.parentNode;
  } while (element !== null && element.nodeType === 1);

  return null;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
/* eslint-disable no-nested-ternary */


function runIfFn(valueOrFn) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return isFunction(valueOrFn) ? valueOrFn.apply(void 0, args) : valueOrFn;
}

function callAllHandlers() {
  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    fns[_key2] = arguments[_key2];
  }

  return function func(event) {
    fns.some(function (fn) {
      fn == null ? void 0 : fn(event);
      return event == null ? void 0 : event.defaultPrevented;
    });
  };
}

function callAll() {
  for (var _len3 = arguments.length, fns = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    fns[_key3] = arguments[_key3];
  }

  return function mergedFn(arg) {
    fns.forEach(function (fn) {
      fn == null ? void 0 : fn(arg);
    });
  };
}

var compose = function compose(fn1) {
  for (var _len4 = arguments.length, fns = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    fns[_key4 - 1] = arguments[_key4];
  }

  return fns.reduce(function (f1, f2) {
    return function () {
      return f1(f2.apply(void 0, arguments));
    };
  }, fn1);
};

function once(fn) {
  var result;
  return function func() {
    if (fn) {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      result = fn.apply(this, args);
      fn = null;
    }

    return result;
  };
}

var noop = function noop() {};

var warn = once(function (options) {
  return function () {
    var condition = options.condition,
        message = options.message;

    if (condition && __DEV__) {
      console.warn(message);
    }
  };
});
var error = once(function (options) {
  return function () {
    var condition = options.condition,
        message = options.message;

    if (condition && __DEV__) {
      console.error(message);
    }
  };
});

var pipe = function pipe() {
  for (var _len6 = arguments.length, fns = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    fns[_key6] = arguments[_key6];
  }

  return function (v) {
    return fns.reduce(function (a, b) {
      return b(a);
    }, v);
  };
};

var distance1D = function distance1D(a, b) {
  return Math.abs(a - b);
};

var isPoint = function isPoint(point) {
  return "x" in point && "y" in point;
};

function distance(a, b) {
  if (isNumber(a) && isNumber(b)) {
    return distance1D(a, b);
  }

  if (isPoint(a) && isPoint(b)) {
    var xDelta = distance1D(a.x, b.x);
    var yDelta = distance1D(a.y, b.y);
    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2));
  }

  return 0;
}

function focus(element, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$isActive = _options.isActive,
      isActive = _options$isActive === void 0 ? isActiveElement : _options$isActive,
      nextTick = _options.nextTick,
      _options$preventScrol = _options.preventScroll,
      preventScroll = _options$preventScrol === void 0 ? true : _options$preventScrol,
      _options$selectTextIf = _options.selectTextIfInput,
      selectTextIfInput = _options$selectTextIf === void 0 ? true : _options$selectTextIf;
  if (!element || isActive(element)) return -1;

  function triggerFocus() {
    if (!element) {
      warn({
        condition: true,
        message: "[chakra-ui]: can't call focus() on `null` or `undefined` element"
      });
      return;
    }

    if (supportsPreventScroll()) {
      element.focus({
        preventScroll: preventScroll
      });
    } else {
      element.focus();

      if (preventScroll) {
        var scrollableElements = getScrollableElements(element);
        restoreScrollPosition(scrollableElements);
      }
    }

    if (isInputElement(element) && selectTextIfInput) {
      element.select();
    }
  }

  if (nextTick) {
    return requestAnimationFrame(triggerFocus);
  }

  triggerFocus();
  return -1;
}

var supportsPreventScrollCached = null;

function supportsPreventScroll() {
  if (supportsPreventScrollCached == null) {
    supportsPreventScrollCached = false;

    try {
      var div = document.createElement("div");
      div.focus({
        get preventScroll() {
          supportsPreventScrollCached = true;
          return true;
        }

      });
    } catch (e) {// Ignore
    }
  }

  return supportsPreventScrollCached;
}

function getScrollableElements(element) {
  var _doc$defaultView;

  var doc = getOwnerDocument(element);
  var win = (_doc$defaultView = doc.defaultView) != null ? _doc$defaultView : window;
  var parent = element.parentNode;
  var scrollableElements = [];
  var rootScrollingElement = doc.scrollingElement || doc.documentElement;

  while (parent instanceof win.HTMLElement && parent !== rootScrollingElement) {
    if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) {
      scrollableElements.push({
        element: parent,
        scrollTop: parent.scrollTop,
        scrollLeft: parent.scrollLeft
      });
    }

    parent = parent.parentNode;
  }

  if (rootScrollingElement instanceof win.HTMLElement) {
    scrollableElements.push({
      element: rootScrollingElement,
      scrollTop: rootScrollingElement.scrollTop,
      scrollLeft: rootScrollingElement.scrollLeft
    });
  }

  return scrollableElements;
}

function restoreScrollPosition(scrollableElements) {
  for (var _iterator = _createForOfIteratorHelperLoose(scrollableElements), _step; !(_step = _iterator()).done;) {
    var _step$value = _step.value,
        element = _step$value.element,
        scrollTop = _step$value.scrollTop,
        scrollLeft = _step$value.scrollLeft;
    element.scrollTop = scrollTop;
    element.scrollLeft = scrollLeft;
  }
}

function flatten(target, maxDepth) {
  if (maxDepth === void 0) {
    maxDepth = Infinity;
  }

  if (!isObject(target) && !Array.isArray(target) || !maxDepth) {
    return target;
  }

  return Object.entries(target).reduce(function (result, _ref) {
    var key = _ref[0],
        value = _ref[1];

    if (isObject(value) || isArray(value)) {
      Object.entries(flatten(value, maxDepth - 1)).forEach(function (_ref2) {
        var childKey = _ref2[0],
            childValue = _ref2[1]; // e.g. gray.500

        result[key + "." + childKey] = childValue;
      });
    } else {
      // e.g. transparent
      result[key] = value;
    }

    return result;
  }, {});
}
/**
 * Determines whether the children of a disclosure widget
 * should be rendered or not, depending on the lazy behavior.
 *
 * Used in accordion, tabs, popover, menu and other disclosure
 * widgets.
 */


function determineLazyBehavior(options) {
  var hasBeenSelected = options.hasBeenSelected,
      isLazy = options.isLazy,
      isSelected = options.isSelected,
      _options$lazyBehavior = options.lazyBehavior,
      lazyBehavior = _options$lazyBehavior === void 0 ? "unmount" : _options$lazyBehavior; // if not lazy, always render the disclosure's content

  if (!isLazy) return true; // if the diclosure is selected, render the disclosure's content

  if (isSelected) return true; // if the disclosure was selected but not active, keep its content active

  if (lazyBehavior === "keepMounted" && hasBeenSelected) return true;
  return false;
}

var minSafeInteger = Number.MIN_SAFE_INTEGER || -9007199254740991;
var maxSafeInteger = Number.MAX_SAFE_INTEGER || 9007199254740991;

function toNumber(value) {
  var num = parseFloat(value);
  return isNotNumber(num) ? 0 : num;
}
/**
 * Converts a value to a specific precision (or decimal points).
 *
 * Returns a string representing a number in fixed-point notation.
 *
 * @param value the value to convert
 * @param precision the precision or decimal points
 */


function toPrecision(value, precision) {
  var nextValue = toNumber(value);
  var scaleFactor = Math.pow(10, precision != null ? precision : 10);
  nextValue = Math.round(nextValue * scaleFactor) / scaleFactor;
  return precision ? nextValue.toFixed(precision) : nextValue.toString();
}
/**
 * Counts the number of decimal places a number has
 *
 * @param value the decimal value to count
 */


function countDecimalPlaces(value) {
  if (!Number.isFinite(value)) return 0;
  var e = 1;
  var p = 0;

  while (Math.round(value * e) / e !== value) {
    e *= 10;
    p += 1;
  }

  return p;
}
/**
 * Convert a value to percentage based on lower and upper bound values
 *
 * @param value the value in number
 * @param min the minimum value
 * @param max the maximum value
 */


function valueToPercent(value, min, max) {
  return (value - min) * 100 / (max - min);
}
/**
 * Calculate the value based on percentage, lower and upper bound values
 *
 * @param percent the percent value in decimals (e.g 0.6, 0.3)
 * @param min the minimum value
 * @param max the maximum value
 */


function percentToValue(percent, min, max) {
  return (max - min) * percent + min;
}
/**
 * Rounds a specific value to the next or previous step
 *
 * @param value the value to round
 * @param from the number that stepping started from
 * @param step the specified step
 */


function roundValueToStep(value, from, step) {
  var nextValue = Math.round((value - from) / step) * step + from;
  var precision = countDecimalPlaces(step);
  return toPrecision(nextValue, precision);
}
/**
 * Clamps a value to ensure it stays within the min and max range.
 *
 * @param value the value to clamp
 * @param min the minimum value
 * @param max the maximum value
 */


function clampValue(value, min, max) {
  if (value == null) return value;
  warn({
    condition: max < min,
    message: "clamp: max cannot be less than min"
  });
  return Math.min(Math.max(value, min), max);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}
/**
 * Credit goes to `framer-motion` of this useful utilities.
 * License can be found here: https://github.com/framer/motion
 */


function isMouseEvent(event) {
  var win = getEventWindow(event); // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.

  if (typeof win.PointerEvent !== "undefined" && event instanceof win.PointerEvent) {
    return !!(event.pointerType === "mouse");
  }

  return event instanceof win.MouseEvent;
}

function isTouchEvent(event) {
  var hasTouches = !!event.touches;
  return hasTouches;
}
/**
 * Filters out events not attached to the primary pointer (currently left mouse button)
 * @param eventHandler
 */


function filterPrimaryPointer(eventHandler) {
  return function (event) {
    var win = getEventWindow(event);
    var isMouseEvent = event instanceof win.MouseEvent;
    var isPrimaryPointer = !isMouseEvent || isMouseEvent && event.button === 0;

    if (isPrimaryPointer) {
      eventHandler(event);
    }
  };
}

var defaultPagePoint = {
  pageX: 0,
  pageY: 0
};

function pointFromTouch(e, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }

  var primaryTouch = e.touches[0] || e.changedTouches[0];
  var point = primaryTouch || defaultPagePoint;
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}

function pointFromMouse(point, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }

  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}

function extractEventInfo(event, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }

  return {
    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)
  };
}

function getViewportPointFromEvent(event) {
  return extractEventInfo(event, "client");
}

var wrapPointerEventHandler = function wrapPointerEventHandler(handler, shouldFilterPrimaryPointer) {
  if (shouldFilterPrimaryPointer === void 0) {
    shouldFilterPrimaryPointer = false;
  }

  var listener = function listener(event) {
    return handler(event, extractEventInfo(event));
  };

  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;
}; // We check for event support via functions in case they've been mocked by a testing suite.


var supportsPointerEvents = function supportsPointerEvents() {
  return isBrowser && window.onpointerdown === null;
};

var supportsTouchEvents = function supportsTouchEvents() {
  return isBrowser && window.ontouchstart === null;
};

var supportsMouseEvents = function supportsMouseEvents() {
  return isBrowser && window.onmousedown === null;
};

var mouseEventNames = {
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointercancel: "mousecancel",
  pointerover: "mouseover",
  pointerout: "mouseout",
  pointerenter: "mouseenter",
  pointerleave: "mouseleave"
};
var touchEventNames = {
  pointerdown: "touchstart",
  pointermove: "touchmove",
  pointerup: "touchend",
  pointercancel: "touchcancel"
};

function getPointerEventName(name) {
  if (supportsPointerEvents()) {
    return name;
  }

  if (supportsTouchEvents()) {
    return touchEventNames[name];
  }

  if (supportsMouseEvents()) {
    return mouseEventNames[name];
  }

  return name;
}

function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, getPointerEventName(eventName), wrapPointerEventHandler(handler, eventName === "pointerdown"), options);
}

function isMultiTouchEvent(event) {
  return isTouchEvent(event) && event.touches.length > 1;
}
/**
 * The event information passed to pan event handlers like `onPan`, `onPanStart`.
 *
 * It contains information about the current state of the tap gesture such as its
 * `point`, `delta`, and `offset`
 */

/**
 * @internal
 *
 * A Pan Session is recognized when the pointer is down
 * and moved in the allowed direction.
 */


var PanSession = /*#__PURE__*/function () {
  /**
   * We use this to keep track of the `x` and `y` pan session history
   * as the pan event happens. It helps to calculate the `offset` and `delta`
   */
  // The pointer event that started the pan session
  // The current pointer event for the pan session
  // The current pointer event info for the pan session

  /**
   * Minimal pan distance required before recognizing the pan.
   * @default "3px"
   */
  function PanSession(_event, handlers, threshold) {
    var _this = this;

    this.history = [];
    this.startEvent = null;
    this.lastEvent = null;
    this.lastEventInfo = null;
    this.handlers = {};
    this.removeListeners = noop;
    this.threshold = 3;
    this.win = void 0;

    this.updatePoint = function () {
      if (!(_this.lastEvent && _this.lastEventInfo)) return;
      var info = getPanInfo(_this.lastEventInfo, _this.history);
      var isPanStarted = _this.startEvent !== null;

      var isDistancePastThreshold = distance(info.offset, {
        x: 0,
        y: 0
      }) >= _this.threshold;

      if (!isPanStarted && !isDistancePastThreshold) return;

      var _getFrameData = sync.getFrameData(),
          timestamp = _getFrameData.timestamp;

      _this.history.push(_extends({}, info.point, {
        timestamp: timestamp
      }));

      var _this$handlers = _this.handlers,
          onStart = _this$handlers.onStart,
          onMove = _this$handlers.onMove;

      if (!isPanStarted) {
        onStart == null ? void 0 : onStart(_this.lastEvent, info);
        _this.startEvent = _this.lastEvent;
      }

      onMove == null ? void 0 : onMove(_this.lastEvent, info);
    };

    this.onPointerMove = function (event, info) {
      _this.lastEvent = event;
      _this.lastEventInfo = info; // Because Safari doesn't trigger mouseup events when it's above a `<select>`

      if (isMouseEvent(event) && event.buttons === 0) {
        _this.onPointerUp(event, info);

        return;
      } // Throttle mouse move event to once per frame


      sync__default["default"].update(_this.updatePoint, true);
    };

    this.onPointerUp = function (event, info) {
      // notify pan session ended
      var panInfo = getPanInfo(info, _this.history);
      var _this$handlers2 = _this.handlers,
          onEnd = _this$handlers2.onEnd,
          onSessionEnd = _this$handlers2.onSessionEnd;
      onSessionEnd == null ? void 0 : onSessionEnd(event, panInfo);

      _this.end(); // if panning never started, no need to call `onEnd`
      // panning requires a pointermove of at least 3px


      if (!onEnd || !_this.startEvent) return;
      onEnd == null ? void 0 : onEnd(event, panInfo);
    };

    this.win = getEventWindow(_event); // If we have more than one touch, don't start detecting this gesture

    if (isMultiTouchEvent(_event)) return;
    this.handlers = handlers;

    if (threshold) {
      this.threshold = threshold;
    } // stop default browser behavior


    _event.stopPropagation();

    _event.preventDefault(); // get and save the `pointerdown` event info in history
    // we'll use it to compute the `offset`


    var _info = extractEventInfo(_event);

    var _getFrameData2 = sync.getFrameData(),
        _timestamp = _getFrameData2.timestamp;

    this.history = [_extends({}, _info.point, {
      timestamp: _timestamp
    })]; // notify pan session start

    var onSessionStart = handlers.onSessionStart;
    onSessionStart == null ? void 0 : onSessionStart(_event, getPanInfo(_info, this.history)); // attach event listeners and return a single function to remove them all

    this.removeListeners = pipe(addPointerEvent(this.win, "pointermove", this.onPointerMove), addPointerEvent(this.win, "pointerup", this.onPointerUp), addPointerEvent(this.win, "pointercancel", this.onPointerUp));
  }

  var _proto = PanSession.prototype;

  _proto.updateHandlers = function updateHandlers(handlers) {
    this.handlers = handlers;
  };

  _proto.end = function end() {
    var _this$removeListeners;

    (_this$removeListeners = this.removeListeners) == null ? void 0 : _this$removeListeners.call(this);
    sync.cancelSync.update(this.updatePoint);
  };

  return PanSession;
}();

function subtractPoint(a, b) {
  return {
    x: a.x - b.x,
    y: a.y - b.y
  };
}

function startPanPoint(history) {
  return history[0];
}

function lastPanPoint(history) {
  return history[history.length - 1];
}

function getPanInfo(info, history) {
  return {
    point: info.point,
    delta: subtractPoint(info.point, lastPanPoint(history)),
    offset: subtractPoint(info.point, startPanPoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}

function lastDevicePoint(history) {
  return history[history.length - 1];
}

var toMilliseconds = function toMilliseconds(seconds) {
  return seconds * 1000;
};

function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return {
      x: 0,
      y: 0
    };
  }

  var i = history.length - 1;
  var timestampedPoint = null;
  var lastPoint = lastDevicePoint(history);

  while (i >= 0) {
    timestampedPoint = history[i];

    if (lastPoint.timestamp - timestampedPoint.timestamp > toMilliseconds(timeDelta)) {
      break;
    }

    i--;
  }

  if (!timestampedPoint) {
    return {
      x: 0,
      y: 0
    };
  }

  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;

  if (time === 0) {
    return {
      x: 0,
      y: 0
    };
  }

  var currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };

  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }

  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }

  return currentVelocity;
}

var breakpoints = Object.freeze(["base", "sm", "md", "lg", "xl", "2xl"]);

function mapResponsive(prop, mapper) {
  if (isArray(prop)) {
    return prop.map(function (item) {
      if (item === null) {
        return null;
      }

      return mapper(item);
    });
  }

  if (isObject(prop)) {
    return objectKeys(prop).reduce(function (result, key) {
      result[key] = mapper(prop[key]);
      return result;
    }, {});
  }

  if (prop != null) {
    return mapper(prop);
  }

  return null;
}

function objectToArrayNotation(obj, bps) {
  if (bps === void 0) {
    bps = breakpoints;
  }

  var result = bps.map(function (br) {
    var _obj$br;

    return (_obj$br = obj[br]) != null ? _obj$br : null;
  });

  while (getLastItem(result) === null) {
    result.pop();
  }

  return result;
}

function arrayToObjectNotation(values, bps) {
  if (bps === void 0) {
    bps = breakpoints;
  }

  var result = {};
  values.forEach(function (value, index) {
    var key = bps[index];
    if (value == null) return;
    result[key] = value;
  });
  return result;
}

function isResponsiveObjectLike(obj, bps) {
  if (bps === void 0) {
    bps = breakpoints;
  }

  var keys = Object.keys(obj);
  return keys.length > 0 && keys.every(function (key) {
    return bps.includes(key);
  });
}
/**
 * since breakpoints are defined as custom properties on an array, you may
 * `Object.keys(theme.breakpoints)` to retrieve both regular numeric indices
 * and custom breakpoints as string.
 *
 * This function returns true given a custom array property.
 */


var isCustomBreakpoint = function isCustomBreakpoint(maybeBreakpoint) {
  return Number.isNaN(Number(maybeBreakpoint));
};

function getUserAgentBrowser(navigator) {
  var ua = navigator.userAgent,
      vendor = navigator.vendor;
  var android = /(android)/i.test(ua);

  switch (true) {
    case /CriOS/.test(ua):
      return "Chrome for iOS";

    case /Edg\//.test(ua):
      return "Edge";

    case android && /Silk\//.test(ua):
      return "Silk";

    case /Chrome/.test(ua) && /Google Inc/.test(vendor):
      return "Chrome";

    case /Firefox\/\d+\.\d+$/.test(ua):
      return "Firefox";

    case android:
      return "AOSP";

    case /MSIE|Trident/.test(ua):
      return "IE";

    case /Safari/.test(navigator.userAgent) && /Apple Computer/.test(ua):
      return "Safari";

    case /AppleWebKit/.test(ua):
      return "WebKit";

    default:
      return null;
  }
}

function getUserAgentOS(navigator) {
  var ua = navigator.userAgent,
      platform = navigator.platform;

  switch (true) {
    case /Android/.test(ua):
      return "Android";

    case /iPhone|iPad|iPod/.test(platform):
      return "iOS";

    case /Win/.test(platform):
      return "Windows";

    case /Mac/.test(platform):
      return "Mac";

    case /CrOS/.test(ua):
      return "Chrome OS";

    case /Firefox/.test(ua):
      return "Firefox OS";

    default:
      return null;
  }
}

function detectDeviceType(navigator) {
  var ua = navigator.userAgent;
  if (/(tablet)|(iPad)|(Nexus 9)/i.test(ua)) return "tablet";
  if (/(mobi)/i.test(ua)) return "phone";
  return "desktop";
}

function detectOS(os) {
  if (!isBrowser) return false;
  return getUserAgentOS(window.navigator) === os;
}

function detectBrowser(browser) {
  if (!isBrowser) return false;
  return getUserAgentBrowser(window.navigator) === browser;
}

function detectTouch() {
  if (!isBrowser) return false;
  return window.ontouchstart === null && window.ontouchmove === null && window.ontouchend === null;
}

function walkObject(target, predicate) {
  function inner(value, path) {
    if (path === void 0) {
      path = [];
    }

    if (isArray(value)) {
      return value.map(function (item, index) {
        return inner(item, [].concat(path, [String(index)]));
      });
    }

    if (isObject(value)) {
      return fromEntries(Object.entries(value).map(function (_ref) {
        var key = _ref[0],
            child = _ref[1];
        return [key, inner(child, [].concat(path, [key]))];
      }));
    }

    return predicate(value, path);
  }

  return inner(target);
}

Object.defineProperty(exports, 'mergeWith', {
  enumerable: true,
  get: function () {
    return lodash_mergewith__default["default"];
  }
});
exports.PanSession = PanSession;
exports.__DEV__ = __DEV__;
exports.__TEST__ = __TEST__;
exports.addDomEvent = addDomEvent;
exports.addItem = addItem;
exports.addPointerEvent = addPointerEvent;
exports.analyzeBreakpoints = analyzeBreakpoints;
exports.ariaAttr = ariaAttr;
exports.arrayToObjectNotation = arrayToObjectNotation;
exports.breakpoints = breakpoints;
exports.callAll = callAll;
exports.callAllHandlers = callAllHandlers;
exports.canUseDOM = canUseDOM;
exports.chunk = chunk;
exports.clampValue = clampValue;
exports.closest = closest;
exports.compose = compose;
exports.contains = contains;
exports.countDecimalPlaces = countDecimalPlaces;
exports.cx = cx;
exports.dataAttr = dataAttr;
exports.detectBrowser = detectBrowser;
exports.detectDeviceType = detectDeviceType;
exports.detectOS = detectOS;
exports.detectTouch = detectTouch;
exports.determineLazyBehavior = determineLazyBehavior;
exports.distance = distance;
exports.error = error;
exports.extractEventInfo = extractEventInfo;
exports.filterUndefined = filterUndefined;
exports.flatten = flatten;
exports.focus = focus;
exports.focusNextTabbable = focusNextTabbable;
exports.focusPreviousTabbable = focusPreviousTabbable;
exports.fromEntries = fromEntries;
exports.get = get;
exports.getActiveElement = getActiveElement;
exports.getAllFocusable = getAllFocusable;
exports.getAllTabbable = getAllTabbable;
exports.getCSSVar = getCSSVar;
exports.getEventWindow = getEventWindow;
exports.getFirstFocusable = getFirstFocusable;
exports.getFirstItem = getFirstItem;
exports.getFirstTabbableIn = getFirstTabbableIn;
exports.getLastItem = getLastItem;
exports.getLastTabbableIn = getLastTabbableIn;
exports.getNextIndex = getNextIndex;
exports.getNextItem = getNextItem;
exports.getNextItemFromSearch = getNextItemFromSearch;
exports.getNextTabbable = getNextTabbable;
exports.getOwnerDocument = getOwnerDocument;
exports.getOwnerWindow = getOwnerWindow;
exports.getPointerEventName = getPointerEventName;
exports.getPrevIndex = getPrevIndex;
exports.getPrevItem = getPrevItem;
exports.getPreviousTabbable = getPreviousTabbable;
exports.getRelatedTarget = getRelatedTarget;
exports.getViewportPointFromEvent = getViewportPointFromEvent;
exports.getWithDefault = getWithDefault;
exports.hasDisplayNone = hasDisplayNone;
exports.hasFocusWithin = hasFocusWithin;
exports.hasNegativeTabIndex = hasNegativeTabIndex;
exports.hasTabIndex = hasTabIndex;
exports.isActiveElement = isActiveElement;
exports.isArray = isArray;
exports.isBrowser = isBrowser;
exports.isContentEditable = isContentEditable;
exports.isCssVar = isCssVar;
exports.isCustomBreakpoint = isCustomBreakpoint;
exports.isDefined = isDefined;
exports.isDisabled = isDisabled;
exports.isElement = isElement;
exports.isEmpty = isEmpty;
exports.isEmptyArray = isEmptyArray;
exports.isEmptyObject = isEmptyObject;
exports.isFocusable = isFocusable;
exports.isFunction = isFunction;
exports.isHTMLElement = isHTMLElement;
exports.isHidden = isHidden;
exports.isInputElement = isInputElement;
exports.isInputEvent = isInputEvent;
exports.isMouseEvent = isMouseEvent;
exports.isMultiTouchEvent = isMultiTouchEvent;
exports.isNotEmptyObject = isNotEmptyObject;
exports.isNotNumber = isNotNumber;
exports.isNull = isNull;
exports.isNumber = isNumber;
exports.isNumeric = isNumeric;
exports.isObject = isObject;
exports.isRefObject = isRefObject;
exports.isResponsiveObjectLike = isResponsiveObjectLike;
exports.isRightClick = isRightClick;
exports.isString = isString;
exports.isTabbable = isTabbable;
exports.isTouchEvent = isTouchEvent;
exports.isUndefined = isUndefined;
exports.mapResponsive = mapResponsive;
exports.maxSafeInteger = maxSafeInteger;
exports.memoize = memoize;
exports.memoizedGet = memoizedGet;
exports.minSafeInteger = minSafeInteger;
exports.noop = noop;
exports.normalizeEventKey = normalizeEventKey;
exports.objectFilter = objectFilter;
exports.objectKeys = objectKeys;
exports.objectToArrayNotation = objectToArrayNotation;
exports.omit = omit;
exports.once = once;
exports.percentToValue = percentToValue;
exports.pick = pick;
exports.pipe = pipe;
exports.px = px;
exports.removeIndex = removeIndex;
exports.removeItem = removeItem;
exports.roundValueToStep = roundValueToStep;
exports.runIfFn = runIfFn;
exports.split = split;
exports.toPrecision = toPrecision;
exports.valueToPercent = valueToPercent;
exports.walkObject = walkObject;
exports.warn = warn;
exports.wrapPointerEventHandler = wrapPointerEventHandler;
Object.keys(cssBoxModel).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return cssBoxModel[k];
    }
  });
});

/***/ }),
/* 160 */
/***/ (function(module, exports) {

module.exports = require("css-box-model");

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeMax = Math.max,
    nativeNow = Date.now;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = mergeWith;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(79)(module)))

/***/ }),
/* 162 */
/***/ (function(module, exports) {

module.exports = require("framesync");

/***/ }),
/* 163 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// NAMESPACE OBJECT: ./node_modules/.cache/nuxt/components/index.js
var components_namespaceObject = {};
__webpack_require__.r(components_namespaceObject);
__webpack_require__.d(components_namespaceObject, "NuxtLogo", function() { return NuxtLogo; });
__webpack_require__.d(components_namespaceObject, "Tutorial", function() { return Tutorial; });

// EXTERNAL MODULE: external "vue"
var external_vue_ = __webpack_require__(0);
var external_vue_default = /*#__PURE__*/__webpack_require__.n(external_vue_);

// EXTERNAL MODULE: external "ufo"
var external_ufo_ = __webpack_require__(7);

// EXTERNAL MODULE: external "node-fetch"
var external_node_fetch_ = __webpack_require__(91);
var external_node_fetch_default = /*#__PURE__*/__webpack_require__.n(external_node_fetch_);

// CONCATENATED MODULE: ./node_modules/.cache/nuxt/middleware.js
const middleware = {};
/* harmony default export */ var nuxt_middleware = (middleware);
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/utils.js

 // window.{{globals.loadedCallback}} hook
// Useful for jsdom testing or plugins (https://github.com/tmpvar/jsdom#dealing-with-asynchronous-script-loading)

if (false) {}

function createGetCounter(counterObject, defaultKey = '') {
  return function getCounter(id = defaultKey) {
    if (counterObject[id] === undefined) {
      counterObject[id] = 0;
    }

    return counterObject[id]++;
  };
}
function empty() {}
function globalHandleError(error) {
  if (external_vue_default.a.config.errorHandler) {
    external_vue_default.a.config.errorHandler(error);
  }
}
function interopDefault(promise) {
  return promise.then(m => m.default || m);
}
function hasFetch(vm) {
  return vm.$options && typeof vm.$options.fetch === 'function' && !vm.$options.fetch.length;
}
function purifyData(data) {
  if (true) {
    return data;
  }

  return Object.entries(data).filter(([key, value]) => {
    const valid = !(value instanceof Function) && !(value instanceof Promise);

    if (!valid) {
      console.warn(`${key} is not able to be stringified. This will break in a production environment.`);
    }

    return valid;
  }).reduce((obj, [key, value]) => {
    obj[key] = value;
    return obj;
  }, {});
}
function getChildrenComponentInstancesUsingFetch(vm, instances = []) {
  const children = vm.$children || [];

  for (const child of children) {
    if (child.$fetch) {
      instances.push(child);
      continue; // Don't get the children since it will reload the template
    }

    if (child.$children) {
      getChildrenComponentInstancesUsingFetch(child, instances);
    }
  }

  return instances;
}
function applyAsyncData(Component, asyncData) {
  if ( // For SSR, we once all this function without second param to just apply asyncData
  // Prevent doing this for each SSR request
  !asyncData && Component.options.__hasNuxtData) {
    return;
  }

  const ComponentData = Component.options._originDataFn || Component.options.data || function () {
    return {};
  };

  Component.options._originDataFn = ComponentData;

  Component.options.data = function () {
    const data = ComponentData.call(this, this);

    if (this.$ssrContext) {
      asyncData = this.$ssrContext.asyncData[Component.cid];
    }

    return { ...data,
      ...asyncData
    };
  };

  Component.options.__hasNuxtData = true;

  if (Component._Ctor && Component._Ctor.options) {
    Component._Ctor.options.data = Component.options.data;
  }
}
function sanitizeComponent(Component) {
  // If Component already sanitized
  if (Component.options && Component._Ctor === Component) {
    return Component;
  }

  if (!Component.options) {
    Component = external_vue_default.a.extend(Component); // fix issue #6

    Component._Ctor = Component;
  } else {
    Component._Ctor = Component;
    Component.extendOptions = Component.options;
  } // If no component name defined, set file path as name, (also fixes #5703)


  if (!Component.options.name && Component.options.__file) {
    Component.options.name = Component.options.__file;
  }

  return Component;
}
function getMatchedComponents(route, matches = false, prop = 'components') {
  return Array.prototype.concat.apply([], route.matched.map((m, index) => {
    return Object.keys(m[prop]).map(key => {
      matches && matches.push(index);
      return m[prop][key];
    });
  }));
}
function getMatchedComponentsInstances(route, matches = false) {
  return getMatchedComponents(route, matches, 'instances');
}
function flatMapComponents(route, fn) {
  return Array.prototype.concat.apply([], route.matched.map((m, index) => {
    return Object.keys(m.components).reduce((promises, key) => {
      if (m.components[key]) {
        promises.push(fn(m.components[key], m.instances[key], m, key, index));
      } else {
        delete m.components[key];
      }

      return promises;
    }, []);
  }));
}
function resolveRouteComponents(route, fn) {
  return Promise.all(flatMapComponents(route, async (Component, instance, match, key) => {
    // If component is a function, resolve it
    if (typeof Component === 'function' && !Component.options) {
      try {
        Component = await Component();
      } catch (error) {
        // Handle webpack chunk loading errors
        // This may be due to a new deployment or a network problem
        if (error && error.name === 'ChunkLoadError' && typeof window !== 'undefined' && window.sessionStorage) {
          const timeNow = Date.now();
          const previousReloadTime = parseInt(window.sessionStorage.getItem('nuxt-reload')); // check for previous reload time not to reload infinitely

          if (!previousReloadTime || previousReloadTime + 60000 < timeNow) {
            window.sessionStorage.setItem('nuxt-reload', timeNow);
            window.location.reload(true
            /* skip cache */
            );
          }
        }

        throw error;
      }
    }

    match.components[key] = Component = sanitizeComponent(Component);
    return typeof fn === 'function' ? fn(Component, instance, match, key) : Component;
  }));
}
async function getRouteData(route) {
  if (!route) {
    return;
  } // Make sure the components are resolved (code-splitting)


  await resolveRouteComponents(route); // Send back a copy of route with meta based on Component definition

  return { ...route,
    meta: getMatchedComponents(route).map((Component, index) => {
      return { ...Component.options.meta,
        ...(route.matched[index] || {}).meta
      };
    })
  };
}
async function setContext(app, context) {
  // If context not defined, create it
  if (!app.context) {
    app.context = {
      isStatic: true,
      isDev: false,
      isHMR: false,
      app,
      payload: context.payload,
      error: context.error,
      base: app.router.options.base,
      env: {}
    }; // Only set once

    if (context.ssrContext) {
      app.context.ssrContext = context.ssrContext;
    }

    app.context.redirect = (status, path, query) => {
      if (!status) {
        return;
      }

      app.context._redirected = true; // if only 1 or 2 arguments: redirect('/') or redirect('/', { foo: 'bar' })

      let pathType = typeof path;

      if (typeof status !== 'number' && (pathType === 'undefined' || pathType === 'object')) {
        query = path || {};
        path = status;
        pathType = typeof path;
        status = 302;
      }

      if (pathType === 'object') {
        path = app.router.resolve(path).route.fullPath;
      } // "/absolute/route", "./relative/route" or "../relative/route"


      if (/(^[.]{1,2}\/)|(^\/(?!\/))/.test(path)) {
        app.context.next({
          path,
          query,
          status
        });
      } else {
        path = Object(external_ufo_["withQuery"])(path, query);

        if (true) {
          app.context.next({
            path,
            status
          });
        }

        if (false) {}
      }
    };

    if (true) {
      app.context.beforeNuxtRender = fn => context.beforeRenderFns.push(fn);
    }

    if (false) {}
  } // Dynamic keys


  const [currentRouteData, fromRouteData] = await Promise.all([getRouteData(context.route), getRouteData(context.from)]);

  if (context.route) {
    app.context.route = currentRouteData;
  }

  if (context.from) {
    app.context.from = fromRouteData;
  }

  app.context.next = context.next;
  app.context._redirected = false;
  app.context._errored = false;
  app.context.isHMR = false;
  app.context.params = app.context.route.params || {};
  app.context.query = app.context.route.query || {};
}
function middlewareSeries(promises, appContext) {
  if (!promises.length || appContext._redirected || appContext._errored) {
    return Promise.resolve();
  }

  return promisify(promises[0], appContext).then(() => {
    return middlewareSeries(promises.slice(1), appContext);
  });
}
function promisify(fn, context) {
  let promise;

  if (fn.length === 2) {
    // fn(context, callback)
    promise = new Promise(resolve => {
      fn(context, function (err, data) {
        if (err) {
          context.error(err);
        }

        data = data || {};
        resolve(data);
      });
    });
  } else {
    promise = fn(context);
  }

  if (promise && promise instanceof Promise && typeof promise.then === 'function') {
    return promise;
  }

  return Promise.resolve(promise);
} // Imported from vue-router

function getLocation(base, mode) {
  if (mode === 'hash') {
    return window.location.hash.replace(/^#\//, '');
  }

  base = decodeURI(base).slice(0, -1); // consideration is base is normalized with trailing slash

  let path = decodeURI(window.location.pathname);

  if (base && path.startsWith(base)) {
    path = path.slice(base.length);
  }

  const fullPath = (path || '/') + window.location.search + window.location.hash;
  return Object(external_ufo_["normalizeURL"])(fullPath);
} // Imported from path-to-regexp

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */

function compile(str, options) {
  return tokensToFunction(parse(str, options), options);
}
function getQueryDiff(toQuery, fromQuery) {
  const diff = {};
  const queries = { ...toQuery,
    ...fromQuery
  };

  for (const k in queries) {
    if (String(toQuery[k]) !== String(fromQuery[k])) {
      diff[k] = true;
    }
  }

  return diff;
}
function normalizeError(err) {
  let message;

  if (!(err.message || typeof err === 'string')) {
    try {
      message = JSON.stringify(err, null, 2);
    } catch (e) {
      message = `[${err.constructor.name}]`;
    }
  } else {
    message = err.message || err;
  }

  return { ...err,
    message,
    statusCode: err.statusCode || err.status || err.response && err.response.status || 500
  };
}
/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */

const PATH_REGEXP = new RegExp([// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)', // Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');
/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */

function parse(str, options) {
  const tokens = [];
  let key = 0;
  let index = 0;
  let path = '';
  const defaultDelimiter = options && options.delimiter || '/';
  let res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    const m = res[0];
    const escaped = res[1];
    const offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length; // Ignore already escaped sequences.

    if (escaped) {
      path += escaped[1];
      continue;
    }

    const next = str[index];
    const prefix = res[2];
    const name = res[3];
    const capture = res[4];
    const group = res[5];
    const modifier = res[6];
    const asterisk = res[7]; // Push the current path onto the tokens.

    if (path) {
      tokens.push(path);
      path = '';
    }

    const partial = prefix != null && next != null && next !== prefix;
    const repeat = modifier === '+' || modifier === '*';
    const optional = modifier === '?' || modifier === '*';
    const delimiter = res[2] || defaultDelimiter;
    const pattern = capture || group;
    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter,
      optional,
      repeat,
      partial,
      asterisk: Boolean(asterisk),
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  } // Match any characters still remaining.


  if (index < str.length) {
    path += str.substr(index);
  } // If the path exists, push it onto the end.


  if (path) {
    tokens.push(path);
  }

  return tokens;
}
/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */


function encodeURIComponentPretty(str, slashAllowed) {
  const re = slashAllowed ? /[?#]/g : /[/?#]/g;
  return encodeURI(str).replace(re, c => {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */


function encodeAsterisk(str) {
  return encodeURIComponentPretty(str, true);
}
/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */


function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1');
}
/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */


function escapeGroup(group) {
  return group.replace(/([=!:$/()])/g, '\\$1');
}
/**
 * Expose a method for transforming tokens into the path function.
 */


function tokensToFunction(tokens, options) {
  // Compile all the tokens into regexps.
  const matches = new Array(tokens.length); // Compile all the patterns before compilation.

  for (let i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));
    }
  }

  return function (obj, opts) {
    let path = '';
    const data = obj || {};
    const options = opts || {};
    const encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];

      if (typeof token === 'string') {
        path += token;
        continue;
      }

      const value = data[token.name || 'pathMatch'];
      let segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (Array.isArray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (let j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}
/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */


function flags(options) {
  return options && options.sensitive ? '' : 'i';
}

function addLifecycleHook(vm, hook, fn) {
  if (!vm.$options[hook]) {
    vm.$options[hook] = [];
  }

  if (!vm.$options[hook].includes(fn)) {
    vm.$options[hook].push(fn);
  }
}
const urlJoin = external_ufo_["joinURL"];
const stripTrailingSlash = external_ufo_["withoutTrailingSlash"];
const isSamePath = external_ufo_["isSamePath"];
function setScrollRestoration(newVal) {
  try {
    window.history.scrollRestoration = newVal;
  } catch (e) {}
}
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/mixins/fetch.server.js



async function serverPrefetch() {
  if (!this._fetchOnServer) {
    return;
  } // Call and await on $fetch


  try {
    await this.$options.fetch.call(this);
  } catch (err) {
    if (false) {}

    this.$fetchState.error = normalizeError(err);
  }

  this.$fetchState.pending = false; // Define an ssrKey for hydration

  this._fetchKey = this._fetchKey || this.$ssrContext.fetchCounters['']++; // Add data-fetch-key on parent element of Component

  const attrs = this.$vnode.data.attrs = this.$vnode.data.attrs || {};
  attrs['data-fetch-key'] = this._fetchKey; // Add to ssrContext for window.__NUXT__.fetch

  this.$ssrContext.nuxt.fetch[this._fetchKey] = this.$fetchState.error ? {
    _error: this.$fetchState.error
  } : purifyData(this._data);
}

/* harmony default export */ var fetch_server = ({
  created() {
    if (!hasFetch(this)) {
      return;
    }

    if (typeof this.$options.fetchOnServer === 'function') {
      this._fetchOnServer = this.$options.fetchOnServer.call(this) !== false;
    } else {
      this._fetchOnServer = this.$options.fetchOnServer !== false;
    }

    const defaultKey = this.$options._scopeId || this.$options.name || '';
    const getCounter = createGetCounter(this.$ssrContext.fetchCounters, defaultKey);

    if (typeof this.$options.fetchKey === 'function') {
      this._fetchKey = this.$options.fetchKey.call(this, getCounter);
    } else {
      const key = 'string' === typeof this.$options.fetchKey ? this.$options.fetchKey : defaultKey;
      this._fetchKey = key ? key + ':' + getCounter(key) : String(getCounter(key));
    } // Added for remove vue undefined warning while ssr


    this.$fetch = () => {}; // issue #8043


    external_vue_default.a.util.defineReactive(this, '$fetchState', {
      pending: true,
      error: null,
      timestamp: Date.now()
    });
    addLifecycleHook(this, 'serverPrefetch', serverPrefetch);
  }

});
// EXTERNAL MODULE: external "vue-meta"
var external_vue_meta_ = __webpack_require__(92);
var external_vue_meta_default = /*#__PURE__*/__webpack_require__.n(external_vue_meta_);

// EXTERNAL MODULE: external "vue-client-only"
var external_vue_client_only_ = __webpack_require__(72);
var external_vue_client_only_default = /*#__PURE__*/__webpack_require__.n(external_vue_client_only_);

// EXTERNAL MODULE: external "vue-no-ssr"
var external_vue_no_ssr_ = __webpack_require__(64);
var external_vue_no_ssr_default = /*#__PURE__*/__webpack_require__.n(external_vue_no_ssr_);

// EXTERNAL MODULE: external "vue-router"
var external_vue_router_ = __webpack_require__(73);
var external_vue_router_default = /*#__PURE__*/__webpack_require__.n(external_vue_router_);

// CONCATENATED MODULE: ./node_modules/.cache/nuxt/router.scrollBehavior.js


if (false) {}

function shouldScrollToTop(route) {
  const Pages = getMatchedComponents(route);

  if (Pages.length === 1) {
    const {
      options = {}
    } = Pages[0];
    return options.scrollToTop !== false;
  }

  return Pages.some(({
    options
  }) => options && options.scrollToTop);
}

/* harmony default export */ var router_scrollBehavior = (function (to, from, savedPosition) {
  // If the returned position is falsy or an empty object, will retain current scroll position
  let position = false;
  const isRouteChanged = to !== from; // savedPosition is only available for popstate navigations (back button)

  if (savedPosition) {
    position = savedPosition;
  } else if (isRouteChanged && shouldScrollToTop(to)) {
    position = {
      x: 0,
      y: 0
    };
  }

  const nuxt = window.$nuxt;

  if ( // Initial load (vuejs/vue-router#3199)
  !isRouteChanged || // Route hash changes
  to.path === from.path && to.hash !== from.hash) {
    nuxt.$nextTick(() => nuxt.$emit('triggerScroll'));
  }

  return new Promise(resolve => {
    // wait for the out transition to complete (if necessary)
    nuxt.$once('triggerScroll', () => {
      // coords will be used if no selector is provided,
      // or if the selector didn't match any element.
      if (to.hash) {
        let hash = to.hash; // CSS.escape() is not supported with IE and Edge.

        if (typeof window.CSS !== 'undefined' && typeof window.CSS.escape !== 'undefined') {
          hash = '#' + window.CSS.escape(hash.substr(1));
        }

        try {
          if (document.querySelector(hash)) {
            // scroll to anchor by returning the selector
            position = {
              selector: hash
            };
          }
        } catch (e) {
          console.warn('Failed to save scroll position. Please add CSS.escape() polyfill (https://github.com/mathiasbynens/CSS.escape).');
        }
      }

      resolve(position);
    });
  });
});
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/router.js






const _0863c453 = () => interopDefault(__webpack_require__.e(/* import() | pages/index */ 3).then(__webpack_require__.bind(null, 173)));

const emptyFn = () => {};

external_vue_default.a.use(external_vue_router_default.a);
const routerOptions = {
  mode: 'history',
  base: '/',
  linkActiveClass: 'nuxt-link-active',
  linkExactActiveClass: 'nuxt-link-exact-active',
  scrollBehavior: router_scrollBehavior,
  routes: [{
    path: "/",
    component: _0863c453,
    name: "index"
  }],
  fallback: false
};
function createRouter(ssrContext, config) {
  const base = config._app && config._app.basePath || routerOptions.base;
  const router = new external_vue_router_default.a({ ...routerOptions,
    base
  }); // TODO: remove in Nuxt 3

  const originalPush = router.push;

  router.push = function push(location, onComplete = emptyFn, onAbort) {
    return originalPush.call(this, location, onComplete, onAbort);
  };

  const resolve = router.resolve.bind(router);

  router.resolve = (to, current, append) => {
    if (typeof to === 'string') {
      to = Object(external_ufo_["normalizeURL"])(to);
    }

    return resolve(to, current, append);
  };

  return router;
}
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-child.js
/* harmony default export */ var nuxt_child = ({
  name: 'NuxtChild',
  functional: true,
  props: {
    nuxtChildKey: {
      type: String,
      default: ''
    },
    keepAlive: Boolean,
    keepAliveProps: {
      type: Object,
      default: undefined
    }
  },

  render(_, {
    parent,
    data,
    props
  }) {
    const h = parent.$createElement;
    data.nuxtChild = true;
    const _parent = parent;
    const transitions = parent.$nuxt.nuxt.transitions;
    const defaultTransition = parent.$nuxt.nuxt.defaultTransition;
    let depth = 0;

    while (parent) {
      if (parent.$vnode && parent.$vnode.data.nuxtChild) {
        depth++;
      }

      parent = parent.$parent;
    }

    data.nuxtChildDepth = depth;
    const transition = transitions[depth] || defaultTransition;
    const transitionProps = {};
    transitionsKeys.forEach(key => {
      if (typeof transition[key] !== 'undefined') {
        transitionProps[key] = transition[key];
      }
    });
    const listeners = {};
    listenersKeys.forEach(key => {
      if (typeof transition[key] === 'function') {
        listeners[key] = transition[key].bind(_parent);
      }
    });

    if (false) {} // make sure that leave is called asynchronous (fix #5703)


    if (transition.css === false) {
      const leave = listeners.leave; // only add leave listener when user didnt provide one
      // or when it misses the done argument

      if (!leave || leave.length < 2) {
        listeners.leave = (el, done) => {
          if (leave) {
            leave.call(_parent, el);
          }

          _parent.$nextTick(done);
        };
      }
    }

    let routerView = h('routerView', data);

    if (props.keepAlive) {
      routerView = h('keep-alive', {
        props: props.keepAliveProps
      }, [routerView]);
    }

    return h('transition', {
      props: transitionProps,
      on: listeners
    }, [routerView]);
  }

});
const transitionsKeys = ['name', 'mode', 'appear', 'css', 'type', 'duration', 'enterClass', 'leaveClass', 'appearClass', 'enterActiveClass', 'enterActiveClass', 'leaveActiveClass', 'appearActiveClass', 'enterToClass', 'leaveToClass', 'appearToClass'];
const listenersKeys = ['beforeEnter', 'enter', 'afterEnter', 'enterCancelled', 'beforeLeave', 'leave', 'afterLeave', 'leaveCancelled', 'beforeAppear', 'appear', 'afterAppear', 'appearCancelled'];
// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--2!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./node_modules/.cache/nuxt/components/nuxt-error.vue?vue&type=template&id=608a1420&
var render = function render() {
  var _vm = this,
      _c = _vm._self._c;

  return _c('div', {
    staticClass: "__nuxt-error-page"
  }, [_vm._ssrNode("<div class=\"error\">", "</div>", [_vm._ssrNode("<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"90\" height=\"90\" fill=\"#DBE1EC\" viewBox=\"0 0 48 48\"><path d=\"M22 30h4v4h-4zm0-16h4v12h-4zm1.99-10C12.94 4 4 12.95 4 24s8.94 20 19.99 20S44 35.05 44 24 35.04 4 23.99 4zM24 40c-8.84 0-16-7.16-16-16S15.16 8 24 8s16 7.16 16 16-7.16 16-16 16z\"></path></svg> <div class=\"title\">" + _vm._ssrEscape(_vm._s(_vm.message)) + "</div> "), _vm.statusCode === 404 ? _vm._ssrNode("<p class=\"description\">", "</p>", [typeof _vm.$route === 'undefined' ? _vm._ssrNode("<a href=\"/\" class=\"error-link\">", "</a>") : _c('NuxtLink', {
    staticClass: "error-link",
    attrs: {
      "to": "/"
    }
  }, [_vm._v("Back to the home page")])], 1) : _vm._e(), _vm._ssrNode(" <div class=\"logo\"><a href=\"https://nuxtjs.org\" target=\"_blank\" rel=\"noopener\">Nuxt</a></div>")], 2)]);
};

var staticRenderFns = [];

// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-error.vue?vue&type=template&id=608a1420&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./node_modules/.cache/nuxt/components/nuxt-error.vue?vue&type=script&lang=js&
/* harmony default export */ var nuxt_errorvue_type_script_lang_js_ = ({
  name: 'NuxtError',
  props: {
    error: {
      type: Object,
      default: null
    }
  },
  computed: {
    statusCode() {
      return this.error && this.error.statusCode || 500;
    },

    message() {
      return this.error.message || 'Error';
    }

  },

  head() {
    return {
      title: this.message,
      meta: [{
        name: 'viewport',
        content: 'width=device-width,initial-scale=1.0,minimum-scale=1.0'
      }]
    };
  }

});
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-error.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_nuxt_errorvue_type_script_lang_js_ = (nuxt_errorvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(19);

// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-error.vue



function injectStyles (context) {
  
  var style0 = __webpack_require__(97)
if (style0.__inject__) style0.__inject__(context)

}

/* normalize component */

var nuxt_error_component = Object(componentNormalizer["a" /* default */])(
  components_nuxt_errorvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  injectStyles,
  null,
  "1374a755"
  
)

/* harmony default export */ var nuxt_error = (nuxt_error_component.exports);
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt.js




/* harmony default export */ var components_nuxt = ({
  name: 'Nuxt',
  components: {
    NuxtChild: nuxt_child,
    NuxtError: nuxt_error
  },
  props: {
    nuxtChildKey: {
      type: String,
      default: undefined
    },
    keepAlive: Boolean,
    keepAliveProps: {
      type: Object,
      default: undefined
    },
    name: {
      type: String,
      default: 'default'
    }
  },

  errorCaptured(error) {
    // if we receive and error while showing the NuxtError component
    // capture the error and force an immediate update so we re-render
    // without the NuxtError component
    if (this.displayingNuxtError) {
      this.errorFromNuxtError = error;
      this.$forceUpdate();
    }
  },

  computed: {
    routerViewKey() {
      // If nuxtChildKey prop is given or current route has children
      if (typeof this.nuxtChildKey !== 'undefined' || this.$route.matched.length > 1) {
        return this.nuxtChildKey || compile(this.$route.matched[0].path)(this.$route.params);
      }

      const [matchedRoute] = this.$route.matched;

      if (!matchedRoute) {
        return this.$route.path;
      }

      const Component = matchedRoute.components.default;

      if (Component && Component.options) {
        const {
          options
        } = Component;

        if (options.key) {
          return typeof options.key === 'function' ? options.key(this.$route) : options.key;
        }
      }

      const strict = /\/$/.test(matchedRoute.path);
      return strict ? this.$route.path : this.$route.path.replace(/\/$/, '');
    }

  },

  beforeCreate() {
    external_vue_default.a.util.defineReactive(this, 'nuxt', this.$root.$options.nuxt);
  },

  render(h) {
    // if there is no error
    if (!this.nuxt.err) {
      // Directly return nuxt child
      return h('NuxtChild', {
        key: this.routerViewKey,
        props: this.$props
      });
    } // if an error occurred within NuxtError show a simple
    // error message instead to prevent looping


    if (this.errorFromNuxtError) {
      this.$nextTick(() => this.errorFromNuxtError = false);
      return h('div', {}, [h('h2', 'An error occurred while showing the error page'), h('p', 'Unfortunately an error occurred and while showing the error page another error occurred'), h('p', `Error details: ${this.errorFromNuxtError.toString()}`), h('nuxt-link', {
        props: {
          to: '/'
        }
      }, 'Go back to home')]);
    } // track if we are showing the NuxtError component


    this.displayingNuxtError = true;
    this.$nextTick(() => this.displayingNuxtError = false);
    return h(nuxt_error, {
      props: {
        error: this.nuxt.err
      }
    });
  }

});
// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./node_modules/.cache/nuxt/components/nuxt-loading.vue?vue&type=script&lang=js&
/* harmony default export */ var nuxt_loadingvue_type_script_lang_js_ = ({
  name: 'NuxtLoading',

  data() {
    return {
      percent: 0,
      show: false,
      canSucceed: true,
      reversed: false,
      skipTimerCount: 0,
      rtl: false,
      throttle: 200,
      duration: 5000,
      continuous: false
    };
  },

  computed: {
    left() {
      if (!this.continuous && !this.rtl) {
        return false;
      }

      return this.rtl ? this.reversed ? '0px' : 'auto' : !this.reversed ? '0px' : 'auto';
    }

  },

  beforeDestroy() {
    this.clear();
  },

  methods: {
    clear() {
      clearInterval(this._timer);
      clearTimeout(this._throttle);
      this._timer = null;
    },

    start() {
      this.clear();
      this.percent = 0;
      this.reversed = false;
      this.skipTimerCount = 0;
      this.canSucceed = true;

      if (this.throttle) {
        this._throttle = setTimeout(() => this.startTimer(), this.throttle);
      } else {
        this.startTimer();
      }

      return this;
    },

    set(num) {
      this.show = true;
      this.canSucceed = true;
      this.percent = Math.min(100, Math.max(0, Math.floor(num)));
      return this;
    },

    get() {
      return this.percent;
    },

    increase(num) {
      this.percent = Math.min(100, Math.floor(this.percent + num));
      return this;
    },

    decrease(num) {
      this.percent = Math.max(0, Math.floor(this.percent - num));
      return this;
    },

    pause() {
      clearInterval(this._timer);
      return this;
    },

    resume() {
      this.startTimer();
      return this;
    },

    finish() {
      this.percent = this.reversed ? 0 : 100;
      this.hide();
      return this;
    },

    hide() {
      this.clear();
      setTimeout(() => {
        this.show = false;
        this.$nextTick(() => {
          this.percent = 0;
          this.reversed = false;
        });
      }, 500);
      return this;
    },

    fail(error) {
      this.canSucceed = false;
      return this;
    },

    startTimer() {
      if (!this.show) {
        this.show = true;
      }

      if (typeof this._cut === 'undefined') {
        this._cut = 10000 / Math.floor(this.duration);
      }

      this._timer = setInterval(() => {
        /**
         * When reversing direction skip one timers
         * so 0, 100 are displayed for two iterations
         * also disable css width transitioning
         * which otherwise interferes and shows
         * a jojo effect
         */
        if (this.skipTimerCount > 0) {
          this.skipTimerCount--;
          return;
        }

        if (this.reversed) {
          this.decrease(this._cut);
        } else {
          this.increase(this._cut);
        }

        if (this.continuous) {
          if (this.percent >= 100) {
            this.skipTimerCount = 1;
            this.reversed = !this.reversed;
          } else if (this.percent <= 0) {
            this.skipTimerCount = 1;
            this.reversed = !this.reversed;
          }
        }
      }, 100);
    }

  },

  render(h) {
    let el = h(false);

    if (this.show) {
      el = h('div', {
        staticClass: 'nuxt-progress',
        class: {
          'nuxt-progress-notransition': this.skipTimerCount > 0,
          'nuxt-progress-failed': !this.canSucceed
        },
        style: {
          width: this.percent + '%',
          left: this.left
        }
      });
    }

    return el;
  }

});
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-loading.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_nuxt_loadingvue_type_script_lang_js_ = (nuxt_loadingvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-loading.vue
var nuxt_loading_render, nuxt_loading_staticRenderFns


function nuxt_loading_injectStyles (context) {
  
  var style0 = __webpack_require__(99)
if (style0.__inject__) style0.__inject__(context)

}

/* normalize component */

var nuxt_loading_component = Object(componentNormalizer["a" /* default */])(
  components_nuxt_loadingvue_type_script_lang_js_,
  nuxt_loading_render,
  nuxt_loading_staticRenderFns,
  false,
  nuxt_loading_injectStyles,
  null,
  "7f3f2349"
  
)

/* harmony default export */ var nuxt_loading = (nuxt_loading_component.exports);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--2!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./layouts/default.vue?vue&type=template&id=363d9d1d&
var defaultvue_type_template_id_363d9d1d_render = function render() {
  var _vm = this,
      _c = _vm._self._c;

  return _c('div', {
    staticClass: "container"
  }, [_c('CThemeProvider', [_c('CColorModeProvider', [_c('CBox', {
    attrs: {
      "font-family": "body",
      "as": "main"
    }
  }, [_c('CReset'), _vm._v(" "), _c('Nuxt')], 1)], 1)], 1)], 1);
};

var defaultvue_type_template_id_363d9d1d_staticRenderFns = [];

// CONCATENATED MODULE: ./layouts/default.vue?vue&type=template&id=363d9d1d&

// EXTERNAL MODULE: ./node_modules/@chakra-ui/vue/dist/cjs/index.js
var cjs = __webpack_require__(11);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./layouts/default.vue?vue&type=script&lang=js&

/* harmony default export */ var defaultvue_type_script_lang_js_ = ({
  name: 'DefaultLayout',
  components: {
    CThemeProvider: cjs["CThemeProvider"],
    CColorModeProvider: cjs["CColorModeProvider"],
    CReset: cjs["CReset"],
    CBox: cjs["CBox"]
  }
});
// CONCATENATED MODULE: ./layouts/default.vue?vue&type=script&lang=js&
 /* harmony default export */ var layouts_defaultvue_type_script_lang_js_ = (defaultvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./layouts/default.vue





/* normalize component */

var default_component = Object(componentNormalizer["a" /* default */])(
  layouts_defaultvue_type_script_lang_js_,
  defaultvue_type_template_id_363d9d1d_render,
  defaultvue_type_template_id_363d9d1d_staticRenderFns,
  false,
  null,
  null,
  "bed07492"
  
)

/* harmony default export */ var layouts_default = (default_component.exports);

/* chakra-loader */
const installChakraComponents = __webpack_require__(146)
installChakraComponents(default_component, {CReset: __webpack_require__(11).CReset, CBox: __webpack_require__(11).CBox, CColorModeProvider: __webpack_require__(11).CColorModeProvider, CThemeProvider: __webpack_require__(11).CThemeProvider})

// CONCATENATED MODULE: ./node_modules/.cache/nuxt/App.js






const layouts = {
  "_default": sanitizeComponent(layouts_default)
};
/* harmony default export */ var App = ({
  render(h, props) {
    const loadingEl = h('NuxtLoading', {
      ref: 'loading'
    });
    const layoutEl = h(this.layout || 'nuxt');
    const templateEl = h('div', {
      domProps: {
        id: '__layout'
      },
      key: this.layoutName
    }, [layoutEl]);
    const transitionEl = h('transition', {
      props: {
        name: 'layout',
        mode: 'out-in'
      },
      on: {
        beforeEnter(el) {
          // Ensure to trigger scroll event after calling scrollBehavior
          window.$nuxt.$nextTick(() => {
            window.$nuxt.$emit('triggerScroll');
          });
        }

      }
    }, [templateEl]);
    return h('div', {
      domProps: {
        id: '__nuxt'
      }
    }, [loadingEl, transitionEl]);
  },

  data: () => ({
    isOnline: true,
    layout: null,
    layoutName: '',
    nbFetching: 0
  }),

  beforeCreate() {
    external_vue_default.a.util.defineReactive(this, 'nuxt', this.$options.nuxt);
  },

  created() {
    // Add this.$nuxt in child instances
    this.$root.$options.$nuxt = this;

    if (false) {} // Add $nuxt.error()


    this.error = this.nuxt.error; // Add $nuxt.context

    this.context = this.$options.context;
  },

  async mounted() {
    this.$loading = this.$refs.loading;

    if (this.isPreview) {
      if (this.$store && this.$store._actions.nuxtServerInit) {
        this.$loading.start();
        await this.$store.dispatch('nuxtServerInit', this.context);
      }

      await this.refresh();
      this.$loading.finish();
    }
  },

  watch: {
    'nuxt.err': 'errorChanged'
  },
  computed: {
    isOffline() {
      return !this.isOnline;
    },

    isFetching() {
      return this.nbFetching > 0;
    },

    isPreview() {
      return Boolean(this.$options.previewData);
    }

  },
  methods: {
    refreshOnlineStatus() {
      if (false) {}
    },

    async refresh() {
      const pages = getMatchedComponentsInstances(this.$route);

      if (!pages.length) {
        return;
      }

      this.$loading.start();
      const promises = pages.map(page => {
        const p = []; // Old fetch

        if (page.$options.fetch && page.$options.fetch.length) {
          p.push(promisify(page.$options.fetch, this.context));
        }

        if (page.$fetch) {
          p.push(page.$fetch());
        } else {
          // Get all component instance to call $fetch
          for (const component of getChildrenComponentInstancesUsingFetch(page.$vnode.componentInstance)) {
            p.push(component.$fetch());
          }
        }

        if (page.$options.asyncData) {
          p.push(promisify(page.$options.asyncData, this.context).then(newData => {
            for (const key in newData) {
              external_vue_default.a.set(page.$data, key, newData[key]);
            }
          }));
        }

        return Promise.all(p);
      });

      try {
        await Promise.all(promises);
      } catch (error) {
        this.$loading.fail(error);
        globalHandleError(error);
        this.error(error);
      }

      this.$loading.finish();
    },

    errorChanged() {
      if (this.nuxt.err) {
        if (this.$loading) {
          if (this.$loading.fail) {
            this.$loading.fail(this.nuxt.err);
          }

          if (this.$loading.finish) {
            this.$loading.finish();
          }
        }

        let errorLayout = (nuxt_error.options || nuxt_error).layout;

        if (typeof errorLayout === 'function') {
          errorLayout = errorLayout(this.context);
        }

        this.setLayout(errorLayout);
      }
    },

    setLayout(layout) {
      if (!layout || !layouts['_' + layout]) {
        layout = 'default';
      }

      this.layoutName = layout;
      this.layout = layouts['_' + layout];
      return this.layout;
    },

    loadLayout(layout) {
      if (!layout || !layouts['_' + layout]) {
        layout = 'default';
      }

      return Promise.resolve(layouts['_' + layout]);
    },

    getRouterBase() {
      return Object(external_ufo_["withoutTrailingSlash"])(this.$router.options.base);
    },

    getRoutePath(route = '/') {
      const base = this.getRouterBase();
      return Object(external_ufo_["withoutTrailingSlash"])(Object(external_ufo_["withoutBase"])(Object(external_ufo_["parsePath"])(route).pathname, base));
    },

    getStaticAssetsPath(route = '/') {
      const {
        staticAssetsBase
      } = window.__NUXT__;
      return urlJoin(staticAssetsBase, this.getRoutePath(route));
    },

    async fetchStaticManifest() {
      return window.__NUXT_IMPORT__('manifest.js', Object(external_ufo_["normalizeURL"])(urlJoin(this.getStaticAssetsPath(), 'manifest.js')));
    },

    setPagePayload(payload) {
      this._pagePayload = payload;
      this._fetchCounters = {};
    },

    async fetchPayload(route, prefetch) {
      const path = Object(external_ufo_["decode"])(this.getRoutePath(route));
      const manifest = await this.fetchStaticManifest();

      if (!manifest.routes.includes(path)) {
        if (!prefetch) {
          this.setPagePayload(false);
        }

        throw new Error(`Route ${path} is not pre-rendered`);
      }

      const src = urlJoin(this.getStaticAssetsPath(route), 'payload.js');

      try {
        const payload = await window.__NUXT_IMPORT__(path, Object(external_ufo_["normalizeURL"])(src));

        if (!prefetch) {
          this.setPagePayload(payload);
        }

        return payload;
      } catch (err) {
        if (!prefetch) {
          this.setPagePayload(false);
        }

        throw err;
      }
    }

  },
  components: {
    NuxtLoading: nuxt_loading
  }
});
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/index.js
const NuxtLogo = () => __webpack_require__.e(/* import() | components/nuxt-logo */ 1).then(__webpack_require__.bind(null, 175)).then(c => wrapFunctional(c.default || c));
const Tutorial = () => __webpack_require__.e(/* import() | components/tutorial */ 2).then(__webpack_require__.bind(null, 174)).then(c => wrapFunctional(c.default || c)); // nuxt/nuxt.js#8607

function wrapFunctional(options) {
  if (!options || !options.functional) {
    return options;
  }

  const propKeys = Array.isArray(options.props) ? options.props : Object.keys(options.props || {});
  return {
    render(h) {
      const attrs = {};
      const props = {};

      for (const key in this.$attrs) {
        if (propKeys.includes(key)) {
          props[key] = this.$attrs[key];
        } else {
          attrs[key] = this.$attrs[key];
        }
      }

      return h(options, {
        on: this.$listeners,
        attrs,
        props,
        scopedSlots: this.$scopedSlots
      }, this.$slots.default);
    }

  };
}
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/plugin.js



for (const name in components_namespaceObject) {
  external_vue_default.a.component(name, components_namespaceObject[name]);
  external_vue_default.a.component('Lazy' + name, components_namespaceObject[name]);
}
// EXTERNAL MODULE: ./node_modules/.cache/nuxt/empty.js
var nuxt_empty = __webpack_require__(147);

// EXTERNAL MODULE: external "@emotion/css"
var css_ = __webpack_require__(1);

// EXTERNAL MODULE: ./node_modules/@chakra-ui/styled-system/dist/chakra-ui-styled-system.cjs.js
var chakra_ui_styled_system_cjs = __webpack_require__(23);

// CONCATENATED MODULE: ./node_modules/@chakra-ui/vue/src/Css/Css.js

/**
 * Build a CSS factory function, to create CSS object by given a theme
 * @param {Object} styleProps Styles object
 * @returns {Function} (theme) => CSSStyleObject
 */

const buildCssFn = styleProps => Object(chakra_ui_styled_system_cjs["css"])(styleProps);

/* harmony default export */ var Css = (buildCssFn);
// CONCATENATED MODULE: ./node_modules/@chakra-ui/vue/src/Css/index.js

/* harmony default export */ var src_Css = (Css);
// CONCATENATED MODULE: ./node_modules/@chakra-ui/vue/src/utils/strings.js
/**
 * @description Returns the substring after a certain character in a string.
 * @param {'String'} string
 * @param {'String'} char
 */
function getSubstringAfterChar(string, char) {
  return string.slice(string.indexOf(char) + 1);
}
/**
 * @description Returns the substring before a certain character in a string.
 * @param {'String'} string
 * @param {'String'} char
 */

function getSubstringBeforeChar(string, char) {
  return string.slice(0, string.indexOf(char));
}
/**
 * Transforms a string to Kebab case
 * @param {String} text String to transform to kebab case
 */

function kebabify(text) {
  return text && text.match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g).map(x => x.toLowerCase()).join('-');
}
/**
 * Converts a kebab-case string into camel case
 * @param {String} string
 */

function camelize(string) {
  return string.replace(/[.-](\w|$)/g, function (_, x) {
    return x.toUpperCase();
  });
}
// CONCATENATED MODULE: ./node_modules/lodash-es/_arrayMap.js
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

/* harmony default export */ var _arrayMap = (arrayMap);
// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheClear.js
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/* harmony default export */ var _listCacheClear = (listCacheClear);
// CONCATENATED MODULE: ./node_modules/lodash-es/eq.js
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/* harmony default export */ var lodash_es_eq = (eq);
// CONCATENATED MODULE: ./node_modules/lodash-es/_assocIndexOf.js

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (lodash_es_eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

/* harmony default export */ var _assocIndexOf = (assocIndexOf);
// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheDelete.js

/** Used for built-in method references. */

var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

/* harmony default export */ var _listCacheDelete = (listCacheDelete);
// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheGet.js

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function listCacheGet(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

/* harmony default export */ var _listCacheGet = (listCacheGet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheHas.js

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function listCacheHas(key) {
  return _assocIndexOf(this.__data__, key) > -1;
}

/* harmony default export */ var _listCacheHas = (listCacheHas);
// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheSet.js

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */

function listCacheSet(key, value) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

/* harmony default export */ var _listCacheSet = (listCacheSet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_ListCache.js





/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = _listCacheClear;
ListCache.prototype['delete'] = _listCacheDelete;
ListCache.prototype.get = _listCacheGet;
ListCache.prototype.has = _listCacheHas;
ListCache.prototype.set = _listCacheSet;
/* harmony default export */ var _ListCache = (ListCache);
// CONCATENATED MODULE: ./node_modules/lodash-es/_stackClear.js

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */

function stackClear() {
  this.__data__ = new _ListCache();
  this.size = 0;
}

/* harmony default export */ var _stackClear = (stackClear);
// CONCATENATED MODULE: ./node_modules/lodash-es/_stackDelete.js
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

/* harmony default export */ var _stackDelete = (stackDelete);
// CONCATENATED MODULE: ./node_modules/lodash-es/_stackGet.js
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/* harmony default export */ var _stackGet = (stackGet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_stackHas.js
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/* harmony default export */ var _stackHas = (stackHas);
// EXTERNAL MODULE: ./node_modules/lodash-es/_root.js
var _root = __webpack_require__(10);

// CONCATENATED MODULE: ./node_modules/lodash-es/_Symbol.js

/** Built-in value references. */

var Symbol = _root["a" /* default */].Symbol;
/* harmony default export */ var _Symbol = (Symbol);
// CONCATENATED MODULE: ./node_modules/lodash-es/_getRawTag.js

/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _getRawTag_hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = _getRawTag_hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

/* harmony default export */ var _getRawTag = (getRawTag);
// CONCATENATED MODULE: ./node_modules/lodash-es/_objectToString.js
/** Used for built-in method references. */
var _objectToString_objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var _objectToString_nativeObjectToString = _objectToString_objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return _objectToString_nativeObjectToString.call(value);
}

/* harmony default export */ var _objectToString = (objectToString);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseGetTag.js



/** `Object#toString` result references. */

var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var _baseGetTag_symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return _baseGetTag_symToStringTag && _baseGetTag_symToStringTag in Object(value) ? _getRawTag(value) : _objectToString(value);
}

/* harmony default export */ var _baseGetTag = (baseGetTag);
// CONCATENATED MODULE: ./node_modules/lodash-es/isObject.js
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/* harmony default export */ var lodash_es_isObject = (isObject);
// CONCATENATED MODULE: ./node_modules/lodash-es/isFunction.js


/** `Object#toString` result references. */

var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!lodash_es_isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = _baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/* harmony default export */ var lodash_es_isFunction = (isFunction);
// CONCATENATED MODULE: ./node_modules/lodash-es/_coreJsData.js

/** Used to detect overreaching core-js shims. */

var coreJsData = _root["a" /* default */]['__core-js_shared__'];
/* harmony default export */ var _coreJsData = (coreJsData);
// CONCATENATED MODULE: ./node_modules/lodash-es/_isMasked.js

/** Used to detect methods masquerading as native. */

var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/* harmony default export */ var _isMasked = (isMasked);
// CONCATENATED MODULE: ./node_modules/lodash-es/_toSource.js
/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

/* harmony default export */ var _toSource = (toSource);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsNative.js




/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var _baseIsNative_funcProto = Function.prototype,
    _baseIsNative_objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var _baseIsNative_funcToString = _baseIsNative_funcProto.toString;
/** Used to check objects for own properties. */

var _baseIsNative_hasOwnProperty = _baseIsNative_objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + _baseIsNative_funcToString.call(_baseIsNative_hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!lodash_es_isObject(value) || _isMasked(value)) {
    return false;
  }

  var pattern = lodash_es_isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(_toSource(value));
}

/* harmony default export */ var _baseIsNative = (baseIsNative);
// CONCATENATED MODULE: ./node_modules/lodash-es/_getValue.js
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/* harmony default export */ var _getValue = (getValue);
// CONCATENATED MODULE: ./node_modules/lodash-es/_getNative.js


/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */

function getNative(object, key) {
  var value = _getValue(object, key);
  return _baseIsNative(value) ? value : undefined;
}

/* harmony default export */ var _getNative = (getNative);
// CONCATENATED MODULE: ./node_modules/lodash-es/_Map.js


/* Built-in method references that are verified to be native. */

var Map = _getNative(_root["a" /* default */], 'Map');
/* harmony default export */ var _Map = (Map);
// CONCATENATED MODULE: ./node_modules/lodash-es/_nativeCreate.js

/* Built-in method references that are verified to be native. */

var nativeCreate = _getNative(Object, 'create');
/* harmony default export */ var _nativeCreate = (nativeCreate);
// CONCATENATED MODULE: ./node_modules/lodash-es/_hashClear.js

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */

function hashClear() {
  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
  this.size = 0;
}

/* harmony default export */ var _hashClear = (hashClear);
// CONCATENATED MODULE: ./node_modules/lodash-es/_hashDelete.js
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/* harmony default export */ var _hashDelete = (hashDelete);
// CONCATENATED MODULE: ./node_modules/lodash-es/_hashGet.js

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var _hashGet_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _hashGet_hasOwnProperty = _hashGet_objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (_nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return _hashGet_hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/* harmony default export */ var _hashGet = (hashGet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_hashHas.js

/** Used for built-in method references. */

var _hashHas_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _hashHas_hasOwnProperty = _hashHas_objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate ? data[key] !== undefined : _hashHas_hasOwnProperty.call(data, key);
}

/* harmony default export */ var _hashHas = (hashHas);
// CONCATENATED MODULE: ./node_modules/lodash-es/_hashSet.js

/** Used to stand-in for `undefined` hash values. */

var _hashSet_HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = _nativeCreate && value === undefined ? _hashSet_HASH_UNDEFINED : value;
  return this;
}

/* harmony default export */ var _hashSet = (hashSet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_Hash.js





/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = _hashClear;
Hash.prototype['delete'] = _hashDelete;
Hash.prototype.get = _hashGet;
Hash.prototype.has = _hashHas;
Hash.prototype.set = _hashSet;
/* harmony default export */ var _Hash = (Hash);
// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheClear.js



/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */

function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new _Hash(),
    'map': new (_Map || _ListCache)(),
    'string': new _Hash()
  };
}

/* harmony default export */ var _mapCacheClear = (mapCacheClear);
// CONCATENATED MODULE: ./node_modules/lodash-es/_isKeyable.js
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/* harmony default export */ var _isKeyable = (isKeyable);
// CONCATENATED MODULE: ./node_modules/lodash-es/_getMapData.js

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */

function getMapData(map, key) {
  var data = map.__data__;
  return _isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/* harmony default export */ var _getMapData = (getMapData);
// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheDelete.js

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function mapCacheDelete(key) {
  var result = _getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/* harmony default export */ var _mapCacheDelete = (mapCacheDelete);
// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheGet.js

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function mapCacheGet(key) {
  return _getMapData(this, key).get(key);
}

/* harmony default export */ var _mapCacheGet = (mapCacheGet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheHas.js

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function mapCacheHas(key) {
  return _getMapData(this, key).has(key);
}

/* harmony default export */ var _mapCacheHas = (mapCacheHas);
// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheSet.js

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */

function mapCacheSet(key, value) {
  var data = _getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/* harmony default export */ var _mapCacheSet = (mapCacheSet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_MapCache.js





/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = _mapCacheClear;
MapCache.prototype['delete'] = _mapCacheDelete;
MapCache.prototype.get = _mapCacheGet;
MapCache.prototype.has = _mapCacheHas;
MapCache.prototype.set = _mapCacheSet;
/* harmony default export */ var _MapCache = (MapCache);
// CONCATENATED MODULE: ./node_modules/lodash-es/_stackSet.js



/** Used as the size to enable large array optimizations. */

var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof _ListCache) {
    var pairs = data.__data__;

    if (!_Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new _MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

/* harmony default export */ var _stackSet = (stackSet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_Stack.js






/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Stack(entries) {
  var data = this.__data__ = new _ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = _stackClear;
Stack.prototype['delete'] = _stackDelete;
Stack.prototype.get = _stackGet;
Stack.prototype.has = _stackHas;
Stack.prototype.set = _stackSet;
/* harmony default export */ var _Stack = (Stack);
// CONCATENATED MODULE: ./node_modules/lodash-es/_setCacheAdd.js
/** Used to stand-in for `undefined` hash values. */
var _setCacheAdd_HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, _setCacheAdd_HASH_UNDEFINED);

  return this;
}

/* harmony default export */ var _setCacheAdd = (setCacheAdd);
// CONCATENATED MODULE: ./node_modules/lodash-es/_setCacheHas.js
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/* harmony default export */ var _setCacheHas = (setCacheHas);
// CONCATENATED MODULE: ./node_modules/lodash-es/_SetCache.js



/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */

function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new _MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
SetCache.prototype.has = _setCacheHas;
/* harmony default export */ var _SetCache = (SetCache);
// CONCATENATED MODULE: ./node_modules/lodash-es/_arraySome.js
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

/* harmony default export */ var _arraySome = (arraySome);
// CONCATENATED MODULE: ./node_modules/lodash-es/_cacheHas.js
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/* harmony default export */ var _cacheHas = (cacheHas);
// CONCATENATED MODULE: ./node_modules/lodash-es/_equalArrays.js



/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Check that cyclic values are equal.


  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);

  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new _SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!_arraySome(other, function (othValue, othIndex) {
        if (!_cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/* harmony default export */ var _equalArrays = (equalArrays);
// CONCATENATED MODULE: ./node_modules/lodash-es/_Uint8Array.js

/** Built-in value references. */

var Uint8Array = _root["a" /* default */].Uint8Array;
/* harmony default export */ var _Uint8Array = (Uint8Array);
// CONCATENATED MODULE: ./node_modules/lodash-es/_mapToArray.js
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/* harmony default export */ var _mapToArray = (mapToArray);
// CONCATENATED MODULE: ./node_modules/lodash-es/_setToArray.js
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/* harmony default export */ var _setToArray = (setToArray);
// CONCATENATED MODULE: ./node_modules/lodash-es/_equalByTag.js






/** Used to compose bitmasks for value comparisons. */

var _equalByTag_COMPARE_PARTIAL_FLAG = 1,
    _equalByTag_COMPARE_UNORDERED_FLAG = 2;
/** `Object#toString` result references. */

var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return lodash_es_eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = _mapToArray;

    case setTag:
      var isPartial = bitmask & _equalByTag_COMPARE_PARTIAL_FLAG;
      convert || (convert = _setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= _equalByTag_COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

/* harmony default export */ var _equalByTag = (equalByTag);
// CONCATENATED MODULE: ./node_modules/lodash-es/_arrayPush.js
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

/* harmony default export */ var _arrayPush = (arrayPush);
// CONCATENATED MODULE: ./node_modules/lodash-es/isArray.js
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
/* harmony default export */ var lodash_es_isArray = (isArray);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseGetAllKeys.js


/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */

function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return lodash_es_isArray(object) ? result : _arrayPush(result, symbolsFunc(object));
}

/* harmony default export */ var _baseGetAllKeys = (baseGetAllKeys);
// CONCATENATED MODULE: ./node_modules/lodash-es/_arrayFilter.js
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

/* harmony default export */ var _arrayFilter = (arrayFilter);
// CONCATENATED MODULE: ./node_modules/lodash-es/stubArray.js
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/* harmony default export */ var lodash_es_stubArray = (stubArray);
// CONCATENATED MODULE: ./node_modules/lodash-es/_getSymbols.js


/** Used for built-in method references. */

var _getSymbols_objectProto = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable = _getSymbols_objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? lodash_es_stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return _arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
/* harmony default export */ var _getSymbols = (getSymbols);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseTimes.js
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

/* harmony default export */ var _baseTimes = (baseTimes);
// CONCATENATED MODULE: ./node_modules/lodash-es/isObjectLike.js
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/* harmony default export */ var lodash_es_isObjectLike = (isObjectLike);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsArguments.js


/** `Object#toString` result references. */

var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return lodash_es_isObjectLike(value) && _baseGetTag(value) == argsTag;
}

/* harmony default export */ var _baseIsArguments = (baseIsArguments);
// CONCATENATED MODULE: ./node_modules/lodash-es/isArguments.js


/** Used for built-in method references. */

var isArguments_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var isArguments_hasOwnProperty = isArguments_objectProto.hasOwnProperty;
/** Built-in value references. */

var isArguments_propertyIsEnumerable = isArguments_objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = _baseIsArguments(function () {
  return arguments;
}()) ? _baseIsArguments : function (value) {
  return lodash_es_isObjectLike(value) && isArguments_hasOwnProperty.call(value, 'callee') && !isArguments_propertyIsEnumerable.call(value, 'callee');
};
/* harmony default export */ var lodash_es_isArguments = (isArguments);
// EXTERNAL MODULE: ./node_modules/lodash-es/isBuffer.js
var isBuffer = __webpack_require__(27);

// CONCATENATED MODULE: ./node_modules/lodash-es/_isIndex.js
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/* harmony default export */ var _isIndex = (isIndex);
// CONCATENATED MODULE: ./node_modules/lodash-es/isLength.js
/** Used as references for various `Number` constants. */
var isLength_MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= isLength_MAX_SAFE_INTEGER;
}

/* harmony default export */ var lodash_es_isLength = (isLength);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsTypedArray.js



/** `Object#toString` result references. */

var _baseIsTypedArray_argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    _baseIsTypedArray_boolTag = '[object Boolean]',
    _baseIsTypedArray_dateTag = '[object Date]',
    _baseIsTypedArray_errorTag = '[object Error]',
    _baseIsTypedArray_funcTag = '[object Function]',
    _baseIsTypedArray_mapTag = '[object Map]',
    _baseIsTypedArray_numberTag = '[object Number]',
    objectTag = '[object Object]',
    _baseIsTypedArray_regexpTag = '[object RegExp]',
    _baseIsTypedArray_setTag = '[object Set]',
    _baseIsTypedArray_stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var _baseIsTypedArray_arrayBufferTag = '[object ArrayBuffer]',
    _baseIsTypedArray_dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[_baseIsTypedArray_argsTag] = typedArrayTags[arrayTag] = typedArrayTags[_baseIsTypedArray_arrayBufferTag] = typedArrayTags[_baseIsTypedArray_boolTag] = typedArrayTags[_baseIsTypedArray_dataViewTag] = typedArrayTags[_baseIsTypedArray_dateTag] = typedArrayTags[_baseIsTypedArray_errorTag] = typedArrayTags[_baseIsTypedArray_funcTag] = typedArrayTags[_baseIsTypedArray_mapTag] = typedArrayTags[_baseIsTypedArray_numberTag] = typedArrayTags[objectTag] = typedArrayTags[_baseIsTypedArray_regexpTag] = typedArrayTags[_baseIsTypedArray_setTag] = typedArrayTags[_baseIsTypedArray_stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return lodash_es_isObjectLike(value) && lodash_es_isLength(value.length) && !!typedArrayTags[_baseGetTag(value)];
}

/* harmony default export */ var _baseIsTypedArray = (baseIsTypedArray);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseUnary.js
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

/* harmony default export */ var _baseUnary = (baseUnary);
// EXTERNAL MODULE: ./node_modules/lodash-es/_nodeUtil.js
var _nodeUtil = __webpack_require__(74);

// CONCATENATED MODULE: ./node_modules/lodash-es/isTypedArray.js



/* Node.js helper references. */

var nodeIsTypedArray = _nodeUtil["a" /* default */] && _nodeUtil["a" /* default */].isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;
/* harmony default export */ var lodash_es_isTypedArray = (isTypedArray);
// CONCATENATED MODULE: ./node_modules/lodash-es/_arrayLikeKeys.js






/** Used for built-in method references. */

var _arrayLikeKeys_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _arrayLikeKeys_hasOwnProperty = _arrayLikeKeys_objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = lodash_es_isArray(value),
      isArg = !isArr && lodash_es_isArguments(value),
      isBuff = !isArr && !isArg && Object(isBuffer["a" /* default */])(value),
      isType = !isArr && !isArg && !isBuff && lodash_es_isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? _baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || _arrayLikeKeys_hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    _isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

/* harmony default export */ var _arrayLikeKeys = (arrayLikeKeys);
// CONCATENATED MODULE: ./node_modules/lodash-es/_isPrototype.js
/** Used for built-in method references. */
var _isPrototype_objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || _isPrototype_objectProto;
  return value === proto;
}

/* harmony default export */ var _isPrototype = (isPrototype);
// CONCATENATED MODULE: ./node_modules/lodash-es/_overArg.js
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

/* harmony default export */ var _overArg = (overArg);
// CONCATENATED MODULE: ./node_modules/lodash-es/_nativeKeys.js

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeKeys = _overArg(Object.keys, Object);
/* harmony default export */ var _nativeKeys = (nativeKeys);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseKeys.js


/** Used for built-in method references. */

var _baseKeys_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _baseKeys_hasOwnProperty = _baseKeys_objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!_isPrototype(object)) {
    return _nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (_baseKeys_hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

/* harmony default export */ var _baseKeys = (baseKeys);
// CONCATENATED MODULE: ./node_modules/lodash-es/isArrayLike.js


/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */

function isArrayLike(value) {
  return value != null && lodash_es_isLength(value.length) && !lodash_es_isFunction(value);
}

/* harmony default export */ var lodash_es_isArrayLike = (isArrayLike);
// CONCATENATED MODULE: ./node_modules/lodash-es/keys.js



/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */

function keys(object) {
  return lodash_es_isArrayLike(object) ? _arrayLikeKeys(object) : _baseKeys(object);
}

/* harmony default export */ var lodash_es_keys = (keys);
// CONCATENATED MODULE: ./node_modules/lodash-es/_getAllKeys.js



/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */

function getAllKeys(object) {
  return _baseGetAllKeys(object, lodash_es_keys, _getSymbols);
}

/* harmony default export */ var _getAllKeys = (getAllKeys);
// CONCATENATED MODULE: ./node_modules/lodash-es/_equalObjects.js

/** Used to compose bitmasks for value comparisons. */

var _equalObjects_COMPARE_PARTIAL_FLAG = 1;
/** Used for built-in method references. */

var _equalObjects_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _equalObjects_hasOwnProperty = _equalObjects_objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & _equalObjects_COMPARE_PARTIAL_FLAG,
      objProps = _getAllKeys(object),
      objLength = objProps.length,
      othProps = _getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : _equalObjects_hasOwnProperty.call(other, key))) {
      return false;
    }
  } // Check that cyclic values are equal.


  var objStacked = stack.get(object);
  var othStacked = stack.get(other);

  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/* harmony default export */ var _equalObjects = (equalObjects);
// CONCATENATED MODULE: ./node_modules/lodash-es/_DataView.js


/* Built-in method references that are verified to be native. */

var DataView = _getNative(_root["a" /* default */], 'DataView');
/* harmony default export */ var _DataView = (DataView);
// CONCATENATED MODULE: ./node_modules/lodash-es/_Promise.js


/* Built-in method references that are verified to be native. */

var _Promise_Promise = _getNative(_root["a" /* default */], 'Promise');
/* harmony default export */ var _Promise = (_Promise_Promise);
// CONCATENATED MODULE: ./node_modules/lodash-es/_Set.js


/* Built-in method references that are verified to be native. */

var Set = _getNative(_root["a" /* default */], 'Set');
/* harmony default export */ var _Set = (Set);
// CONCATENATED MODULE: ./node_modules/lodash-es/_WeakMap.js


/* Built-in method references that are verified to be native. */

var WeakMap = _getNative(_root["a" /* default */], 'WeakMap');
/* harmony default export */ var _WeakMap = (WeakMap);
// CONCATENATED MODULE: ./node_modules/lodash-es/_getTag.js







/** `Object#toString` result references. */

var _getTag_mapTag = '[object Map]',
    _getTag_objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    _getTag_setTag = '[object Set]',
    _getTag_weakMapTag = '[object WeakMap]';
var _getTag_dataViewTag = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = _toSource(_DataView),
    mapCtorString = _toSource(_Map),
    promiseCtorString = _toSource(_Promise),
    setCtorString = _toSource(_Set),
    weakMapCtorString = _toSource(_WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = _baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (_DataView && getTag(new _DataView(new ArrayBuffer(1))) != _getTag_dataViewTag || _Map && getTag(new _Map()) != _getTag_mapTag || _Promise && getTag(_Promise.resolve()) != promiseTag || _Set && getTag(new _Set()) != _getTag_setTag || _WeakMap && getTag(new _WeakMap()) != _getTag_weakMapTag) {
  getTag = function (value) {
    var result = _baseGetTag(value),
        Ctor = result == _getTag_objectTag ? value.constructor : undefined,
        ctorString = Ctor ? _toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return _getTag_dataViewTag;

        case mapCtorString:
          return _getTag_mapTag;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return _getTag_setTag;

        case weakMapCtorString:
          return _getTag_weakMapTag;
      }
    }

    return result;
  };
}

/* harmony default export */ var _getTag = (getTag);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsEqualDeep.js








/** Used to compose bitmasks for value comparisons. */

var _baseIsEqualDeep_COMPARE_PARTIAL_FLAG = 1;
/** `Object#toString` result references. */

var _baseIsEqualDeep_argsTag = '[object Arguments]',
    _baseIsEqualDeep_arrayTag = '[object Array]',
    _baseIsEqualDeep_objectTag = '[object Object]';
/** Used for built-in method references. */

var _baseIsEqualDeep_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _baseIsEqualDeep_hasOwnProperty = _baseIsEqualDeep_objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = lodash_es_isArray(object),
      othIsArr = lodash_es_isArray(other),
      objTag = objIsArr ? _baseIsEqualDeep_arrayTag : _getTag(object),
      othTag = othIsArr ? _baseIsEqualDeep_arrayTag : _getTag(other);
  objTag = objTag == _baseIsEqualDeep_argsTag ? _baseIsEqualDeep_objectTag : objTag;
  othTag = othTag == _baseIsEqualDeep_argsTag ? _baseIsEqualDeep_objectTag : othTag;
  var objIsObj = objTag == _baseIsEqualDeep_objectTag,
      othIsObj = othTag == _baseIsEqualDeep_objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && Object(isBuffer["a" /* default */])(object)) {
    if (!Object(isBuffer["a" /* default */])(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new _Stack());
    return objIsArr || lodash_es_isTypedArray(object) ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack) : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & _baseIsEqualDeep_COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && _baseIsEqualDeep_hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && _baseIsEqualDeep_hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new _Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new _Stack());
  return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/* harmony default export */ var _baseIsEqualDeep = (baseIsEqualDeep);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsEqual.js


/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */

function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !lodash_es_isObjectLike(value) && !lodash_es_isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/* harmony default export */ var _baseIsEqual = (baseIsEqual);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsMatch.js


/** Used to compose bitmasks for value comparisons. */

var _baseIsMatch_COMPARE_PARTIAL_FLAG = 1,
    _baseIsMatch_COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new _Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? _baseIsEqual(srcValue, objValue, _baseIsMatch_COMPARE_PARTIAL_FLAG | _baseIsMatch_COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

/* harmony default export */ var _baseIsMatch = (baseIsMatch);
// CONCATENATED MODULE: ./node_modules/lodash-es/_isStrictComparable.js

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */

function isStrictComparable(value) {
  return value === value && !lodash_es_isObject(value);
}

/* harmony default export */ var _isStrictComparable = (isStrictComparable);
// CONCATENATED MODULE: ./node_modules/lodash-es/_getMatchData.js


/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */

function getMatchData(object) {
  var result = lodash_es_keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, _isStrictComparable(value)];
  }

  return result;
}

/* harmony default export */ var _getMatchData = (getMatchData);
// CONCATENATED MODULE: ./node_modules/lodash-es/_matchesStrictComparable.js
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

/* harmony default export */ var _matchesStrictComparable = (matchesStrictComparable);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseMatches.js



/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatches(source) {
  var matchData = _getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || _baseIsMatch(object, source, matchData);
  };
}

/* harmony default export */ var _baseMatches = (baseMatches);
// CONCATENATED MODULE: ./node_modules/lodash-es/isSymbol.js


/** `Object#toString` result references. */

var isSymbol_symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return typeof value == 'symbol' || lodash_es_isObjectLike(value) && _baseGetTag(value) == isSymbol_symbolTag;
}

/* harmony default export */ var lodash_es_isSymbol = (isSymbol);
// CONCATENATED MODULE: ./node_modules/lodash-es/_isKey.js


/** Used to match property names within property paths. */

var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (lodash_es_isArray(value)) {
    return false;
  }

  var type = typeof value;

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || lodash_es_isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

/* harmony default export */ var _isKey = (isKey);
// CONCATENATED MODULE: ./node_modules/lodash-es/memoize.js

/** Error message constants. */

var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || _MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = _MapCache;
/* harmony default export */ var lodash_es_memoize = (memoize);
// CONCATENATED MODULE: ./node_modules/lodash-es/_memoizeCapped.js

/** Used as the maximum memoize cache size. */

var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = lodash_es_memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

/* harmony default export */ var _memoizeCapped = (memoizeCapped);
// CONCATENATED MODULE: ./node_modules/lodash-es/_stringToPath.js

/** Used to match property names within property paths. */

var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = _memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
    result.push('');
  }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
/* harmony default export */ var _stringToPath = (stringToPath);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseToString.js




/** Used as references for various `Number` constants. */

var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var _baseToString_symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = _baseToString_symbolProto ? _baseToString_symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (lodash_es_isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return _arrayMap(value, baseToString) + '';
  }

  if (lodash_es_isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/* harmony default export */ var _baseToString = (baseToString);
// CONCATENATED MODULE: ./node_modules/lodash-es/toString.js

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */

function toString_toString(value) {
  return value == null ? '' : _baseToString(value);
}

/* harmony default export */ var lodash_es_toString = (toString_toString);
// CONCATENATED MODULE: ./node_modules/lodash-es/_castPath.js




/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */

function castPath(value, object) {
  if (lodash_es_isArray(value)) {
    return value;
  }

  return _isKey(value, object) ? [value] : _stringToPath(lodash_es_toString(value));
}

/* harmony default export */ var _castPath = (castPath);
// CONCATENATED MODULE: ./node_modules/lodash-es/_toKey.js

/** Used as references for various `Number` constants. */

var _toKey_INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || lodash_es_isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -_toKey_INFINITY ? '-0' : result;
}

/* harmony default export */ var _toKey = (toKey);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseGet.js


/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */

function baseGet(object, path) {
  path = _castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[_toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

/* harmony default export */ var _baseGet = (baseGet);
// CONCATENATED MODULE: ./node_modules/lodash-es/get.js

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */

function get(object, path, defaultValue) {
  var result = object == null ? undefined : _baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/* harmony default export */ var lodash_es_get = (get);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseHasIn.js
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/* harmony default export */ var _baseHasIn = (baseHasIn);
// CONCATENATED MODULE: ./node_modules/lodash-es/_hasPath.js






/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */

function hasPath(object, path, hasFunc) {
  path = _castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = _toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && lodash_es_isLength(length) && _isIndex(key, length) && (lodash_es_isArray(object) || lodash_es_isArguments(object));
}

/* harmony default export */ var _hasPath = (hasPath);
// CONCATENATED MODULE: ./node_modules/lodash-es/hasIn.js


/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */

function hasIn(object, path) {
  return object != null && _hasPath(object, path, _baseHasIn);
}

/* harmony default export */ var lodash_es_hasIn = (hasIn);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseMatchesProperty.js







/** Used to compose bitmasks for value comparisons. */

var _baseMatchesProperty_COMPARE_PARTIAL_FLAG = 1,
    _baseMatchesProperty_COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty(path, srcValue) {
  if (_isKey(path) && _isStrictComparable(srcValue)) {
    return _matchesStrictComparable(_toKey(path), srcValue);
  }

  return function (object) {
    var objValue = lodash_es_get(object, path);
    return objValue === undefined && objValue === srcValue ? lodash_es_hasIn(object, path) : _baseIsEqual(srcValue, objValue, _baseMatchesProperty_COMPARE_PARTIAL_FLAG | _baseMatchesProperty_COMPARE_UNORDERED_FLAG);
  };
}

/* harmony default export */ var _baseMatchesProperty = (baseMatchesProperty);
// CONCATENATED MODULE: ./node_modules/lodash-es/identity.js
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/* harmony default export */ var lodash_es_identity = (identity);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseProperty.js
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

/* harmony default export */ var _baseProperty = (baseProperty);
// CONCATENATED MODULE: ./node_modules/lodash-es/_basePropertyDeep.js

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */

function basePropertyDeep(path) {
  return function (object) {
    return _baseGet(object, path);
  };
}

/* harmony default export */ var _basePropertyDeep = (basePropertyDeep);
// CONCATENATED MODULE: ./node_modules/lodash-es/property.js




/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */

function property(path) {
  return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
}

/* harmony default export */ var lodash_es_property = (property);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIteratee.js





/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */

function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return lodash_es_identity;
  }

  if (typeof value == 'object') {
    return lodash_es_isArray(value) ? _baseMatchesProperty(value[0], value[1]) : _baseMatches(value);
  }

  return lodash_es_property(value);
}

/* harmony default export */ var _baseIteratee = (baseIteratee);
// CONCATENATED MODULE: ./node_modules/lodash-es/_defineProperty.js


var defineProperty = function () {
  try {
    var func = _getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

/* harmony default export */ var _defineProperty = (defineProperty);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseAssignValue.js

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function baseAssignValue(object, key, value) {
  if (key == '__proto__' && _defineProperty) {
    _defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/* harmony default export */ var _baseAssignValue = (baseAssignValue);
// CONCATENATED MODULE: ./node_modules/lodash-es/_assignValue.js


/** Used for built-in method references. */

var _assignValue_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _assignValue_hasOwnProperty = _assignValue_objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(_assignValue_hasOwnProperty.call(object, key) && lodash_es_eq(objValue, value)) || value === undefined && !(key in object)) {
    _baseAssignValue(object, key, value);
  }
}

/* harmony default export */ var _assignValue = (assignValue);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseSet.js





/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */

function baseSet(object, path, value, customizer) {
  if (!lodash_es_isObject(object)) {
    return object;
  }

  path = _castPath(path, object);
  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = _toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;

      if (newValue === undefined) {
        newValue = lodash_es_isObject(objValue) ? objValue : _isIndex(path[index + 1]) ? [] : {};
      }
    }

    _assignValue(nested, key, newValue);
    nested = nested[key];
  }

  return object;
}

/* harmony default export */ var _baseSet = (baseSet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_basePickBy.js



/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */

function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = _baseGet(object, path);

    if (predicate(value, path)) {
      _baseSet(result, _castPath(path, object), value);
    }
  }

  return result;
}

/* harmony default export */ var _basePickBy = (basePickBy);
// CONCATENATED MODULE: ./node_modules/lodash-es/_getPrototype.js

/** Built-in value references. */

var getPrototype = _overArg(Object.getPrototypeOf, Object);
/* harmony default export */ var _getPrototype = (getPrototype);
// CONCATENATED MODULE: ./node_modules/lodash-es/_getSymbolsIn.js




/* Built-in method references for those with the same name as other `lodash` methods. */

var _getSymbolsIn_nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbolsIn = !_getSymbolsIn_nativeGetSymbols ? lodash_es_stubArray : function (object) {
  var result = [];

  while (object) {
    _arrayPush(result, _getSymbols(object));
    object = _getPrototype(object);
  }

  return result;
};
/* harmony default export */ var _getSymbolsIn = (getSymbolsIn);
// CONCATENATED MODULE: ./node_modules/lodash-es/_nativeKeysIn.js
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

/* harmony default export */ var _nativeKeysIn = (nativeKeysIn);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseKeysIn.js



/** Used for built-in method references. */

var _baseKeysIn_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _baseKeysIn_hasOwnProperty = _baseKeysIn_objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!lodash_es_isObject(object)) {
    return _nativeKeysIn(object);
  }

  var isProto = _isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !_baseKeysIn_hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

/* harmony default export */ var _baseKeysIn = (baseKeysIn);
// CONCATENATED MODULE: ./node_modules/lodash-es/keysIn.js



/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */

function keysIn(object) {
  return lodash_es_isArrayLike(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
}

/* harmony default export */ var lodash_es_keysIn = (keysIn);
// CONCATENATED MODULE: ./node_modules/lodash-es/_getAllKeysIn.js



/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */

function getAllKeysIn(object) {
  return _baseGetAllKeys(object, lodash_es_keysIn, _getSymbolsIn);
}

/* harmony default export */ var _getAllKeysIn = (getAllKeysIn);
// CONCATENATED MODULE: ./node_modules/lodash-es/pickBy.js




/**
 * Creates an object composed of the `object` properties `predicate` returns
 * truthy for. The predicate is invoked with two arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} [predicate=_.identity] The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pickBy(object, _.isNumber);
 * // => { 'a': 1, 'c': 3 }
 */

function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }

  var props = _arrayMap(_getAllKeysIn(object), function (prop) {
    return [prop];
  });
  predicate = _baseIteratee(predicate);
  return _basePickBy(object, props, function (value, path) {
    return predicate(value, path[0]);
  });
}

/* harmony default export */ var lodash_es_pickBy = (pickBy);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseClamp.js
/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }

    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }

  return number;
}

/* harmony default export */ var _baseClamp = (baseClamp);
// CONCATENATED MODULE: ./node_modules/lodash-es/_trimmedEndIndex.js
/** Used to match a single whitespace character. */
var reWhitespace = /\s/;
/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */

function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}

  return index;
}

/* harmony default export */ var _trimmedEndIndex = (trimmedEndIndex);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseTrim.js

/** Used to match leading whitespace. */

var reTrimStart = /^\s+/;
/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */

function baseTrim(string) {
  return string ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
}

/* harmony default export */ var _baseTrim = (baseTrim);
// CONCATENATED MODULE: ./node_modules/lodash-es/toNumber.js



/** Used as references for various `Number` constants. */

var NAN = 0 / 0;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */

function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (lodash_es_isSymbol(value)) {
    return NAN;
  }

  if (lodash_es_isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = lodash_es_isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = _baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

/* harmony default export */ var lodash_es_toNumber = (toNumber);
// CONCATENATED MODULE: ./node_modules/lodash-es/toFinite.js

/** Used as references for various `Number` constants. */

var toFinite_INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;
/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */

function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }

  value = lodash_es_toNumber(value);

  if (value === toFinite_INFINITY || value === -toFinite_INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }

  return value === value ? value : 0;
}

/* harmony default export */ var lodash_es_toFinite = (toFinite);
// CONCATENATED MODULE: ./node_modules/lodash-es/toInteger.js

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */

function toInteger(value) {
  var result = lodash_es_toFinite(value),
      remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}

/* harmony default export */ var lodash_es_toInteger = (toInteger);
// CONCATENATED MODULE: ./node_modules/lodash-es/startsWith.js




/**
 * Checks if `string` starts with the given target string.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {string} [target] The string to search for.
 * @param {number} [position=0] The position to search from.
 * @returns {boolean} Returns `true` if `string` starts with `target`,
 *  else `false`.
 * @example
 *
 * _.startsWith('abc', 'a');
 * // => true
 *
 * _.startsWith('abc', 'b');
 * // => false
 *
 * _.startsWith('abc', 'b', 1);
 * // => true
 */

function startsWith(string, target, position) {
  string = lodash_es_toString(string);
  position = position == null ? 0 : _baseClamp(lodash_es_toInteger(position), 0, string.length);
  target = _baseToString(target);
  return string.slice(position, position + target.length) == target;
}

/* harmony default export */ var lodash_es_startsWith = (startsWith);
// CONCATENATED MODULE: ./node_modules/@chakra-ui/vue/src/utils/object.js



/**
 * Clears out all undefined properties from an object.
 * @param {Object} props
 * @returns {Object} Sanitized object with defined values.
 */

function pickProperty(props) {
  const pure = {};

  for (const prop in props) {
    if (props[prop] !== undefined) {
      pure[prop] = props[prop];
    }
  }

  return pure;
}
/**
 * Extracts pseudo style props from props objects
 * @param {Object} props
 * @returns {Object} Pseudo styles object
 */

function filterPseudo(props) {
  const pseudos = lodash_es_pickBy(props, (_value, key) => {
    return lodash_es_startsWith(key, '_');
  });
  return pseudos;
}
/**
 * Extracts style props from merged spseudo styes object
 * @param {Object} props
 * @returns {Object} Base styles object
 */

function filterBaseStyles(props) {
  const pseudos = lodash_es_pickBy(props, (_value, key) => {
    return !lodash_es_startsWith(key, '_');
  });
  return pseudos;
}
/** Filter attrs and return object of chakra props */

function extractChakraAttrs(attrs) {
  const styleAttrs = {};
  const nativeAttrs = {};

  for (const _prop in attrs) {
    const prop = camelize(_prop);

    if (Object(chakra_ui_styled_system_cjs["isStyleProp"])(prop)) {
      styleAttrs[prop] = attrs[_prop];
    } else {
      nativeAttrs[_prop] = attrs[_prop];
    }
  }

  return {
    styleAttrs,
    nativeAttrs
  };
}
/**
 * Check if a given value is a non-null object.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is a non-null object, else `false`.
 */

function isNonNullObject(value) {
  return typeof value === 'object' && value !== null;
}
/**
 * Checks if object has a specific property.
 * @param {Object} obj
 * @param {String} prop
 */

const hasOwn = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
/**
 * Checks to see if objects in empty
 * @param {Object} object
 */

function isEmpty(object) {
  for (const key in object) {
    // Should iterate only once
    if (hasOwn(object, key)) {
      return false;
    }

    return true;
  }
}
/**
 * Splits user styles into base and pseudo styles
 * @param {Object} props styles objects
 * @returns {{ baseStyles: Object, pseudoStyles: Object }}
 */

function splitProps(props) {
  const baseStyles = {};
  const pseudoStyles = {};
  const styles = {
    baseStyles,
    pseudoStyles
  };

  if (!props || isEmpty(props)) {
    return styles;
  }

  for (const key in props) {
    if (key.startsWith('_')) {
      styles.pseudoStyles[key] = props[key];
    } else {
      styles.baseStyles[key] = props[key];
    }
  }

  return styles;
}
// CONCATENATED MODULE: ./node_modules/@chakra-ui/vue/src/directives/chakra.directive.js



/** Purify Chakra attributes */

const purifyAttrs = (el, props) => {
  for (const attr in props) {
    el.removeAttribute(attr);
    el.removeAttribute(kebabify(attr));
  }
};
/** Purify's Chakra Attributes from VNode object */


const purifyVNodeAttrs = (vnode, props) => {
  if (props && vnode.data.attrs) {
    for (const attr in props) {
      delete vnode.data.attrs[kebabify(attr)];
    }
  }
};
/** Creates SSR `v-chakra` directive for Nuxt */


function createServerDirective(theme) {
  /** Applies server-side className */
  const applyServerClassName = (vnode, className, styleAttrs) => {
    if (vnode.data.class) {
      vnode.data.class += ` ${className}`;
    } else {
      vnode.data.class = className;
    }
    /**
     * Only remove style attributes
     * from VNode if directive has no
     * arguments
     **/


    if (styleAttrs) {
      purifyVNodeAttrs(vnode, styleAttrs);
    }
  };

  return (vnode, directive) => {
    const {
      styleAttrs
    } = extractChakraAttrs(vnode.data.attrs);
    const className = /*#__PURE__*/Object(css_["css"])(src_Css(styleAttrs)(theme),  true ? "" : undefined);
    applyServerClassName(vnode, className, styleAttrs);

    if (directive.value) {
      if (typeof directive.value === 'object') {
        const className = /*#__PURE__*/Object(css_["css"])(src_Css(directive.value)(theme),  true ? "" : undefined);
        applyServerClassName(vnode, className);
      }

      if (typeof directive.value === 'function') {
        const styles = directive.value(theme);
        const className = /*#__PURE__*/Object(css_["css"])(src_Css(styles)(theme),  true ? "" : undefined);
        applyServerClassName(vnode, className);
      }
    }
  };
}
;
/** Creates Client `v-chakra` Directive */

function createClientDirective(theme) {
  function applyClientStyles(el, binding, vnode) {
    const {
      styleAttrs
    } = extractChakraAttrs(vnode.data.attrs);
    const className = /*#__PURE__*/Object(css_["css"])(src_Css(styleAttrs)(theme),  true ? "" : undefined);
    el.classList.add(className);
    purifyAttrs(el, styleAttrs);

    if (binding.value) {
      if (typeof binding.value === 'object') {
        const className = /*#__PURE__*/Object(css_["css"])(src_Css(binding.value)(theme),  true ? "" : undefined);
        el.classList.add(className);
      }

      if (typeof binding.value === 'function') {
        const styles = binding.value(theme);
        const className = /*#__PURE__*/Object(css_["css"])(src_Css(styles)(theme),  true ? "" : undefined);
        el.classList.add(className);
      }
    }
  }

  return {
    bind: applyClientStyles,
    update: applyClientStyles,
    componentUpdated: applyClientStyles,
    unbind: applyClientStyles
  };
}
// EXTERNAL MODULE: ./node_modules/@chakra-ui/utils/dist/chakra-ui-utils.cjs.js
var chakra_ui_utils_cjs = __webpack_require__(71);

// EXTERNAL MODULE: ./node_modules/@chakra-ui/theme-vue/dist/index.js
var dist = __webpack_require__(93);
var dist_default = /*#__PURE__*/__webpack_require__.n(dist);

// CONCATENATED MODULE: ./node_modules/.cache/nuxt/chakra.js






const extendTheme = {}; // Recursively merge extended theme variables

const mergedTheme = Object(chakra_ui_styled_system_cjs["toCSSVar"])(Object(chakra_ui_utils_cjs["mergeWith"])(dist_default.a, extendTheme));
external_vue_default.a.prototype.$chakra = {
  theme: mergedTheme,
  icons: {
    "star": {
      "path": "\n      <path\n        fill=\"currentColor\"\n        d=\"M23.555,8.729a1.505,1.505,0,0,0-1.406-.98H16.062a.5.5,0,0,1-.472-.334L13.405,1.222a1.5,1.5,0,0,0-2.81,0l-.005.016L8.41,7.415a.5.5,0,0,1-.471.334H1.85A1.5,1.5,0,0,0,.887,10.4l5.184,4.3a.5.5,0,0,1,.155.543L4.048,21.774a1.5,1.5,0,0,0,2.31,1.684l5.346-3.92a.5.5,0,0,1,.591,0l5.344,3.919a1.5,1.5,0,0,0,2.312-1.683l-2.178-6.535a.5.5,0,0,1,.155-.543l5.194-4.306A1.5,1.5,0,0,0,23.555,8.729Z\"\n      />\n    "
    },
    "email": {
      "path": "\n    <g fill=\"currentColor\">\n      <path d=\"M11.114,14.556a1.252,1.252,0,0,0,1.768,0L22.568,4.87a.5.5,0,0,0-.281-.849A1.966,1.966,0,0,0,22,4H2a1.966,1.966,0,0,0-.289.021.5.5,0,0,0-.281.849Z\" />\n      <path d=\"M23.888,5.832a.182.182,0,0,0-.2.039l-6.2,6.2a.251.251,0,0,0,0,.354l5.043,5.043a.75.75,0,1,1-1.06,1.061l-5.043-5.043a.25.25,0,0,0-.354,0l-2.129,2.129a2.75,2.75,0,0,1-3.888,0L7.926,13.488a.251.251,0,0,0-.354,0L2.529,18.531a.75.75,0,0,1-1.06-1.061l5.043-5.043a.251.251,0,0,0,0-.354l-6.2-6.2a.18.18,0,0,0-.2-.039A.182.182,0,0,0,0,6V18a2,2,0,0,0,2,2H22a2,2,0,0,0,2-2V6A.181.181,0,0,0,23.888,5.832Z\" />\n    </g>\n    "
    },
    "phone": {
      "viewBox": "0 0 14 14",
      "path": "\n    <path\n      fill=\"currentColor\"\n      d=\"M2.20731,0.0127209 C2.1105,-0.0066419 1.99432,-0.00664663 1.91687,0.032079 C0.871279,0.438698 0.212942,1.92964 0.0580392,2.95587 C-0.426031,6.28627 2.20731,9.17133 4.62766,11.0689 C6.77694,12.7534 10.9012,15.5223 13.3409,12.8503 C13.6507,12.5211 14.0186,12.037 13.9993,11.553 C13.9412,10.7397 13.186,10.1588 12.6051,9.71349 C12.1598,9.38432 11.2304,8.47427 10.6495,8.49363 C10.1267,8.51299 9.79754,9.05515 9.46837,9.38432 L8.88748,9.96521 C8.79067,10.062 7.55145,9.24878 7.41591,9.15197 C6.91248,8.8228 6.4284,8.45491 6.00242,8.04829 C5.57644,7.64167 5.18919,7.19632 4.86002,6.73161 C4.7632,6.59607 3.96933,5.41495 4.04678,5.31813 C4.04678,5.31813 4.72448,4.58234 4.91811,4.2919 C5.32473,3.67229 5.63453,3.18822 5.16982,2.45243 C4.99556,2.18135 4.78257,1.96836 4.55021,1.73601 C4.14359,1.34875 3.73698,0.942131 3.27227,0.612963 C3.02055,0.419335 2.59457,0.0708094 2.20731,0.0127209 Z\"\n    />\n    "
    },
    "info": {
      "path": "\n    <path\n      fill=\"currentColor\"\n      d=\"M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z\"\n    />\n    "
    },
    "warning-alt": {
      "path": "\n      <path\n        fill=\"currentColor\"\n        d=\"M23.119,20,13.772,2.15h0a2,2,0,0,0-3.543,0L.881,20a2,2,0,0,0,1.772,2.928H21.347A2,2,0,0,0,23.119,20ZM11,8.423a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Zm1.05,11.51h-.028a1.528,1.528,0,0,1-1.522-1.47,1.476,1.476,0,0,1,1.448-1.53h.028A1.527,1.527,0,0,1,13.5,18.4,1.475,1.475,0,0,1,12.05,19.933Z\"\n      />"
    },
    "check": {
      "path": "\n      <g fill=\"currentColor\">\n        <polygon points=\"5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039\" />\n      </g>\n    ",
      "viewBox": "0 0 14 14"
    },
    "check-circle": {
      "path": "\n      <path\n        fill=\"currentColor\"\n        d=\"M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z\"\n      />"
    },
    "exclamation": {
      "path": "\n      <path\n        fill=\"currentColor\"\n        d=\"M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z\"\n      />"
    },
    "question-outline": {
      "viewBox": "0 0 24 24",
      "path": "\n    <g stroke=\"currentColor\" strokeWidth=\"1.5\">\n      <path\n        strokeLinecap=\"full\"\n        fill=\"none\"\n        d=\"M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25\"\n      />\n      <path\n        fill=\"none\"\n        strokeLinecap=\"full\"\n        d=\"M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0\"\n      />\n      <circle fill=\"none\" strokeMiterlimit=\"10\" cx=\"12\" cy=\"12\" r=\"11.25\" />\n    </g>\n    "
    },
    "close": {
      "path": "\n      <path\n        fill=\"currentColor\"\n        d=\"M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z\"\n      />"
    },
    "chevron-right": {
      "path": "\n    <path\n      fill=\"currentColor\"\n      d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"\n    />"
    },
    "chevron-left": {
      "path": "\n      <path\n        fill=\"currentColor\"\n        d=\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\"\n      />"
    },
    "chevron-down": {
      "path": "\n    <path\n      fill=\"currentColor\"\n      d=\"M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z\"\n    />"
    },
    "chevron-up": {
      "path": "\n    <path\n      fill=\"currentColor\"\n      d=\"M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z\"\n    />"
    },
    "arrow-forward": {
      "path": "\n    <path\n      fill=\"currentColor\"\n      d=\"M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z\"\n    />"
    },
    "arrow-up": {
      "path": "\n    <path\n      fill=\"currentColor\"\n      d=\"M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z\"\n    />"
    },
    "arrow-down": {
      "path": "\n      <path\n        fill=\"currentColor\"\n        d=\"M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z\"\n      />"
    },
    "add": {
      "path": "\n    <path\n      fill=\"currentColor\"\n      d=\"M0,12a1.5,1.5,0,0,0,1.5,1.5h8.75a.25.25,0,0,1,.25.25V22.5a1.5,1.5,0,0,0,3,0V13.75a.25.25,0,0,1,.25-.25H22.5a1.5,1.5,0,0,0,0-3H13.75a.25.25,0,0,1-.25-.25V1.5a1.5,1.5,0,0,0-3,0v8.75a.25.25,0,0,1-.25.25H1.5A1.5,1.5,0,0,0,0,12Z\"\n    />\n    "
    },
    "minus": {
      "path": "\n      <g fill=\"currentColor\">\n        <rect height=\"4\" width=\"20\" x=\"2\" y=\"10\" />\n      </g>\n    "
    },
    "moon": {
      "path": "\n      <path\n        fill=\"currentColor\"\n        d=\"M21.4,13.7C20.6,13.9,19.8,14,19,14c-5,0-9-4-9-9c0-0.8,0.1-1.6,0.3-2.4c0.1-0.3,0-0.7-0.3-1 c-0.3-0.3-0.6-0.4-1-0.3C4.3,2.7,1,7.1,1,12c0,6.1,4.9,11,11,11c4.9,0,9.3-3.3,10.6-8.1c0.1-0.3,0-0.7-0.3-1 C22.1,13.7,21.7,13.6,21.4,13.7z\"\n      />\n    "
    },
    "sun": {
      "path": "\n      <g\n        strokeLinejoin=\"full\"\n        strokeLinecap=\"full\"\n        strokeWidth=\"2\"\n        fill=\"none\"\n        stroke=\"currentColor\"\n      >\n        <circle cx=\"12\" cy=\"12\" r=\"5\" />\n        <path d=\"M12 1v2\" />\n        <path d=\"M12 21v2\" />\n        <path d=\"M4.22 4.22l1.42 1.42\" />\n        <path d=\"M18.36 18.36l1.42 1.42\" />\n        <path d=\"M1 12h2\" />\n        <path d=\"M21 12h2\" />\n        <path d=\"M4.22 19.78l1.42-1.42\" />\n        <path d=\"M18.36 5.64l1.42-1.42\" />\n      </g>\n    "
    },
    "warning": {
      "path": "\n    <path\n      fill=\"currentColor\"\n      d=\"M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z\"\n    />"
    },
    "small-close": {
      "path": "\n      <path\n        d=\"M9.41 8l2.29-2.29c.19-.18.3-.43.3-.71a1.003 1.003 0 0 0-1.71-.71L8 6.59l-2.29-2.3a1.003 1.003 0 0 0-1.42 1.42L6.59 8 4.3 10.29c-.19.18-.3.43-.3.71a1.003 1.003 0 0 0 1.71.71L8 9.41l2.29 2.29c.18.19.43.3.71.3a1.003 1.003 0 0 0 .71-1.71L9.41 8z\"\n        fillRule=\"evenodd\"\n        fill=\"currentColor\"\n      />\n    ",
      "viewBox": "0 0 16 16"
    },
    "triangle-up": {
      "path": "\n      <path\n        fill=\"currentColor\"\n        d=\"M12.8,5.4c-0.377-0.504-1.223-0.504-1.6,0l-9,12c-0.228,0.303-0.264,0.708-0.095,1.047 C2.275,18.786,2.621,19,3,19h18c0.379,0,0.725-0.214,0.895-0.553c0.169-0.339,0.133-0.744-0.095-1.047L12.8,5.4z\"\n      />\n    "
    },
    "triangle-down": {
      "path": "\n      <path\n        fill=\"currentColor\"\n        d=\"M21,5H3C2.621,5,2.275,5.214,2.105,5.553C1.937,5.892,1.973,6.297,2.2,6.6l9,12 c0.188,0.252,0.485,0.4,0.8,0.4s0.611-0.148,0.8-0.4l9-12c0.228-0.303,0.264-0.708,0.095-1.047C21.725,5.214,21.379,5,21,5z\"\n      />\n    "
    }
  }
};
external_vue_default.a.mixin({
  computed: {
    chakraColorMode() {
      return cjs["localColorModeObserver"].colorMode;
    },

    chakraTheme() {
      return cjs["localColorModeObserver"].theme;
    },

    chakraToggleColorMode() {
      return cjs["localColorModeObserver"].toggleColorMode;
    },

    $mode: vm => (lightValue, darkValue) => Object(cjs["mode"])(lightValue, darkValue, cjs["localColorModeObserver"])
  }
});
external_vue_default.a.directive('chakra', createClientDirective(mergedTheme));

if (false) {}
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/index.js










/* Plugins */

 // Source: ./components/plugin.js (mode: 'all')

 // Source: ./emotion.js (mode: 'client')

 // Source: ./chakra.js (mode: 'all')
// Component: <ClientOnly>

external_vue_default.a.component(external_vue_client_only_default.a.name, external_vue_client_only_default.a); // TODO: Remove in Nuxt 3: <NoSsr>

external_vue_default.a.component(external_vue_no_ssr_default.a.name, { ...external_vue_no_ssr_default.a,

  render(h, ctx) {
    if (false) {}

    return external_vue_no_ssr_default.a.render(h, ctx);
  }

}); // Component: <NuxtChild>

external_vue_default.a.component(nuxt_child.name, nuxt_child);
external_vue_default.a.component('NChild', nuxt_child); // Component NuxtLink is imported in server.js or client.js
// Component: <Nuxt>

external_vue_default.a.component(components_nuxt.name, components_nuxt);
Object.defineProperty(external_vue_default.a.prototype, '$nuxt', {
  get() {
    const globalNuxt = this.$root.$options.$nuxt;

    if (false) {}

    return globalNuxt;
  },

  configurable: true
});
external_vue_default.a.use(external_vue_meta_default.a, {
  "keyName": "head",
  "attribute": "data-n-head",
  "ssrAttribute": "data-n-head-ssr",
  "tagIDKeyName": "hid"
});
const defaultTransition = {
  "name": "page",
  "mode": "out-in",
  "appear": false,
  "appearClass": "appear",
  "appearActiveClass": "appear-active",
  "appearToClass": "appear-to"
};

async function createApp(ssrContext, config = {}) {
  const router = await createRouter(ssrContext, config); // Create Root instance
  // here we inject the router and store to all child components,
  // making them available everywhere as `this.$router` and `this.$store`.

  const app = {
    head: {
      "title": "chwan97",
      "htmlAttrs": {
        "lang": "en"
      },
      "meta": [{
        "charset": "utf-8"
      }, {
        "name": "viewport",
        "content": "width=device-width, initial-scale=1"
      }, {
        "hid": "description",
        "name": "description",
        "content": ""
      }, {
        "name": "format-detection",
        "content": "telephone=no"
      }],
      "link": [{
        "rel": "icon",
        "type": "image\u002Fx-icon",
        "href": "\u002Ffavicon.ico"
      }],
      "style": [],
      "script": []
    },
    router,
    nuxt: {
      defaultTransition,
      transitions: [defaultTransition],

      setTransitions(transitions) {
        if (!Array.isArray(transitions)) {
          transitions = [transitions];
        }

        transitions = transitions.map(transition => {
          if (!transition) {
            transition = defaultTransition;
          } else if (typeof transition === 'string') {
            transition = Object.assign({}, defaultTransition, {
              name: transition
            });
          } else {
            transition = Object.assign({}, defaultTransition, transition);
          }

          return transition;
        });
        this.$options.nuxt.transitions = transitions;
        return transitions;
      },

      err: null,
      dateErr: null,

      error(err) {
        err = err || null;
        app.context._errored = Boolean(err);
        err = err ? normalizeError(err) : null;
        let nuxt = app.nuxt; // to work with @vue/composition-api, see https://github.com/nuxt/nuxt.js/issues/6517#issuecomment-573280207

        if (this) {
          nuxt = this.nuxt || this.$options.nuxt;
        }

        nuxt.dateErr = Date.now();
        nuxt.err = err; // Used in src/server.js

        if (ssrContext) {
          ssrContext.nuxt.error = err;
        }

        return err;
      }

    },
    ...App
  };
  const next = ssrContext ? ssrContext.next : location => app.router.push(location); // Resolve route

  let route;

  if (ssrContext) {
    route = router.resolve(ssrContext.url).route;
  } else {
    const path = getLocation(router.options.base, router.options.mode);
    route = router.resolve(path).route;
  } // Set context to app.context


  await setContext(app, {
    route,
    next,
    error: app.nuxt.error.bind(app),
    payload: ssrContext ? ssrContext.payload : undefined,
    req: ssrContext ? ssrContext.req : undefined,
    res: ssrContext ? ssrContext.res : undefined,
    beforeRenderFns: ssrContext ? ssrContext.beforeRenderFns : undefined,
    ssrContext
  });

  function inject(key, value) {
    if (!key) {
      throw new Error('inject(key, value) has no key provided');
    }

    if (value === undefined) {
      throw new Error(`inject('${key}', value) has no value provided`);
    }

    key = '$' + key; // Add into app

    app[key] = value; // Add into context

    if (!app.context[key]) {
      app.context[key] = value;
    } // Check if plugin not already installed


    const installKey = '__nuxt_' + key + '_installed__';

    if (external_vue_default.a[installKey]) {
      return;
    }

    external_vue_default.a[installKey] = true; // Call Vue.use() to install the plugin into vm

    external_vue_default.a.use(() => {
      if (!Object.prototype.hasOwnProperty.call(external_vue_default.a.prototype, key)) {
        Object.defineProperty(external_vue_default.a.prototype, key, {
          get() {
            return this.$root.$options[key];
          }

        });
      }
    });
  } // Inject runtime config as $config


  inject('config', config); // Add enablePreview(previewData = {}) in context for plugins

  if (false) {} // Plugin execution


  if (typeof /* Cannot get final name for export "default" in "./node_modules/.cache/nuxt/components/plugin.js" (known exports: , known reexports: ) */ undefined === 'function') {
    await /* Cannot get final name for export "default" in "./node_modules/.cache/nuxt/components/plugin.js" (known exports: , known reexports: ) */ undefined(app.context, inject);
  }

  if (false) {}

  if (typeof /* Cannot get final name for export "default" in "./node_modules/.cache/nuxt/chakra.js" (known exports: , known reexports: ) */ undefined === 'function') {
    await /* Cannot get final name for export "default" in "./node_modules/.cache/nuxt/chakra.js" (known exports: , known reexports: ) */ undefined(app.context, inject);
  } // Lock enablePreview in context


  if (false) {} // Wait for async component to be resolved first


  await new Promise((resolve, reject) => {
    // Ignore 404s rather than blindly replacing URL in browser
    if (false) {}

    router.replace(app.context.route.fullPath, resolve, err => {
      // https://github.com/vuejs/vue-router/blob/v3.4.3/src/util/errors.js
      if (!err._isRouter) return reject(err);
      if (err.type !== 2
      /* NavigationFailureType.redirected */
      ) return resolve(); // navigated to a different route in router guard

      const unregister = router.afterEach(async (to, from) => {
        if ( true && ssrContext && ssrContext.url) {
          ssrContext.url = to.fullPath;
        }

        app.context.route = await getRouteData(to);
        app.context.params = to.params || {};
        app.context.query = to.query || {};
        unregister();
        resolve();
      });
    });
  });
  return {
    app,
    router
  };
}


// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-link.server.js

/* harmony default export */ var nuxt_link_server = ({
  name: 'NuxtLink',
  extends: external_vue_default.a.component('RouterLink'),
  props: {
    prefetch: {
      type: Boolean,
      default: true
    },
    noPrefetch: {
      type: Boolean,
      default: false
    }
  }
});
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/server.js







 // should be included after ./index.js
// Update serverPrefetch strategy

external_vue_default.a.config.optionMergeStrategies.serverPrefetch = external_vue_default.a.config.optionMergeStrategies.created; // Fetch mixin

if (!external_vue_default.a.__nuxt__fetch__mixin__) {
  external_vue_default.a.mixin(fetch_server);
  external_vue_default.a.__nuxt__fetch__mixin__ = true;
} // Component: <NuxtLink>


external_vue_default.a.component(nuxt_link_server.name, nuxt_link_server);
external_vue_default.a.component('NLink', nuxt_link_server);

if (!global.fetch) {
  global.fetch = external_node_fetch_default.a;
}

const noopApp = () => new external_vue_default.a({
  render: h => h('div', {
    domProps: {
      id: '__nuxt'
    }
  })
});

const createNext = ssrContext => opts => {
  // If static target, render on client-side
  ssrContext.redirected = opts;

  if (ssrContext.target === 'static' || !ssrContext.res) {
    ssrContext.nuxt.serverRendered = false;
    return;
  }

  let fullPath = Object(external_ufo_["withQuery"])(opts.path, opts.query);
  const $config = ssrContext.runtimeConfig || {};
  const routerBase = $config._app && $config._app.basePath || '/';

  if (!fullPath.startsWith('http') && routerBase !== '/' && !fullPath.startsWith(routerBase)) {
    fullPath = Object(external_ufo_["joinURL"])(routerBase, fullPath);
  } // Avoid loop redirect


  if (decodeURI(fullPath) === decodeURI(ssrContext.url)) {
    ssrContext.redirected = false;
    return;
  }

  ssrContext.res.writeHead(opts.status, {
    Location: Object(external_ufo_["normalizeURL"])(fullPath)
  });
  ssrContext.res.end();
}; // This exported function will be called by `bundleRenderer`.
// This is where we perform data-prefetching to determine the
// state of our application before actually rendering it.
// Since data fetching is async, this function is expected to
// return a Promise that resolves to the app instance.


/* harmony default export */ var server = __webpack_exports__["default"] = (async ssrContext => {
  // Create ssrContext.next for simulate next() of beforeEach() when wanted to redirect
  ssrContext.redirected = false;
  ssrContext.next = createNext(ssrContext); // Used for beforeNuxtRender({ Components, nuxtState })

  ssrContext.beforeRenderFns = []; // Nuxt object (window.{{globals.context}}, defaults to window.__NUXT__)

  ssrContext.nuxt = {
    layout: 'default',
    data: [],
    fetch: {},
    error: null,
    serverRendered: true,
    routePath: ''
  };
  ssrContext.fetchCounters = {}; // Remove query from url is static target

  if (ssrContext.url) {
    ssrContext.url = ssrContext.url.split('?')[0];
  } // Public runtime config


  ssrContext.nuxt.config = ssrContext.runtimeConfig.public;

  if (ssrContext.nuxt.config._app) {
    __webpack_require__.p = Object(external_ufo_["joinURL"])(ssrContext.nuxt.config._app.cdnURL, ssrContext.nuxt.config._app.assetsPath);
  } // Create the app definition and the instance (created for each request)


  const {
    app,
    router
  } = await createApp(ssrContext, ssrContext.runtimeConfig.private);

  const _app = new external_vue_default.a(app); // Add ssr route path to nuxt context so we can account for page navigation between ssr and csr


  ssrContext.nuxt.routePath = app.context.route.path; // Add meta infos (used in renderer.js)

  ssrContext.meta = _app.$meta(); // Keep asyncData for each matched component in ssrContext (used in app/utils.js via this.$ssrContext)

  ssrContext.asyncData = {};

  const beforeRender = async () => {
    // Call beforeNuxtRender() methods
    await Promise.all(ssrContext.beforeRenderFns.map(fn => promisify(fn, {
      Components,
      nuxtState: ssrContext.nuxt
    })));
  };

  const renderErrorPage = async () => {
    // Don't server-render the page in static target
    if (ssrContext.target === 'static') {
      ssrContext.nuxt.serverRendered = false;
    } // Load layout for error page


    const layout = (nuxt_error.options || nuxt_error).layout;
    const errLayout = typeof layout === 'function' ? layout.call(nuxt_error, app.context) : layout;
    ssrContext.nuxt.layout = errLayout || 'default';
    await _app.loadLayout(errLayout);

    _app.setLayout(errLayout);

    await beforeRender();
    return _app;
  };

  const render404Page = () => {
    app.context.error({
      statusCode: 404,
      path: ssrContext.url,
      message: 'This page could not be found'
    });
    return renderErrorPage();
  }; // Components are already resolved by setContext -> getRouteData (app/utils.js)


  const Components = getMatchedComponents(app.context.route);
  /*
  ** Call global middleware (nuxt.config.js)
  */

  let midd = [];
  midd = midd.map(name => {
    if (typeof name === 'function') {
      return name;
    }

    if (typeof nuxt_middleware[name] !== 'function') {
      app.context.error({
        statusCode: 500,
        message: 'Unknown middleware ' + name
      });
    }

    return nuxt_middleware[name];
  });
  await middlewareSeries(midd, app.context); // ...If there is a redirect or an error, stop the process

  if (ssrContext.redirected) {
    return noopApp();
  }

  if (ssrContext.nuxt.error) {
    return renderErrorPage();
  }
  /*
  ** Set layout
  */


  let layout = Components.length ? Components[0].options.layout : nuxt_error.layout;

  if (typeof layout === 'function') {
    layout = layout(app.context);
  }

  await _app.loadLayout(layout);

  if (ssrContext.nuxt.error) {
    return renderErrorPage();
  }

  layout = _app.setLayout(layout);
  ssrContext.nuxt.layout = _app.layoutName;
  /*
  ** Call middleware (layout + pages)
  */

  midd = [];
  layout = sanitizeComponent(layout);

  if (layout.options.middleware) {
    midd = midd.concat(layout.options.middleware);
  }

  Components.forEach(Component => {
    if (Component.options.middleware) {
      midd = midd.concat(Component.options.middleware);
    }
  });
  midd = midd.map(name => {
    if (typeof name === 'function') {
      return name;
    }

    if (typeof nuxt_middleware[name] !== 'function') {
      app.context.error({
        statusCode: 500,
        message: 'Unknown middleware ' + name
      });
    }

    return nuxt_middleware[name];
  });
  await middlewareSeries(midd, app.context); // ...If there is a redirect or an error, stop the process

  if (ssrContext.redirected) {
    return noopApp();
  }

  if (ssrContext.nuxt.error) {
    return renderErrorPage();
  }
  /*
  ** Call .validate()
  */


  let isValid = true;

  try {
    for (const Component of Components) {
      if (typeof Component.options.validate !== 'function') {
        continue;
      }

      isValid = await Component.options.validate(app.context);

      if (!isValid) {
        break;
      }
    }
  } catch (validationError) {
    // ...If .validate() threw an error
    app.context.error({
      statusCode: validationError.statusCode || '500',
      message: validationError.message
    });
    return renderErrorPage();
  } // ...If .validate() returned false


  if (!isValid) {
    // Render a 404 error page
    return render404Page();
  } // If no Components found, returns 404


  if (!Components.length) {
    return render404Page();
  } // Call asyncData & fetch hooks on components matched by the route.


  const asyncDatas = await Promise.all(Components.map(Component => {
    const promises = []; // Call asyncData(context)

    if (Component.options.asyncData && typeof Component.options.asyncData === 'function') {
      const promise = promisify(Component.options.asyncData, app.context);
      promise.then(asyncDataResult => {
        ssrContext.asyncData[Component.cid] = asyncDataResult;
        applyAsyncData(Component);
        return asyncDataResult;
      });
      promises.push(promise);
    } else {
      promises.push(null);
    } // Call fetch(context)


    if (Component.options.fetch && Component.options.fetch.length) {
      promises.push(Component.options.fetch(app.context));
    } else {
      promises.push(null);
    }

    return Promise.all(promises);
  })); // datas are the first row of each

  ssrContext.nuxt.data = asyncDatas.map(r => r[0] || {}); // ...If there is a redirect or an error, stop the process

  if (ssrContext.redirected) {
    return noopApp();
  }

  if (ssrContext.nuxt.error) {
    return renderErrorPage();
  } // Call beforeNuxtRender methods & add store state


  await beforeRender();
  return _app;
});

/***/ })
/******/ ]);
//# sourceMappingURL=server.js.map