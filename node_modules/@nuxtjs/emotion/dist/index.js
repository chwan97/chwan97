'use strict';

const path = require('path');
const server = require('@emotion/server');

function emotionModule(moduleOptions) {
  const defaults = {
    ssr: "critical",
    babel: {
      inline: true,
      sourceMap: this.options.dev
    }
  };
  const options = {
    ...defaults,
    ...moduleOptions,
    ...this.options.emotion
  };
  if (options.babel) {
    babel.call(this, options);
  }
  if (!options.ssr) {
    return;
  }
  const functionMap = {
    render: ssr,
    critical
  };
  const renderFn = functionMap[options.ssr];
  if (typeof renderFn === "undefined") {
    console.error(`[emotion] Invalid value "${options.ssr}" for \`emotion.ssr\``);
    return;
  }
  renderFn.call(this, options);
}
function babel(options) {
  this.nuxt.hook("build:before", () => {
    const {babel: babel2} = this.options.build;
    if (!babel2.plugins) {
      babel2.plugins = [];
    }
    babel2.plugins.unshift(["@emotion", {
      inline: true,
      ...options.babel
    }]);
  });
}
function critical(options) {
  this.nuxt.hook("build:before", () => {
    if (this.options.mode === "spa") {
      return;
    }
    this.addPlugin({
      src: path.resolve(__dirname, "../templates/emotion.js"),
      fileName: "emotion.js",
      ssr: false,
      options
    });
  });
  this.nuxt.hook("vue-renderer:ssr:templateParams", (params) => {
    const {ids, css} = server.extractCritical(params.APP);
    params.HEAD += `<style>${css}</style>`;
    params.HEAD += `<script>window.$emotionSSRIds = ${JSON.stringify(ids)}</script>`;
  });
}
function ssr() {
  this.nuxt.hook("vue-renderer:ssr:templateParams", (params) => {
    params.APP = server.renderStylesToString(params.APP);
  });
}
emotionModule.meta = require("../package.json");

module.exports = emotionModule;
